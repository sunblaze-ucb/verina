{
  "config": {
    "output_dir": "output/gpt-5-coq-1rnd",
    "max_workers": 128,
    "run_type": "generate_only",
    "rounds": 1,
    "fewshot_example_names": [
      "verina_basic_15",
      "verina_basic_44"
    ],
    "itp_type": "coq",
    "coq_config": {
      "use_quickchick": true,
      "quickchick_num_tests": 1000,
      "docker_image": "verina-coq"
    },
    "gen_lm_config": {
      "provider": "openai",
      "model_name": "gpt-5",
      "api_base": null,
      "api_key": null,
      "max_tokens": null
    },
    "baseline_config": {
      "name": "baseline",
      "combind_task_preference": "NO_GENERATED_AS_REF",
      "resume_from_checkpoint": true,
      "refinements": null,
      "dspy_module": null,
      "custom_prompt_template": null,
      "itp_type": "coq"
    },
    "code_gen": true,
    "spec_gen": true,
    "proof_gen": false,
    "code_spec_gen": false,
    "code_proof_gen": false,
    "spec_proof_gen": false,
    "code_spec_proof_gen": false,
    "eval_spec_config": {
      "spec_proving_lm_config": null,
      "formal_proving": false,
      "unit_test": true,
      "unit_test_proving": false,
      "use_grind": false,
      "use_plausible_pass": true,
      "evidence_rel_dir": "./evidence",
      "generate_evidence_template": false,
      "use_evidence": false,
      "save_evidence": true
    }
  },
  "generation_timestamp": 1768732173,
  "evaluated_version_timestamp": 0,
  "evaluation_timestamp": 0,
  "rounds": {
    "0": {
      "experiment_id": "output/gpt-5-coq-1rnd",
      "data_reports": {
        "verina_basic_1": {
          "data_id": "verina_basic_1",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper predicates on Z as booleans *)\nDefinition is_pos (z : Z) : bool := Z.gtb z 0.\nDefinition is_neg (z : Z) : bool := Z.ltb z 0.",
                "code": "(* True iff one is strictly positive and the other strictly negative *)\n  orb (andb (is_pos a) (is_neg b))\n      (andb (is_neg a) (is_pos b))",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true <-> ((Z.lt 0 a /\\ Z.lt b 0) \\/ (Z.lt 0 b /\\ Z.lt a 0)))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_1": {
          "data_id": "verina_advanced_1",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean membership check in a list of Z using Z.eqb *)\nFixpoint memZ (x : Z) (l : list Z) : bool :=\n  match l with\n  | nil => false\n  | y :: ys => if Z.eqb x y then true else memZ x ys\n  end.\n\n(* Remove the first occurrence of x from the list *)\nFixpoint remove_oneZ (x : Z) (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | y :: ys => if Z.eqb x y then ys else y :: remove_oneZ x ys\n  end.\n\n(* Toggle accumulator: add element if not present; remove if present *)\nFixpoint toggle_acc (l : list Z) (acc : list Z) : list Z :=\n  match l with\n  | nil => acc\n  | x :: xs =>\n      if memZ x acc\n      then toggle_acc xs (remove_oneZ x acc)\n      else toggle_acc xs (x :: acc)\n  end.",
                "code": "(* Reduce the list by toggling presence in an accumulator; duplicates cancel out *)\n  match toggle_acc nums nil with\n  | x :: _ => x\n  | nil => 0 (* Unreachable under the given precondition *)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "(* Count occurrences of a value x in a list l *)\nFixpoint occ (x : Z) (l : list Z) : nat :=\n  match l with\n  | nil => 0%nat\n  | y :: ys => if Z.eqb x y then S (occ x ys) else occ x ys\n  end.",
                "precond": "(* The input list has exactly one element occurring once; all others occur twice (or not at all). *)\n  exists x : Z,\n    occ x nums = 1%nat /\\\n    (forall y : Z, y <> x -> occ y nums = 0%nat \\/ occ y nums = 2%nat)",
                "postcond_aux": "",
                "postcond": "(* The result is precisely the unique element that occurs exactly once; all others occur twice (or not at all). *)\n  occ result nums = 1%nat /\\\n  (forall y : Z, y <> result -> occ y nums = 0%nat \\/ occ y nums = 2%nat)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_2": {
          "data_id": "verina_advanced_2",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Auxiliary function computing LCS length with a decreasing fuel n.\n   We start with n = length a + length b, and decrease n by 1 at each step,\n   ensuring structural recursion on n. *)\nFixpoint lcs_aux (n : nat) (a b : list Z) {struct n} : Z :=\n  match n with\n  | O => 0%Z\n  | S n' =>\n      match a, b with\n      | nil, _ => 0%Z\n      | _, nil => 0%Z\n      | x :: xs, y :: ys =>\n          if Z.eqb x y\n          then 1 + lcs_aux n' xs ys\n          else\n            let l1 := lcs_aux n' xs (y :: ys) in\n            let l2 := lcs_aux n' (x :: xs) ys in\n            Z.max l1 l2\n      end\n  end.",
                "code": "(* Initialize the decreasing fuel with the combined lengths of the lists. *)\n  lcs_aux (length a + length b)%nat a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Subsequence relation: s is a subsequence of l if s can be obtained by\n   deleting zero or more elements from l without changing the order. *)\nInductive subseq : list Z -> list Z -> Prop :=\n| subseq_nil : forall xs, subseq [] xs\n| subseq_cons : forall (x : Z) (xs ys : list Z), subseq xs ys -> subseq (x :: xs) (x :: ys)\n| subseq_skip : forall (y : Z) (xs ys : list Z), subseq xs ys -> subseq xs (y :: ys).",
                "postcond": "exists s : list Z,\n    subseq s a /\\\n    subseq s b /\\\n    result = Z.of_nat (List.length s) /\\\n    forall t : list Z, subseq t a -> subseq t b -> (Z.of_nat (List.length t) <= result)%Z",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_2": {
          "data_id": "verina_basic_2",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean comparison on natural numbers, defined recursively *)\nFixpoint my_leb (n m : nat) : bool :=\n  match n, m with\n  | O, _ => true\n  | S _, O => false\n  | S n', S m' => my_leb n' m'\n  end.\n\n(* Minimum of two natural numbers using the boolean comparator *)\nDefinition minNat (n m : nat) : nat :=\n  if my_leb n m then n else m.\n\n(* Compute the minimum element of a list of naturals *)\nFixpoint min_list (l : list nat) : option nat :=\n  match l with\n  | [] => None\n  | x :: xs =>\n      match min_list xs with\n      | None => Some x\n      | Some m => Some (minNat x m)\n      end\n  end.",
                "code": "(* Use the helper to find the smallest element, or None for empty lists *)\n  min_list s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = None <-> s = []) /\\\n  (forall m, result = Some m -> List.In m s /\\ (forall x, List.In x s -> m <= x)) /\\\n  (s <> [] -> exists m, result = Some m /\\ List.In m s /\\ (forall x, List.In x s -> m <= x))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_3": {
          "data_id": "verina_advanced_3",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function to compute maximum of two Z integers *)\nDefinition maxZ (x y : Z) : Z :=\n  if Z.leb x y then y else x.\n\n(* Fuel-based recursive computation of LCS length to ensure termination.\n   The fuel n can be taken as length l1 + length l2, which strictly decreases\n   along any recursive path. *)\nFixpoint lcs_fuel (n : nat) (l1 l2 : list Z) : Z :=\n  match n with\n  | O => 0%Z\n  | S n' =>\n      match l1, l2 with\n      | [], _ => 0%Z\n      | _, [] => 0%Z\n      | x :: xs, y :: ys =>\n          if Z.eqb x y\n          then 1%Z + lcs_fuel n' xs ys\n          else maxZ (lcs_fuel n' l1 ys) (lcs_fuel n' xs l2)\n      end\n  end.",
                "code": "(* Use fuel as the sum of lengths to guarantee termination *)\n  let n := (length a + length b)%nat in\n  lcs_fuel n a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Subsequence relation over lists of Z *)\nInductive subseqZ : list Z -> list Z -> Prop :=\n| subseqZ_nil : forall l, subseqZ [] l\n| subseqZ_skip : forall x l1 l2, subseqZ l1 l2 -> subseqZ l1 (x :: l2)\n| subseqZ_keep : forall x l1 l2, subseqZ l1 l2 -> subseqZ (x :: l1) (x :: l2).",
                "postcond": "exists c : list Z,\n    subseqZ c a /\\\n    subseqZ c b /\\\n    result = Z.of_nat (List.length c) /\\\n    (forall d : list Z, subseqZ d a -> subseqZ d b -> List.length d <= List.length c)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_3": {
          "data_id": "verina_basic_3",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Check if n modulo 11 equals 0 *)\n  Z.eqb (Z.modulo n 11) 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true <-> exists k : Z, n = 11 * k)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_4": {
          "data_id": "verina_advanced_4",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Replace the first element in the list >= x with x; if none, signal not replaced *)\nFixpoint insert_or_replace (x : Z) (l : list Z) : (list Z * bool) :=\n  match l with\n  | [] => ([], false)\n  | y :: ys =>\n      if Z.leb x y then\n        (x :: ys, true)\n      else\n        let (ys', r) := insert_or_replace x ys in\n        (y :: ys', r)\n  end.\n\n(* Process the input list to build the patience sorting tails list *)\nFixpoint process_list (l : list Z) (tails : list Z) : list Z :=\n  match l with\n  | [] => tails\n  | x :: xs =>\n      let (tails', replaced) := insert_or_replace x tails in\n      let tails2 := if replaced then tails' else (tails ++ [x]) in\n      process_list xs tails2\n  end.",
                "code": "let tails := process_list a [] in\n  Z.of_nat (List.length tails)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Inductive subseqZ : list Z -> list Z -> Prop :=\n| subseqZ_nil : forall l, subseqZ [] l\n| subseqZ_cons_right : forall x l1 l2, subseqZ l1 l2 -> subseqZ l1 (x :: l2)\n| subseqZ_cons_both : forall x l1 l2, subseqZ l1 l2 -> subseqZ (x :: l1) (x :: l2).\n\nFixpoint strict_increasing (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: t => x < y /\\ strict_increasing (y :: t)\n  end.",
                "postcond": "exists s : list Z,\n    subseqZ s a /\\\n    strict_increasing s /\\\n    result = Z.of_nat (List.length s) /\\\n    (forall t : list Z, subseqZ t a -> strict_increasing t -> Z.of_nat (List.length t) <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_4": {
          "data_id": "verina_basic_4",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function to fetch the k-th element (1-based) from a list of Z.\n   If k is out of bounds or zero, returns 0%Z as a default.\n   The precondition guarantees k is valid when used by kthElement. *)\nFixpoint kth1_aux (l : list Z) (k : nat) : Z :=\n  match l with\n  | nil => 0%Z\n  | x :: xs =>\n      match k with\n      | O => 0%Z\n      | S O => x\n      | S k' => kth1_aux xs k'\n      end\n  end.",
                "code": "kth1_aux arr k",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* k is 1-based and within bounds: k â‰  0 and the (k-1)-th (0-based) element exists *)\n  k <> 0 /\\ exists v : Z, List.nth_error arr (Nat.pred k) = Some v",
                "postcond_aux": "",
                "postcond": "(* The result is exactly the element at 1-based position k, i.e., index (k-1) in 0-based indexing *)\n  List.nth_error arr (Nat.pred k) = Some result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_5": {
          "data_id": "verina_basic_5",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "a * b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = a * b",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_5": {
          "data_id": "verina_advanced_5",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean less-than-or-equal for nat, used to detect s >= 10 by checking 10 <= s *)\nFixpoint leb (n m : nat) : bool :=\n  match n, m with\n  | 0, _ => true\n  | S _, 0 => false\n  | S n', S m' => leb n' m'\n  end.\n\n(* Mutual recursion to ensure structural decrease:\n   - add_c_l1 recurses structurally on l1\n   - add_c_l2 recurses structurally on l2\n   This avoids non-structural recursion when one list is empty. *)\nFixpoint add_c_l1 (l1 l2 : list nat) (c : nat) {struct l1} : list nat :=\n  match l1 with\n  | [] => add_c_l2 l2 c\n  | x :: xs =>\n      match l2 with\n      | [] =>\n          let s := x + c in\n          if leb 10 s then (s - 10) :: add_c_l1 xs [] 1\n          else s :: add_c_l1 xs [] 0\n      | y :: ys =>\n          let s := x + y + c in\n          if leb 10 s then (s - 10) :: add_c_l1 xs ys 1\n          else s :: add_c_l1 xs ys 0\n      end\n  end\nwith add_c_l2 (l2 : list nat) (c : nat) {struct l2} : list nat :=\n  match l2 with\n  | [] =>\n      match c with\n      | 0 => []\n      | S _ => [1]\n      end\n  | y :: ys =>\n      let s := y + c in\n      if leb 10 s then (s - 10) :: add_c_l2 ys 1\n      else s :: add_c_l2 ys 0\n  end.",
                "code": "(* Start the addition with zero carry. *)\n  add_c_l1 l1 l2 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Evaluate a list of digits (least significant first) as a natural number in base 10 *)\nFixpoint eval10 (l : list nat) : nat :=\n  match l with\n  | [] => 0\n  | d :: ds => d + 10 * eval10 ds\n  end.\n\n(* All elements are valid base-10 digits *)\nDefinition digits_ok (l : list nat) : Prop :=\n  Forall (fun d => d <= 9) l.",
                "postcond": "digits_ok result /\\\n  eval10 result = eval10 l1 + eval10 l2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_6": {
          "data_id": "verina_basic_6",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function to compute the minimum of two Z integers *)\nDefinition zmin2 (x y : Z) : Z :=\n  if x <=? y then x else y.",
                "code": "(* Minimum of three by composing the two-argument minimum *)\n  zmin2 (zmin2 a b) c",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result <= a /\\ result <= b /\\ result <= c)\n  /\\ (result = a \\/ result = b \\/ result = c)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_6": {
          "data_id": "verina_advanced_6",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper record to track which vowels have been seen *)\nRecord VState := {\n  seen_a : bool;\n  seen_e : bool;\n  seen_i : bool;\n  seen_o : bool;\n  seen_u : bool\n}.\n\nDefinition empty_state : VState :=\n  {| seen_a := false; seen_e := false; seen_i := false; seen_o := false; seen_u := false |}.\n\n(* Check if all vowels have been seen *)\nDefinition all_seen (st : VState) : bool :=\n  andb st.(seen_a)\n    (andb st.(seen_e)\n      (andb st.(seen_i)\n        (andb st.(seen_o) st.(seen_u)))).\n\n(* Update the state with a new character (case-insensitive) *)\nDefinition update_state (c : ascii) (st : VState) : VState :=\n  let n := Ascii.nat_of_ascii c in\n  (* lower/upper codes: a/A=97/65, e/E=101/69, i/I=105/73, o/O=111/79, u/U=117/85 *)\n  {| seen_a := orb st.(seen_a) (orb (Nat.eqb n 97) (Nat.eqb n 65));\n     seen_e := orb st.(seen_e) (orb (Nat.eqb n 101) (Nat.eqb n 69));\n     seen_i := orb st.(seen_i) (orb (Nat.eqb n 105) (Nat.eqb n 73));\n     seen_o := orb st.(seen_o) (orb (Nat.eqb n 111) (Nat.eqb n 79));\n     seen_u := orb st.(seen_u) (orb (Nat.eqb n 117) (Nat.eqb n 85)) |}.\n\n(* Traverse the string and collect vowel presence *)\nFixpoint collect_vowels (s : string) (st : VState) : VState :=\n  match s with\n  | EmptyString => st\n  | String c s' => collect_vowels s' (update_state c st)\n  end.",
                "code": "let st := collect_vowels s empty_state in\n  all_seen st",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Predicate: s contains the single-character string lit (case lit must be length 1) *)\nFixpoint contains1 (s lit : string) : Prop :=\n  match s with\n  | String.EmptyString => False\n  | String.String c s' =>\n      match lit with\n      | String.String d String.EmptyString =>\n          c = d \\/ contains1 s' (String.String d String.EmptyString)\n      | _ => False\n      end\n  end.\n\nDefinition all_vowels_ci (s : string) : Prop :=\n  (contains1 s \"a\"%string \\/ contains1 s \"A\"%string) /\\\n  (contains1 s \"e\"%string \\/ contains1 s \"E\"%string) /\\\n  (contains1 s \"i\"%string \\/ contains1 s \"I\"%string) /\\\n  (contains1 s \"o\"%string \\/ contains1 s \"O\"%string) /\\\n  (contains1 s \"u\"%string \\/ contains1 s \"U\"%string).",
                "postcond": "(result = true <-> all_vowels_ci s) /\\\n  (result = false <-> ~ all_vowels_ci s)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_7": {
          "data_id": "verina_advanced_7",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: tail-recursive fold to compute the decimal value from big-endian bits *)\nFixpoint bin2dec_aux (l : list nat) (acc : nat) : nat :=\n  match l with\n  | [] => acc\n  | d :: ds => bin2dec_aux ds (acc * 2 + d)\n  end.",
                "code": "(* Process digits from most-significant to least-significant using an accumulator *)\n  bin2dec_aux digits 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* Big-endian binary interpretation via left fold: acc := acc * 2 + d *)\n  result = fold_left (fun acc d => acc * 2 + d) digits 0",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_7": {
          "data_id": "verina_basic_7",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Use the closed-form formula: (n * (2n - 1) * (2n + 1)) / 3 *)\n  let two_n := Nat.mul 2 n in\n  Nat.div (Nat.mul (Nat.mul n (Nat.sub two_n 1)) (Nat.add two_n 1)) 3",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "3 * result = n * ((2 * n - 1) * (2 * n + 1))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_8": {
          "data_id": "verina_basic_8",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Return the smaller of a and b using Z.leb for comparison *)\n  if Z.leb a b then a else b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* result is one of the inputs and is a lower bound of both *)\n  result <= a /\\ result <= b /\\ (result = a \\/ result = b)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_8": {
          "data_id": "verina_advanced_8",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper recursive scanner implementing the greedy gas station algorithm.\n   It traverses both lists once, maintaining:\n   - i: current index (Z)\n   - start: current candidate start index (Z)\n   - tank: current fuel in tank considering the candidate start (Z)\n   - total: total net fuel over all processed stations (Z)\n   At the end, if total >= 0, a solution exists and is 'start'; otherwise, -1. *)\nFixpoint scan_gas (g c : list Z) (i start tank total : Z) {struct g} : Z :=\n  match g, c with\n  | x :: gs, y :: cs =>\n      let diff := x - y in\n      let tank' := tank + diff in\n      let total' := total + diff in\n      if Z.ltb tank' 0\n      then\n        (* Cannot reach station i+1 from current start; reset start to i+1 and tank to 0 *)\n        scan_gas gs cs (i + 1) (i + 1) 0 total'\n      else\n        (* Continue with the same start and updated tank *)\n        scan_gas gs cs (i + 1) start tank' total'\n  | _, _ =>\n      (* End of traversal (or mismatched lengths, though precondition guarantees equal non-zero length). *)\n      if Z.geb total 0 then start else -1\n  end.",
                "code": "(* Start scanning from index 0, with start=0, tank=0, total=0 *)\n  scan_gas gas cost 0 0 0 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* Equal non-zero lengths as per problem statement *)\n  List.length gas = List.length cost /\\ 0 < List.length gas",
                "postcond_aux": "(* Sum of first (k+1) values of a function f : nat -> Z *)\nFixpoint sum_upto (k : nat) (f : nat -> Z) : Z :=\n  match k with\n  | 0 => f 0\n  | S k' => sum_upto k' f + f (S k')\n  end.\n\n(* Cyclic index over [0, n) starting from r, advancing by t *)\nDefinition cyc_index (n r t : nat) : nat :=\n  if Nat.ltb (r + t) n then (r + t) else (r + t - n).\n\n(* Pointwise difference gas[i] - cost[i] at index i *)\nDefinition diff_at (gas cost : list Z) (i : nat) : Z :=\n  (List.nth i gas 0%Z) - (List.nth i cost 0%Z).\n\n(* Prefix sum of length (k+1) along the cycle starting at r *)\nDefinition prefix_sum (gas cost : list Z) (r k : nat) : Z :=\n  sum_upto k (fun t => diff_at gas cost (cyc_index (List.length gas) r t)).\n\n(* A starting index r is valid if every prefix sum along the n-step tour is nonnegative *)\nDefinition valid_start (gas cost : list Z) (r : nat) : Prop :=\n  r < List.length gas /\\\n  forall k, k < List.length gas -> 0 <= prefix_sum gas cost r k.",
                "postcond": "let n := List.length gas in\n  (* Either there is no valid start and result = -1,\n     or result is the smallest valid starting index (encoded as a Z). *)\n  (\n    result = (-1)%Z /\\\n    (forall r : nat, r < n -> ~ valid_start gas cost r)\n  )\n  \\/\n  (\n    exists r : nat,\n      result = Z.of_nat r /\\\n      r < n /\\\n      valid_start gas cost r /\\\n      (forall j : nat, j < n -> valid_start gas cost j -> r <= j)\n  )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_9": {
          "data_id": "verina_basic_9",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: check if an element x appears in list l using Z.eqb *)\nFixpoint memZ (x : Z) (l : list Z) : bool :=\n  match l with\n  | nil => false\n  | y :: ys => if Z.eqb x y then true else memZ x ys\n  end.\n\n(* Helper function: check if there exists any common element between two lists *)\nFixpoint has_common (l1 : list Z) (l2 : list Z) : bool :=\n  match l1 with\n  | nil => false\n  | x :: xs => if memZ x l2 then true else has_common xs l2\n  end.",
                "code": "has_common a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true <-> exists x : Z, In x a /\\ In x b)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_9": {
          "data_id": "verina_advanced_9",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Sum of digits using a fuel-based recursion to ensure structural decrease *)\nFixpoint sum_digits_fuel (n fuel : nat) : nat :=\n  match fuel with\n  | 0 => 0\n  | S fuel' =>\n      if Nat.ltb n 10 then n\n      else (Nat.modulo n 10) + sum_digits_fuel (Nat.div n 10) fuel'\n  end.\n\nDefinition sum_digits (n : nat) : nat :=\n  sum_digits_fuel n (S n).\n\n(* Count numbers k < n such that sum_digits(k) is divisible by d *)\nFixpoint count_upto (d k : nat) : nat :=\n  match k with\n  | 0 => 0\n  | S k' =>\n      let cnt := count_upto d k' in\n      let s := sum_digits k' in\n      if Nat.eqb (Nat.modulo s d) 0 then S cnt else cnt\n  end.",
                "code": "count_upto d n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "0 < d",
                "postcond_aux": "(* Inductive relation capturing the base-10 digit sum of a natural number. *)\nInductive digit_sum10 : nat -> nat -> Prop :=\n| ds_zero : digit_sum10 0 0\n| ds_step : forall n s, n > 0 -> digit_sum10 (n / 10) s -> digit_sum10 n ((n mod 10) + s).\n\n(* A simple no-duplicate predicate specialized to lists of nat *)\nInductive NoDupNat : list nat -> Prop :=\n| NDN_nil : NoDupNat nil\n| NDN_cons : forall x l, ~ In x l -> NoDupNat l -> NoDupNat (cons x l).",
                "postcond": "exists (l : list nat),\n    NoDupNat l /\\\n    (forall m, (m < n /\\ (exists s, digit_sum10 m s /\\ s mod d = 0)) <-> In m l) /\\\n    length l = result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_10": {
          "data_id": "verina_advanced_10",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: search for a quotient k (0 â‰¤ k â‰¤ bound) such that p * k = n.\n   Returns Some k when found, otherwise None. *)\nFixpoint find_quotient_upto (bound p n : nat) : option nat :=\n  match bound with\n  | 0 =>\n      if Nat.eqb (p * 0) n then Some 0 else None\n  | S bound' =>\n      if Nat.eqb (p * (S bound')) n then Some (S bound')\n      else find_quotient_upto bound' p n\n  end.\n\n(* Try to divide m by p once. If divisible, return Some q with m = p * q; else None. *)\nDefinition divide_once (m p : nat) : option nat :=\n  find_quotient_upto m p m.\n\n(* Count how many times p divides m, threading the remaining value and the count.\n   A fuel parameter ensures structural recursion termination. *)\nFixpoint multiplicity_fuel (fuel m p acc : nat) : (nat * nat) :=\n  match fuel with\n  | 0 => (m, acc)\n  | S fuel' =>\n      match divide_once m p with\n      | Some q => multiplicity_fuel fuel' q p (S acc)\n      | None => (m, acc)\n      end\n  end.\n\n(* Convenience wrapper: start fuel at m and accumulator at 0. \n   Returns (remaining, exponent). *)\nDefinition multiplicity (m p : nat) : (nat * nat) :=\n  multiplicity_fuel m m p 0.\n\n(* Factor the number m with respect to the given list of primes, in order.\n   For each prime p, compute its exponent e and update the remaining m accordingly. *)\nFixpoint factor_primes (primes : list nat) (m : nat) : list (nat * nat) :=\n  match primes with\n  | [] => []\n  | p :: ps =>\n      let res := multiplicity m p in\n      let m' := fst res in\n      let e  := snd res in\n      (p, e) :: factor_primes ps m'\n  end.",
                "code": "(* Compute exponents for each prime in the list, threading the remaining value. *)\n  factor_primes primes n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "(* Auxiliary arithmetic and predicates needed for the specification *)\n\nFixpoint pow (a : nat) (e : nat) : nat :=\n  match e with\n  | 0 => 1\n  | S e' => a * pow a e'\n  end.\n\nFixpoint pow_prod (ps : list nat) (es : list nat) : nat :=\n  match ps, es with\n  | [], [] => 1\n  | p :: ps', e :: es' => pow p e * pow_prod ps' es'\n  | _, _ => 1 (* length mismatch is ruled out by a separate constraint *)\n  end.\n\nDefinition divides (d n : nat) : Prop := exists k, n = d * k.\n\nDefinition is_prime (p : nat) : Prop :=\n  2 <= p /\\ forall d, divides d p -> d = 1 \\/ d = p.",
                "precond": "(* Preconditions from the task:\n     - n > 0\n     - primes is non-empty\n     - primes contains pairwise distinct prime numbers\n     - n can be expressed as a product of powers of the given primes\n  *)\n  0 < n /\\\n  primes <> [] /\\\n  NoDup primes /\\\n  (forall p, In p primes -> is_prime p) /\\\n  exists es, length es = length primes /\\ n = pow_prod primes es",
                "postcond_aux": "(* Product over (prime, exponent) pairs *)\nFixpoint pow_pairs_prod (l : list (nat * nat)) : nat :=\n  match l with\n  | [] => 1\n  | (p, e) :: xs => pow p e * pow_pairs_prod xs\n  end.",
                "postcond": "(* Soundness and completeness of the returned factorization:\n     - The product of p^e over the result equals n\n     - Every pair (p, e) in the result has p from the input primes\n     - Every input prime appears in the result (with some exponent)\n     - Each input prime appears with a unique exponent in the result\n  *)\n  n = pow_pairs_prod result /\\\n  (forall p e, In (p, e) result -> In p primes) /\\\n  (forall p, In p primes -> exists e, In (p, e) result) /\\\n  (forall p e1 e2, In (p, e1) result -> In (p, e2) result -> e1 = e2)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_10": {
          "data_id": "verina_basic_10",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: returns true iff every element of l is strictly less than n *)\nFixpoint all_lt (n : Z) (l : list Z) : bool :=\n  match l with\n  | nil => true\n  | x :: xs =>\n      if Z.ltb x n\n      then all_lt n xs\n      else false\n  end.",
                "code": "all_lt n a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "((result = true) <-> (forall x, List.In x a -> Z.lt x n)) /\\\n  ((result = false) <-> (exists x, List.In x a /\\ Z.ge x n))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_11": {
          "data_id": "verina_advanced_11",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Compute the length of a list as a Z value *)\nFixpoint zlength (lst : list Z) : Z :=\n  match lst with\n  | [] => 0\n  | _ :: xs => 1 + zlength xs\n  end.\n\n(* Count occurrences of a given Z value in a list *)\nFixpoint count_occ_z (lst : list Z) (v : Z) : Z :=\n  match lst with\n  | [] => 0\n  | x :: xs =>\n      (if Z.eqb x v then 1 else 0) + count_occ_z xs v\n  end.\n\n(* Boyer-Moore majority vote to obtain a candidate and its counter *)\nFixpoint majority_vote_candidate (lst : list Z) (cand : Z) (count : Z) {struct lst} : Z * Z :=\n  match lst with\n  | [] => (cand, count)\n  | x :: xs =>\n      if Z.eqb count 0\n      then majority_vote_candidate xs x 1\n      else if Z.eqb x cand\n           then majority_vote_candidate xs cand (count + 1)\n           else majority_vote_candidate xs cand (count - 1)\n  end.",
                "code": "(* First, obtain a candidate using Boyer-Moore majority vote algorithm *)\n  let p := majority_vote_candidate lst 0 0 in\n  match p with\n  | (cand, _) =>\n      (* Verify the candidate by counting its occurrences *)\n      let cnt := count_occ_z lst cand in\n      if Z.gtb (cnt * 2) (zlength lst)\n      then cand\n      else (-1)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* Either:\n     - No majority element exists and result = -1, or\n     - There exists a majority element x (appearing strictly more than half the list length),\n       and result = x. *)\n  ((result = (-1)) /\\\n     ~ (exists x : Z,\n          Nat.lt (Nat.div (List.length lst) 2)\n                 (count_occ Z.eq_dec lst x)))\n  \\/\n  (exists x : Z,\n      Nat.lt (Nat.div (List.length lst) 2)\n             (count_occ Z.eq_dec lst x)\n    /\\ result = x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_11": {
          "data_id": "verina_basic_11",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "n mod 10",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = Nat.modulo n 10 /\\ result <= 9",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_12": {
          "data_id": "verina_advanced_12",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: Boolean membership check for Z in a list using Z.eqb *)\nFixpoint memZb (x : Z) (l : list Z) : bool :=\n  match l with\n  | [] => false\n  | y :: ys => if Z.eqb x y then true else memZb x ys\n  end.\n\n(* Helper: Scan the list from left to right, tracking seen elements.\n   Return the first element whose second occurrence is encountered. *)\nFixpoint firstDuplicateAux (lst : list Z) (seen : list Z) : option Z :=\n  match lst with\n  | [] => None\n  | x :: xs =>\n      if memZb x seen\n      then Some x\n      else firstDuplicateAux xs (x :: seen)\n  end.",
                "code": "(* Use an auxiliary function with an accumulator of seen elements *)\n  firstDuplicateAux lst []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* A duplicate occurs at position j if the element at j also appeared at some earlier index i < j. *)\nDefinition duplicate_at (l : list Z) (j : nat) : Prop :=\n  exists x, nth_error l j = Some x /\\ exists i, i < j /\\ nth_error l i = Some x.\n\n(* j is the first index (from left to right) where a duplicate is found. *)\nDefinition first_duplicate_index (l : list Z) (j : nat) : Prop :=\n  duplicate_at l j /\\\n  (forall k, k < j -> ~ duplicate_at l k).",
                "postcond": "((result = None) <-> (forall j, ~ duplicate_at lst j)) /\\\n  (forall x, result = Some x -> exists j, nth_error lst j = Some x /\\ first_duplicate_index lst j) /\\\n  (forall x j, first_duplicate_index lst j -> nth_error lst j = Some x -> result = Some x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_12": {
          "data_id": "verina_basic_12",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to compute the square of a natural number *)\nDefinition square (n : nat) : nat := Nat.mul n n.\n\n(* Multiply a natural number by 6 without relying on numeric literals or extra imports *)\nDefinition times6 (n : nat) : nat :=\n  Nat.add n (Nat.add n (Nat.add n (Nat.add n (Nat.add n n)))).",
                "code": "(* Surface area of a cube: 6 * size^2 *)\n  times6 (square size)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* Surface area of a cube with edge length `size` is 6 * size^2 *)\n  result = 6 * (size * size)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_13": {
          "data_id": "verina_advanced_13",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: order the endpoints of a chord so that a <= b *)\nDefinition order_pair (a b : nat) : nat * nat :=\n  if Nat.leb a b then (a, b) else (b, a).\n\n(* Check if two chords (a,b) and (c,d) intersect after normalizing endpoints.\n   Two chords intersect iff their endpoints interleave:\n   a < c < b < d  or  c < a < d < b *)\nDefinition chords_intersect_ab (a b c d : nat) : bool :=\n  let '(a1, b1) := order_pair a b in\n  let '(c1, d1) := order_pair c d in\n  let case1 :=\n    andb (Nat.ltb a1 c1)\n      (andb (Nat.ltb c1 b1) (Nat.ltb b1 d1)) in\n  let case2 :=\n    andb (Nat.ltb c1 a1)\n      (andb (Nat.ltb a1 d1) (Nat.ltb d1 b1)) in\n  orb case1 case2.\n\n(* Extract a chord from a list representation [a; b]; otherwise return false *)\nDefinition chords_intersect_lists (l1 l2 : list nat) : bool :=\n  match l1, l2 with\n  | a :: b :: [], c :: d :: [] => chords_intersect_ab a b c d\n  | _, _ => false\n  end.\n\n(* Check if the head chord intersects with any chord in the tail *)\nFixpoint any_intersection_with (h : list nat) (t : list (list nat)) : bool :=\n  match t with\n  | [] => false\n  | x :: xs =>\n      if chords_intersect_lists h x\n      then true\n      else any_intersection_with h xs\n  end.\n\n(* Check the list pairwise for any intersecting chords *)\nFixpoint any_intersection (l : list (list nat)) : bool :=\n  match l with\n  | [] => false\n  | [ _ ] => false\n  | h :: t =>\n      if any_intersection_with h t\n      then true\n      else any_intersection t\n  end.",
                "code": "any_intersection chords",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "length chords = N /\\\n  Forall (fun c => length c = 2) chords /\\\n  NoDup (concat chords) /\\\n  Forall (fun c => forall x, In x c -> 1 <= x /\\ x <= 2 * N) chords",
                "postcond_aux": "",
                "postcond": "(result = true) <->\n  (exists i j a b c d,\n      i < length chords /\\\n      j < length chords /\\\n      i <> j /\\\n      (* pick an orientation a<b for chord i by possibly swapping its two endpoints *)\n      (((a = nth 0 (nth i chords []) 0) /\\ (b = nth 1 (nth i chords []) 0)) \\/\n       ((a = nth 1 (nth i chords []) 0) /\\ (b = nth 0 (nth i chords []) 0))) /\\\n      (* pick an orientation c<d for chord j by possibly swapping its two endpoints *)\n      (((c = nth 0 (nth j chords []) 0) /\\ (d = nth 1 (nth j chords []) 0)) \\/\n       ((c = nth 1 (nth j chords []) 0) /\\ (d = nth 0 (nth j chords []) 0))) /\\\n      a < b /\\ c < d /\\\n      (* chords (a,b) and (c,d) intersect iff exactly one of c or d lies strictly between a and b *)\n      ( (a < c /\\ c < b /\\ ~ (a < d /\\ d < b))\n        \\/\n        (a < d /\\ d < b /\\ ~ (a < c /\\ c < b))\n      )\n  )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_13": {
          "data_id": "verina_basic_13",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to compute the cube of an integer *)\nDefinition cubeZ (z : Z) : Z := z * z * z.\n\n(* Recursively map cubeZ over the input list *)\nFixpoint cube_list (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | x :: xs => cubeZ x :: cube_list xs\n  end.",
                "code": "cube_list a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "length result = length a /\\\n  forall (i : nat),\n    i < length a ->\n    List.nth result i 0 =\n      let x := List.nth a i 0 in x * x * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_14": {
          "data_id": "verina_basic_14",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean equality for ascii using the provided decidable equality *)\nDefinition ascii_eqb (a b : ascii) : bool :=\n  if Ascii.ascii_dec a b then true else false.\n\n(* Check whether a character is 'z' (122) or 'Z' (90) *)\nDefinition isZ_ascii (c : ascii) : bool :=\n  orb (ascii_eqb c (Ascii.ascii_of_nat 122))\n      (ascii_eqb c (Ascii.ascii_of_nat 90)).\n\n(* Recursive scan over the string to find 'z' or 'Z' *)\nFixpoint containsZ_aux (s : string) : bool :=\n  match s with\n  | EmptyString => false\n  | String c rest =>\n      if isZ_ascii c then true else containsZ_aux rest\n  end.",
                "code": "containsZ_aux s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true <->\n    (exists l r : string,\n        s = String.append l (String.append \"z\"%string r)\n     \\/ s = String.append l (String.append \"Z\"%string r))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_14": {
          "data_id": "verina_advanced_14",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Double a natural number *)\nFixpoint times2 (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S n' => S (S (times2 n'))\n  end.\n\n(* Quadruple a natural number as 2 * (2 * n) *)\nDefinition times4 (n : nat) : nat := times2 (times2 n).\n\n(* Boolean equality for natural numbers *)\nFixpoint eqb_nat (a b : nat) : bool :=\n  match a, b with\n  | 0, 0 => true\n  | S a', S b' => eqb_nat a' b'\n  | _, _ => false\n  end.\n\n(* Iterate multiplying by 4 starting from 1, up to a given fuel,\n   returning true if we hit exactly n at some step. *)\nFixpoint is_pow4_iter (n fuel acc : nat) : bool :=\n  match fuel with\n  | 0 => eqb_nat acc n\n  | S fuel' =>\n      if eqb_nat acc n then true\n      else is_pow4_iter n fuel' (times4 acc)\n  end.",
                "code": "(* Start from 1 (= 4^0) and repeatedly multiply by 4, up to n steps *)\n  is_pow4_iter n n 1",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Auxiliary: natural-number exponentiation without extra imports *)\nFixpoint nat_pow (a n : nat) : nat :=\n  match n with\n  | 0 => 1\n  | S k => a * nat_pow a k\n  end.\n\nDefinition is_power_of_four (n : nat) : Prop :=\n  exists x : nat, n = nat_pow 4 x.",
                "postcond": "((result = true) <-> is_power_of_four n) /\\\n  ((result = false) <-> ~ is_power_of_four n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_15": {
          "data_id": "verina_advanced_15",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_15",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function that scans the list while tracking the smallest (first)\n   and the second smallest (second) values seen so far that form an increasing pair.\n   If we find an element greater than 'second', we have an increasing triplet. *)\nFixpoint find_increasing_triplet (l : list Z) (first second : option Z) : bool :=\n  match l with\n  | nil => false\n  | x :: xs =>\n      match first with\n      | None =>\n          (* Initialize 'first' with the first seen element *)\n          find_increasing_triplet xs (Some x) None\n      | Some f =>\n          if Z.leb x f then\n            (* x <= first: improve 'first' *)\n            find_increasing_triplet xs (Some x) second\n          else\n            (* x > first: try to improve 'second' or detect triplet *)\n            match second with\n            | None =>\n                (* Set 'second' as x, since x > first *)\n                find_increasing_triplet xs (Some f) (Some x)\n            | Some s =>\n                if Z.leb x s then\n                  (* first < x <= second: improve 'second' *)\n                  find_increasing_triplet xs (Some f) (Some x)\n                else\n                  (* first < second < x: triplet found *)\n                  true\n            end\n      end\n  end.",
                "code": "find_increasing_triplet nums None None",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_15",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true <->\n  exists (i j k : nat) (xi xj xk : Z),\n    (i < j)%nat /\\\n    (j < k)%nat /\\\n    nth_error nums i = Some xi /\\\n    nth_error nums j = Some xj /\\\n    nth_error nums k = Some xk /\\\n    xi < xj /\\\n    xj < xk",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_16": {
          "data_id": "verina_basic_16",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean equality for ascii characters using the provided decidable equality *)\nDefinition ascii_eqb (a b : ascii) : bool :=\n  if ascii_dec a b then true else false.\n\n(* Replace all occurrences of [old] with [new] in a string [s] *)\nFixpoint replace_chars (s : string) (old new : ascii) : string :=\n  match s with\n  | String.EmptyString => String.EmptyString\n  | String.String c rest =>\n      let c' := if ascii_eqb c old then new else c in\n      String.String c' (replace_chars rest old new)\n  end.",
                "code": "replace_chars s oldChar newChar",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Fixpoint charwise_replaced (s r : string) (oldChar newChar : ascii) : Prop :=\n  match s, r with\n  | EmptyString, EmptyString => True\n  | String c s', String d r' =>\n      ((c = oldChar -> d = newChar) /\\ (c <> oldChar -> d = c))\n      /\\ charwise_replaced s' r' oldChar newChar\n  | _, _ => False\n  end.",
                "postcond": "String.length s = String.length result\n  /\\ charwise_replaced s result oldChar newChar",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_16": {
          "data_id": "verina_advanced_16",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Insert an element into a sorted list (ascending order) at the correct position *)\nFixpoint insert_into_sorted (x : Z) (l : list Z) : list Z :=\n  match l with\n  | nil => x :: nil\n  | y :: ys =>\n      (* Place x before y if x <= y; otherwise continue inserting into the tail *)\n      if Z.leb x y then x :: y :: ys\n      else y :: insert_into_sorted x ys\n  end.\n\n(* Standard insertion sort: recursively sort the tail and insert the head *)\nFixpoint insertion_sort_aux (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | x :: xs => insert_into_sorted x (insertion_sort_aux xs)\n  end.",
                "code": "(* Run insertion sort on the input list *)\n  insertion_sort_aux xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Count occurrences of a given integer in a list *)\nFixpoint countZ (x : Z) (l : list Z) : nat :=\n  match l with\n  | [] => 0%nat\n  | y :: ys => if Z.eq_dec x y then S (countZ x ys) else countZ x ys\n  end.\n\n(* Multiset/permutation equality via occurrence counts *)\nDefinition PermZ (l1 l2 : list Z) : Prop :=\n  forall x : Z, countZ x l1 = countZ x l2.\n\n(* Ascending sortedness (non-decreasing) by adjacent comparison *)\nFixpoint SortedZ (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | _ :: [] => True\n  | x :: y :: xs => x <= y /\\ SortedZ (y :: xs)\n  end.",
                "postcond": "SortedZ result /\\ PermZ xs result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_17": {
          "data_id": "verina_advanced_17",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Insert an element into a sorted list (non-decreasing order) *)\nFixpoint insertZ (x : Z) (l : list Z) : list Z :=\n  match l with\n  | [] => [x]\n  | y :: ys => if Z.leb x y then x :: l else y :: insertZ x ys\n  end.\n\n(* Standard insertion sort using insertZ *)\nFixpoint insertionSort_aux (l : list Z) : list Z :=\n  match l with\n  | [] => []\n  | x :: xs => insertZ x (insertionSort_aux xs)\n  end.",
                "code": "(* Sort the list using insertion sort *)\n  insertionSort_aux l",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Adjacent-based non-decreasing sortedness on Z *)\nFixpoint sorted (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | x :: xs =>\n    match xs with\n    | [] => True\n    | y :: ys => x <= y /\\ sorted xs\n    end\n  end.\n\n(* Multiset equality via element occurrence counting *)\nFixpoint count (x : Z) (l : list Z) : nat :=\n  match l with\n  | [] => 0%nat\n  | y :: ys => if Z.eqb x y then S (count x ys) else count x ys\n  end.\n\nDefinition same_multiset (l1 l2 : list Z) : Prop :=\n  forall z : Z, count z l1 = count z l2.",
                "postcond": "sorted result /\\ same_multiset result l",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_17": {
          "data_id": "verina_basic_17",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: map a function over all characters of a string *)\nFixpoint map_string (f : ascii -> ascii) (s : string) : string :=\n  match s with\n  | EmptyString => EmptyString\n  | String c s' => String (f c) (map_string f s')\n  end.\n\n(* Check if a nat code corresponds to an uppercase ASCII letter 'A'(65) .. 'Z'(90) *)\nDefinition is_upper_ascii (n : nat) : bool :=\n  andb (Nat.leb 65 n) (Nat.leb n 90).\n\n(* Convert a single ASCII character to lowercase if it is uppercase *)\nDefinition toLowerAscii (c : ascii) : ascii :=\n  let n := nat_of_ascii c in\n  if is_upper_ascii n then ascii_of_nat (n + 32) else c.",
                "code": "map_string toLowerAscii s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Character-level predicate: c' is c converted to lowercase if c is uppercase; otherwise c' = c. *)\nDefinition is_upper (c : Ascii.ascii) : Prop :=\n  let n := Ascii.nat_of_ascii c in 65 <= n /\\ n <= 90.\n\nDefinition lower_of (c c' : Ascii.ascii) : Prop :=\n  (is_upper c /\\ Ascii.nat_of_ascii c' = Ascii.nat_of_ascii c + 32) \\/\n  (~ is_upper c /\\ c' = c).\n\n(* String-level relation: result is obtained by applying lower_of to each character of s. *)\nInductive map_lower : string -> string -> Prop :=\n| map_lower_nil :\n    map_lower String.EmptyString String.EmptyString\n| map_lower_cons :\n    forall (c c' : Ascii.ascii) (s r : string),\n      lower_of c c' ->\n      map_lower s r ->\n      map_lower (String.String c s) (String.String c' r).",
                "postcond": "map_lower s result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_18": {
          "data_id": "verina_advanced_18",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Equality on natural numbers *)\nFixpoint nat_beq (x y : nat) : bool :=\n  match x, y with\n  | 0, 0 => true\n  | S x', S y' => nat_beq x' y'\n  | _, _ => false\n  end.\n\n(* Increment a list of base-10 digits (least-significant-first) *)\nFixpoint digits_inc (ds : list nat) : list nat :=\n  match ds with\n  | nil => 1 :: nil\n  | d :: ds' =>\n      if nat_beq d 9 then 0 :: digits_inc ds'\n      else (S d) :: ds'\n  end.\n\n(* Convert a nat to its base-10 digits (least-significant-first).\n   0 is represented as [0]. *)\nFixpoint digits_of (n : nat) : list nat :=\n  match n with\n  | 0 => 0 :: nil\n  | S n' => digits_inc (digits_of n')\n  end.\n\n(* Length of a list *)\nFixpoint len (l : list nat) : nat :=\n  match l with\n  | nil => 0\n  | _ :: t => S (len t)\n  end.\n\n(* Power on natural numbers: a^b *)\nFixpoint pow_nat (a b : nat) : nat :=\n  match b with\n  | 0 => 1\n  | S b' => a * pow_nat a b'\n  end.\n\n(* Sum of k-th powers of digits in the list *)\nFixpoint sum_pow_list (l : list nat) (k : nat) : nat :=\n  match l with\n  | nil => 0\n  | d :: t => pow_nat d k + sum_pow_list t k\n  end.",
                "code": "let ds := digits_of n in\n  nat_beq (sum_pow_list ds (len ds)) n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Auxiliary definitions to express the Armstrong-number property on nat without extra imports *)\n\n(* Natural-number exponentiation *)\nFixpoint nat_pow (a b : nat) : nat :=\n  match b with\n  | O => 1\n  | S b' => a * nat_pow a b'\n  end.\n\n(* Length of a list of nat *)\nFixpoint list_length (l : list nat) : nat :=\n  match l with\n  | nil => 0\n  | _ :: t => S (list_length t)\n  end.\n\n(* Sum of each digit raised to k over a list of digits *)\nFixpoint sum_pow_digits_list (l : list nat) (k : nat) : nat :=\n  match l with\n  | nil => 0\n  | d :: t => nat_pow d k + sum_pow_digits_list t k\n  end.\n\n(* Relational specification of the base-10 digits of a number.\n   The list stores digits in least-significant-first order, but order\n   is irrelevant for the Armstrong sum. *)\nInductive digits_of : nat -> list nat -> Prop :=\n| digits_of_lt10 : forall n, n < 10 -> digits_of n (n :: nil)\n| digits_of_step :\n    forall n q r ds,\n      n = q * 10 + r ->\n      r < 10 ->\n      digits_of q ds ->\n      digits_of n (r :: ds).",
                "postcond": "(* result is true exactly when n equals the sum of its digits each\n     raised to the power of the number of digits (Armstrong property). *)\n  result = true <->\n  exists (ds : list nat),\n    digits_of n ds /\\\n    sum_pow_digits_list ds (list_length ds) = n",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_18": {
          "data_id": "verina_basic_18",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Increment a list of base-10 digits (stored least-significant first) by 1 *)\nFixpoint inc_digits (ds : list nat) : list nat :=\n  match ds with\n  | nil => S O :: nil\n  | d :: ds' =>\n      match d with\n      | O => S O :: ds'\n      | S O => S (S O) :: ds'\n      | S (S O) => S (S (S O)) :: ds'\n      | S (S (S O)) => S (S (S (S O))) :: ds'\n      | S (S (S (S O))) => S (S (S (S (S O)))) :: ds'\n      | S (S (S (S (S O)))) => S (S (S (S (S (S O))))) :: ds'\n      | S (S (S (S (S (S O))))) => S (S (S (S (S (S (S O))))) ) :: ds'\n      | S (S (S (S (S (S (S O)))))) => S (S (S (S (S (S (S (S O))))))) :: ds'\n      | S (S (S (S (S (S (S (S O))))))) => S (S (S (S (S (S (S (S (S O)))))))) :: ds'\n      | _ => O :: inc_digits ds'\n      end\n  end.\n\n(* Produce the list of base-10 digits (least-significant first) of n *)\nFixpoint digits_of (n : nat) : list nat :=\n  match n with\n  | O => O :: nil\n  | S n' => inc_digits (digits_of n')\n  end.\n\n(* Sum a list of natural numbers *)\nFixpoint sum_list (l : list nat) : nat :=\n  match l with\n  | nil => O\n  | x :: xs => x + sum_list xs\n  end.",
                "code": "sum_list (digits_of n)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "exists (k : nat) (q r s : nat -> nat),\n    q 0 = n /\\\n    (forall i, i < k -> r i = (q i) mod 10 /\\ q (S i) = (q i) / 10) /\\\n    q k = 0 /\\\n    s 0 = 0 /\\\n    (forall i, i < k -> s (S i) = s i + r i) /\\\n    result = s k",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_19": {
          "data_id": "verina_basic_19",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper recursive function to check non-decreasing order of a list of Z *)\nFixpoint is_sorted_aux (l : list Z) : bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x :: y :: t => andb (Z.leb x y) (is_sorted_aux (y :: t))\n  end.",
                "code": "is_sorted_aux a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true <-> forall (i j : nat), (i < j)%nat -> (j < length a)%nat -> nth i a 0%Z <= nth j a 0%Z)\n  /\\\n  (result = false -> exists i : nat, (i + 1 < length a)%nat /\\ nth i a 0%Z > nth (i + 1) a 0%Z)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_19": {
          "data_id": "verina_advanced_19",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: check if a nat n is within [lo, hi] *)\nDefinition is_between (n lo hi : nat) : bool :=\n  andb (Nat.leb lo n) (Nat.leb n hi).\n\n(* Helper: check if an ascii is alphabetic (A-Z or a-z) *)\nDefinition is_alpha_ascii (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n  orb (is_between n 65 90) (is_between n 97 122).\n\n(* Helper: convert an ascii to lowercase if it is uppercase *)\nDefinition toLowerAscii (c : ascii) : ascii :=\n  let n := nat_of_ascii c in\n  if is_between n 65 90\n  then ascii_of_nat (n + 32)\n  else c.\n\n(* Clean the string: keep only letters and lowercase them *)\nFixpoint clean (s : string) : string :=\n  match s with\n  | EmptyString => EmptyString\n  | String c rest =>\n      if is_alpha_ascii c\n      then String (toLowerAscii c) (clean rest)\n      else clean rest\n  end.\n\n(* Reverse a string using an accumulator *)\nFixpoint rev_append (s acc : string) : string :=\n  match s with\n  | EmptyString => acc\n  | String c rest => rev_append rest (String c acc)\n  end.\n\nDefinition rev_string (s : string) : string :=\n  rev_append s EmptyString.\n\n(* Boolean equality on strings using ascii_dec *)\nFixpoint eqb_string (s1 s2 : string) : bool :=\n  match s1, s2 with\n  | EmptyString, EmptyString => true\n  | String c1 r1, String c2 r2 =>\n      match ascii_dec c1 c2 with\n      | left _ => eqb_string r1 r2\n      | right _ => false\n      end\n  | _, _ => false\n  end.",
                "code": "let cs := clean s in\n  eqb_string cs (rev_string cs)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Auxiliary functions to normalize and filter the string *)\n\n(* Check if an ASCII code [n] lies within [lo..hi] *)\nDefinition in_range (n lo hi : nat) : bool :=\n  andb (Nat.leb lo n) (Nat.leb n hi).\n\n(* Predicate: is the character an ASCII alphabetic letter (A-Z or a-z)? *)\nDefinition is_letter (c : Ascii.ascii) : bool :=\n  let n := Ascii.nat_of_ascii c in\n  orb (in_range n 65 90)  (* 'A'..'Z' *)\n      (in_range n 97 122) (* 'a'..'z' *).\n\n(* Convert an ASCII character to lowercase (only affects 'A'..'Z') *)\nDefinition to_lower (c : Ascii.ascii) : Ascii.ascii :=\n  let n := Ascii.nat_of_ascii c in\n  if in_range n 65 90 (* 'A'..'Z' *)\n  then Ascii.ascii_of_nat (n + 32) (* 'a'..'z' *)\n  else c.\n\n(* Reverse a string using an accumulator *)\nFixpoint rev_append (s acc : string) : string :=\n  match s with\n  | EmptyString => acc\n  | String c s' => rev_append s' (String c acc)\n  end.\n\nDefinition rev_string (s : string) : string :=\n  rev_append s EmptyString.\n\n(* Remove non-letters and lowercase the remaining letters *)\nFixpoint clean (s : string) : string :=\n  match s with\n  | EmptyString => EmptyString\n  | String c s' =>\n      if is_letter c\n      then String (to_lower c) (clean s')\n      else clean s'\n  end.\n\n(* Cleaned palindrome property: the cleaned string equals its reverse *)\nDefinition is_clean_pal (s : string) : Prop :=\n  clean s = rev_string (clean s).",
                "postcond": "(result = true <-> is_clean_pal s)\n  /\\ (result = false <-> ~ is_clean_pal s)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_20": {
          "data_id": "verina_basic_20",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean membership check in a list of Z using Z.eqb *)\nFixpoint memZ (x : Z) (l : list Z) : bool :=\n  match l with\n  | [] => false\n  | y :: ys => if Z.eqb x y then true else memZ x ys\n  end.\n\n(* Traverse the list once, accumulating a set of seen elements and the product\n   of distinct elements encountered so far. *)\nFixpoint uniqueProduct_aux (l : list Z) (seen : list Z) (acc : Z) : Z :=\n  match l with\n  | [] => acc\n  | x :: xs =>\n      if memZ x seen\n      then uniqueProduct_aux xs seen acc\n      else uniqueProduct_aux xs (x :: seen) (acc * x)\n  end.",
                "code": "(* Start with empty 'seen' set and neutral product 1 *)\n  uniqueProduct_aux arr [] 1",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "exists l : list Z,\n    NoDup l /\\\n    (forall x : Z, List.In x l <-> List.In x arr) /\\\n    result = List.fold_right Z.mul 1 l",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_20": {
          "data_id": "verina_advanced_20",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to check whether a Z has digit 8 in its base-10 representation.\n   We iterate at most k steps, peeling off one digit per step. *)\nFixpoint has_digit8_loop (k : nat) (x : Z) : bool :=\n  match k with\n  | O => false\n  | S k' =>\n      if Z.eqb x 0 then false\n      else\n        let ax := Z.abs x in\n        let d := Z.rem ax 10 in\n        if Z.eqb d 8 then true\n        else has_digit8_loop k' (Z.div ax 10)\n  end.\n\nDefinition has_digit8 (x : Z) : bool :=\n  has_digit8_loop (S (Z.to_nat (Z.abs x))) x.",
                "code": "let divisible := Z.eqb (Z.rem n 8) 0 in\n  let has8 := has_digit8 n in\n  orb divisible has8",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Predicate: n has digit 8 in its (absolute) base-10 representation *)\nDefinition has_digit8 (n : Z) : Prop :=\n  exists k : Z, 0 <= k /\\ Z.modulo (Z.div (Z.abs n) (Z.pow 10 k)) 10 = 8.",
                "postcond": "let P := (Z.modulo n 8 = 0 \\/ has_digit8 n) in\n  (result = true <-> P) /\\ (result = false <-> ~ P)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_21": {
          "data_id": "verina_advanced_21",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: string append *)\nFixpoint str_app (s1 s2 : string) : string :=\n  match s1 with\n  | EmptyString => s2\n  | String c s1' => String c (str_app s1' s2)\n  end.\n\n(* Helper: reverse a string *)\nFixpoint str_rev (s : string) : string :=\n  match s with\n  | EmptyString => EmptyString\n  | String c s' => str_app (str_rev s') (String c EmptyString)\n  end.\n\n(* Helper: boolean equality on strings using string_dec *)\nDefinition str_eqb (s1 s2 : string) : bool :=\n  if string_dec s1 s2 then true else false.",
                "code": "(* A string is a palindrome if it equals its reverse *)\n  str_eqb s (str_rev s)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Reverse a string using an accumulator to avoid needing concatenation *)\nFixpoint rev_acc (s acc : string) : string :=\n  match s with\n  | EmptyString => acc\n  | String c s' => rev_acc s' (String c acc)\n  end.\n\nDefinition str_rev (s : string) : string := rev_acc s EmptyString.",
                "postcond": "(* result is true iff s equals its reverse; false otherwise *)\n  (result = true <-> s = str_rev s) /\\ (result = false <-> s <> str_rev s)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_21": {
          "data_id": "verina_basic_21",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Check whether the first list is a prefix of the second *)\nFixpoint prefixb (sub main : list Z) : bool :=\n  match sub, main with\n  | nil, _ => true\n  | _, nil => false\n  | x :: xs, y :: ys =>\n      if Z.eqb x y then prefixb xs ys else false\n  end.\n\n(* Search for sub as a contiguous sublist within main *)\nFixpoint isSublist_aux (sub main : list Z) : bool :=\n  match sub with\n  | nil => true (* the empty list is a sublist of any list *)\n  | _ =>\n      match main with\n      | nil => false\n      | _ :: ys =>\n          if prefixb sub main then true else isSublist_aux sub ys\n      end\n  end.",
                "code": "isSublist_aux sub main",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "((result = true) <-> (exists l1 l2, main = l1 ++ sub ++ l2))\n  /\\\n  ((result = false) <-> ~(exists l1 l2, main = l1 ++ sub ++ l2))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_22": {
          "data_id": "verina_basic_22",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Check membership in a list of Z using Z.eqb *)\nFixpoint memZ (x : Z) (l : list Z) : bool :=\n  match l with\n  | nil => false\n  | y :: ys => if Z.eqb x y then true else memZ x ys\n  end.\n\n(* Remove duplicate elements from a list, keeping one occurrence *)\nFixpoint remove_dups (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | x :: xs =>\n      let xs' := remove_dups xs in\n      if memZ x xs' then xs' else x :: xs'\n  end.\n\n(* List difference: elements of l1 that are not in l2 *)\nFixpoint diff (l1 l2 : list Z) : list Z :=\n  match l1 with\n  | nil => nil\n  | x :: xs =>\n      if memZ x l2 then diff xs l2 else x :: diff xs l2\n  end.\n\n(* Insert an element into a sorted list (non-decreasing order) *)\nFixpoint insert_sorted (x : Z) (l : list Z) : list Z :=\n  match l with\n  | nil => x :: nil\n  | y :: ys => if Z.leb x y then x :: l else y :: insert_sorted x ys\n  end.\n\n(* Insertion sort for lists of Z (non-decreasing order) *)\nFixpoint sortZ (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | x :: xs => insert_sorted x (sortZ xs)\n  end.",
                "code": "(* Deduplicate both input lists *)\n  let da := remove_dups a in\n  let db := remove_dups b in\n  (* Symmetric difference: elements in a not in b, plus elements in b not in a *)\n  let sym := diff da db ++ diff db da in\n  (* Return the sorted result *)\n  sortZ sym",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Fixpoint sorted_nondec (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: t => x <= y /\\ sorted_nondec (y :: t)\n  end.",
                "postcond": "NoDup result /\\\n  sorted_nondec result /\\\n  (forall z : Z,\n      In z result <->\n      (In z a /\\ ~ In z b) \\/ (In z b /\\ ~ In z a))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_22": {
          "data_id": "verina_advanced_22",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Phase of traversal: increasing first, then decreasing *)\nInductive phase := IncPhase | DecPhase.\n\n(* Recursive checker that enforces:\n   - Start in IncPhase\n   - Strictly increasing while in IncPhase\n   - A single switch to DecPhase (on first decrease)\n   - Strictly decreasing while in DecPhase\n   - Both phases must contribute at least one step (incSeen and decSeen) *)\nFixpoint check_peak_valley (ph : phase) (incSeen decSeen : bool) (prev : Z) (l : list Z) : bool :=\n  match l with\n  | nil => andb incSeen decSeen\n  | y :: ys =>\n      match ph with\n      | IncPhase =>\n          if Z.eqb y prev then false\n          else if prev <? y\n               then check_peak_valley IncPhase true decSeen y ys\n               else (* y < prev, switch to decreasing *)\n                    check_peak_valley DecPhase incSeen true y ys\n      | DecPhase =>\n          if Z.eqb y prev then false\n          else if y <? prev\n               then check_peak_valley DecPhase incSeen true y ys\n               else false\n      end\n  end.",
                "code": "match lst with\n  | nil => false\n  | x :: xs => check_peak_valley IncPhase false false x xs\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* A list follows a peak-valley pattern iff there exists a split index k\n     such that:\n       - the prefix up to k is strictly increasing (at least one step),\n       - the suffix from k is strictly decreasing (at least one step). *)\n  let peak_valley :=\n    (exists k : nat,\n        0 < k /\\\n        k < (List.length lst - 1) /\\\n        (forall i : nat, i < k ->\n            List.nth i lst 0 < List.nth (S i) lst 0) /\\\n        (forall i : nat, k <= i /\\ i < (List.length lst - 1) ->\n            List.nth i lst 0 > List.nth (S i) lst 0))\n  in\n  (result = true <-> peak_valley) /\\\n  (result = false <-> ~ peak_valley)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_23": {
          "data_id": "verina_advanced_23",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* A positive integer n is a power of two iff (n land (n - 1)) = 0. \n     We also exclude non-positive n (n <= 0) explicitly. *)\n  match Z.leb n 0 with\n  | true => false\n  | false => Z.eqb (Z.land n (n - 1)) 0\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "let P := (exists x : Z, 0 <= x /\\ n = Z.pow 2 x) in\n  (result = true <-> P) /\\ (result = false <-> ~ P)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_23": {
          "data_id": "verina_basic_23",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to compute running minimum and maximum over a list *)\nFixpoint min_max_acc (l : list Z) (mn mx : Z) : Z * Z :=\n  match l with\n  | nil => (mn, mx)\n  | y :: ys =>\n      let mn' := Z.min mn y in\n      let mx' := Z.max mx y in\n      min_max_acc ys mn' mx'\n  end.",
                "code": "(* Since the list is non-empty by precondition, we can safely take its head as initial min and max *)\n  match a with\n  | nil => 0 (* unreachable if precondition holds; provided for totality *)\n  | x :: xs =>\n      let p := min_max_acc xs x x in\n      match p with\n      | (mn, mx) => mx - mn\n      end\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "a <> nil",
                "postcond_aux": "",
                "postcond": "exists mn mx,\n    List.In mn a /\\\n    List.In mx a /\\\n    (forall y, List.In y a -> mn <= y) /\\\n    (forall y, List.In y a -> y <= mx) /\\\n    result = mx - mn",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_24": {
          "data_id": "verina_advanced_24",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: maximum of a list of Z, default 0 for empty list *)\nFixpoint lis_max_list (l : list Z) : Z :=\n  match l with\n  | nil => 0%Z\n  | x :: xs => Z.max x (lis_max_list xs)\n  end.\n\n(* Helper: among pairs (v, d) from vals_rev and dp_rev, compute the maximum d such that v < x *)\nFixpoint lis_max_if_lt (vals_rev : list Z) (dp_rev : list Z) (x : Z) : Z :=\n  match vals_rev, dp_rev with\n  | v :: vs, d :: ds =>\n      let recm := lis_max_if_lt vs ds x in\n      if Z.ltb v x then Z.max d recm else recm\n  | _, _ => 0%Z\n  end.\n\n(* Build DP values in reverse order:\n   - vals_rev: values seen so far, in reverse\n   - dp_rev: LIS lengths ending at corresponding values, in reverse *)\nFixpoint lis_compute_dp (nums : list Z) (vals_rev : list Z) (dp_rev : list Z) : list Z :=\n  match nums with\n  | nil => dp_rev\n  | x :: xs =>\n      let m := lis_max_if_lt vals_rev dp_rev x in\n      let best := (1%Z + m)%Z in\n      lis_compute_dp xs (x :: vals_rev) (best :: dp_rev)\n  end.",
                "code": "(* Compute DP lengths for LIS ending at each position (order reversed), then take their maximum *)\n  let dp_rev := lis_compute_dp nums [] [] in\n  lis_max_list dp_rev",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Strictly increasing sequence: each consecutive pair is strictly increasing *)\nFixpoint strictly_increasing (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: tl => x < y /\\ strictly_increasing (y :: tl)\n  end.\n\n(* Standard subsequence relation: obtained by deleting elements without reordering *)\nInductive subseq : list Z -> list Z -> Prop :=\n| subseq_nil : forall l, subseq [] l\n| subseq_cons_drop : forall x xs ys, subseq xs ys -> subseq xs (x :: ys)\n| subseq_cons_keep : forall x xs ys, subseq xs ys -> subseq (x :: xs) (x :: ys).",
                "postcond": "exists l : list Z,\n    subseq l nums /\\\n    strictly_increasing l /\\\n    result = Z.of_nat (List.length l) /\\\n    forall l', subseq l' nums -> strictly_increasing l' -> Z.of_nat (List.length l') <= result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_24": {
          "data_id": "verina_basic_24",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: traverse the list once, tracking the first even and first odd seen so far.\n   As soon as both are found, return their difference (even - odd). *)\nFixpoint diff_first_even_odd (l : list Z) (fe fo : option Z) : option Z :=\n  match fe, fo with\n  | Some e, Some o => Some (e - o)\n  | _, _ =>\n    match l with\n    | nil =>\n      (* At the end, if both were found, return the difference; otherwise None (unreachable under precond). *)\n      match fe, fo with\n      | Some e, Some o => Some (e - o)\n      | _, _ => None\n      end\n    | cons x xs =>\n      let fe' :=\n        match fe with\n        | Some e => Some e\n        | None => if Z.even x then Some x else None\n        end in\n      let fo' :=\n        match fo with\n        | Some o => Some o\n        | None => if Z.odd x then Some x else None\n        end in\n      diff_first_even_odd xs fe' fo'\n    end\n  end.",
                "code": "match diff_first_even_odd a None None with\n  | Some d => d\n  | None => 0 (* Unreachable due to precondition guaranteeing one even and one odd exist. *)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* The list contains at least one even and at least one odd element *)\n  List.Exists (fun z => Z.even z = true) a /\\\n  List.Exists (fun z => Z.odd z = true) a",
                "postcond_aux": "",
                "postcond": "(* result equals (first even) - (first odd) *)\n  exists (pre_even suf_even : list Z) (e : Z)\n         (pre_odd suf_odd : list Z) (o : Z),\n    a = pre_even ++ e :: suf_even /\\\n    a = pre_odd ++ o :: suf_odd /\\\n    Z.even e = true /\\\n    Z.odd o = true /\\\n    (* e is the first even: no earlier element is even *)\n    List.Forall (fun z => Z.even z = false) pre_even /\\\n    (* o is the first odd: no earlier element is odd *)\n    List.Forall (fun z => Z.odd z = false) pre_odd /\\\n    result = e - o",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_25": {
          "data_id": "verina_basic_25",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Convert n to Z for integer arithmetic *)\n  let zn := Z.of_nat n in\n  (* Sum of first n natural numbers: n * (n + 1) / 2 *)\n  let sumZ := (zn * (zn + 1)) / 2 in\n  (* Average: sum divided by n, as a real number *)\n  let avgR := Rdiv (IZR sumZ) (IZR zn) in\n  (sumZ, avgR)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "Require Import Reals.",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "0 < n /\\ Z.of_nat n < Z.pow 2 53",
                "postcond_aux": "",
                "postcond": "fst result = (Z.of_nat n * (Z.of_nat n + 1)) / 2 /\\\n  snd result = Rdiv (IZR ((Z.of_nat n * (Z.of_nat n + 1)) / 2)) (INR n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_25": {
          "data_id": "verina_advanced_25",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Find the first index where the element is >= x *)\nFixpoint first_ge_index (x : Z) (l : list Z) (idx : nat) {struct l} : option nat :=\n  match l with\n  | nil => None\n  | y :: ys => if Z.leb x y then Some idx else first_ge_index x ys (S idx)\n  end.\n\nDefinition find_pos_ge (x : Z) (l : list Z) : option nat :=\n  first_ge_index x l 0.\n\n(* Replace the element at index i with x (assumes i < length l) *)\nFixpoint replace_nth (l : list Z) (i : nat) (x : Z) {struct l} : list Z :=\n  match l with\n  | nil => nil\n  | y :: ys =>\n      match i with\n      | O => x :: ys\n      | S i' => y :: replace_nth ys i' x\n      end\n  end.\n\n(* Update the tails list with a new element x according to patience sorting rules *)\nDefinition update_tails (tails : list Z) (x : Z) : list Z :=\n  match find_pos_ge x tails with\n  | Some i => replace_nth tails i x\n  | None => tails ++ [x]\n  end.\n\n(* Process the input list to build the tails list *)\nFixpoint process_lis (l : list Z) (tails : list Z) {struct l} : list Z :=\n  match l with\n  | nil => tails\n  | x :: xs => process_lis xs (update_tails tails x)\n  end.",
                "code": "(* The length of the LIS equals the length of the tails list constructed by process_lis *)\n  length (process_lis nums [])",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Subsequence relation: s is obtained from l by deleting zero or more elements without reordering *)\nInductive subseq : list Z -> list Z -> Prop :=\n| subseq_nil : forall l2, subseq [] l2\n| subseq_skip : forall x l1 l2, subseq l1 l2 -> subseq l1 (x :: l2)\n| subseq_take : forall x l1 l2, subseq l1 l2 -> subseq (x :: l1) (x :: l2).\n\n(* Strictly increasing list of integers *)\nFixpoint strictly_increasing (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: tl => Z.lt x y /\\ strictly_increasing (y :: tl)\n  end.",
                "postcond": "(* Soundness: there exists a strictly increasing subsequence of length = result *)\n  (exists s, subseq s nums /\\ strictly_increasing s /\\ length s = result)\n  /\\\n  (* Completeness: no strictly increasing subsequence is longer than result *)\n  (forall t, subseq t nums -> strictly_increasing t -> length t <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_26": {
          "data_id": "verina_basic_26",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "Z.eqb (Z.modulo n 2) 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* result is true iff n is even; result is false iff n is odd *)\n  (result = true <-> exists k : Z, n = 2 * k)\n  /\\ (result = false <-> exists k : Z, n = 2 * k + 1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_26": {
          "data_id": "verina_advanced_26",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Map a digit character to its corresponding list of letters, if valid *)\nDefinition char_to_letters (c : ascii) : option (list string) :=\n  if Ascii.eqb c \"2\"%char then Some [\"a\"; \"b\"; \"c\"]\n  else if Ascii.eqb c \"3\"%char then Some [\"d\"; \"e\"; \"f\"]\n  else if Ascii.eqb c \"4\"%char then Some [\"g\"; \"h\"; \"i\"]\n  else if Ascii.eqb c \"5\"%char then Some [\"j\"; \"k\"; \"l\"]\n  else if Ascii.eqb c \"6\"%char then Some [\"m\"; \"n\"; \"o\"]\n  else if Ascii.eqb c \"7\"%char then Some [\"p\"; \"q\"; \"r\"; \"s\"]\n  else if Ascii.eqb c \"8\"%char then Some [\"t\"; \"u\"; \"v\"]\n  else if Ascii.eqb c \"9\"%char then Some [\"w\"; \"x\"; \"y\"; \"z\"]\n  else None.\n\n(* Append a fixed prefix to each string in a list *)\nFixpoint append_each (p : string) (ls : list string) : list string :=\n  match ls with\n  | nil => nil\n  | l :: ls' => String.append p l :: append_each p ls'\n  end.\n\n(* Combine all prefixes with all letters *)\nFixpoint combine (acc letters : list string) : list string :=\n  match acc with\n  | nil => nil\n  | p :: ps => append_each p letters ++ combine ps letters\n  end.\n\n(* Process the input string of digits, accumulating combinations *)\nFixpoint process (s : string) (acc : list string) : option (list string) :=\n  match s with\n  | String.EmptyString => Some acc\n  | String.String c s' =>\n      match char_to_letters c with\n      | None => None\n      | Some letters => process s' (combine acc letters)\n      end\n  end.",
                "code": "match digits with\n  | String.EmptyString => []\n  | _ =>\n      match process digits [\"\"%string] with\n      | Some res => res\n      | None => []\n      end\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Mapping from a digit character to its allowed letter characters *)\nDefinition letter_of_digit (d c : ascii) : Prop :=\n  (d = \"2\"%char /\\ (c = \"a\"%char \\/ c = \"b\"%char \\/ c = \"c\"%char)) \\/\n  (d = \"3\"%char /\\ (c = \"d\"%char \\/ c = \"e\"%char \\/ c = \"f\"%char)) \\/\n  (d = \"4\"%char /\\ (c = \"g\"%char \\/ c = \"h\"%char \\/ c = \"i\"%char)) \\/\n  (d = \"5\"%char /\\ (c = \"j\"%char \\/ c = \"k\"%char \\/ c = \"l\"%char)) \\/\n  (d = \"6\"%char /\\ (c = \"m\"%char \\/ c = \"n\"%char \\/ c = \"o\"%char)) \\/\n  (d = \"7\"%char /\\ (c = \"p\"%char \\/ c = \"q\"%char \\/ c = \"r\"%char \\/ c = \"s\"%char)) \\/\n  (d = \"8\"%char /\\ (c = \"t\"%char \\/ c = \"u\"%char \\/ c = \"v\"%char)) \\/\n  (d = \"9\"%char /\\ (c = \"w\"%char \\/ c = \"x\"%char \\/ c = \"y\"%char \\/ c = \"z\"%char)).\n\n(* Relation capturing exactly the valid letter-combination strings for a given digit string *)\nInductive Comb : string -> string -> Prop :=\n| Comb_empty : Comb EmptyString EmptyString\n| Comb_cons :\n    forall d ds c s,\n      letter_of_digit d c ->\n      Comb ds s ->\n      Comb (String d ds) (String c s).",
                "postcond": "(* If the input is empty, the output must be the empty list. *)\n  (digits = EmptyString -> result = []) /\\\n  (* Otherwise, result contains exactly all and only valid combinations. *)\n  (digits <> EmptyString ->\n    forall s : string, List.In s result <-> Comb digits s)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_27": {
          "data_id": "verina_basic_27",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: membership test for ascii in a list of ascii *)\nFixpoint ascii_in_list (c : ascii) (l : list ascii) : bool :=\n  match l with\n  | nil => false\n  | x :: xs =>\n      if ascii_dec c x then true else ascii_in_list c xs\n  end.\n\n(* Traverse the string left-to-right keeping a set (list) of seen characters.\n   Return the first character that appears more than once, if any. *)\nFixpoint findFirstRepeatedCharAux (s : string) (seen : list ascii) : option ascii :=\n  match s with\n  | String.EmptyString => None\n  | String.String ch rest =>\n      if ascii_in_list ch seen\n      then Some ch\n      else findFirstRepeatedCharAux rest (ch :: seen)\n  end.",
                "code": "(* Start with an empty set of seen characters *)\n  findFirstRepeatedCharAux s nil",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Membership of a character in a string *)\nInductive In_string (a : ascii) : string -> Prop :=\n| In_here  : forall s, In_string a (String.String a s)\n| In_there : forall b s, In_string a s -> In_string a (String.String b s).\n\n(* No-duplicate predicate for strings: all characters are pairwise distinct *)\nFixpoint NoDup_string (s : string) : Prop :=\n  match s with\n  | String.EmptyString => True\n  | String.String a s' => ~ In_string a s' /\\ NoDup_string s'\n  end.",
                "postcond": "(* result = None iff there are no repeated characters in s.\n     result = Some ch iff ch is the first character whose second occurrence appears earliest,\n     i.e., there exist pre and suf such that s = pre ++ ch :: suf, ch appears in pre,\n     and pre has no duplicates (so no repetition occurs before that position). *)\n  (result = None <-> NoDup_string s) /\\\n  (forall ch : ascii,\n      result = Some ch <->\n      exists pre suf : string,\n        s = String.append pre (String.String ch suf) /\\\n        In_string ch pre /\\\n        NoDup_string pre)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_27": {
          "data_id": "verina_advanced_27",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Compute the length of a Coq string (which is a list of ascii) *)\nFixpoint strlen (s : string) : nat :=\n  match s with\n  | EmptyString => 0\n  | String _ r => S (strlen r)\n  end.\n\n(* Boolean less-or-equal on nat *)\nFixpoint leb (m n : nat) : bool :=\n  match m, n with\n  | O, _ => true\n  | S _, O => false\n  | S m', S n' => leb m' n'\n  end.\n\n(* Simple addition on nat to avoid needing extra imports *)\nFixpoint addn (m n : nat) : nat :=\n  match m with\n  | O => n\n  | S m' => S (addn m' n)\n  end.\n\n(* Choose the longer of two strings (return the second if equal length) *)\nDefinition longer_string (x y : string) : string :=\n  if leb (strlen x) (strlen y) then y else x.\n\n(* Fuel-based LCS to ensure structural recursion termination on fuel *)\nFixpoint lcs_fuel (s1 s2 : string) (fuel : nat) : string :=\n  match fuel with\n  | O => EmptyString\n  | S fuel' =>\n      match s1, s2 with\n      | EmptyString, _ => EmptyString\n      | _, EmptyString => EmptyString\n      | String c1 r1, String c2 r2 =>\n          match Ascii.ascii_dec c1 c2 with\n          | left _ => String c1 (lcs_fuel r1 r2 fuel')\n          | right _ =>\n              let x := lcs_fuel r1 (String c2 r2) fuel' in\n              let y := lcs_fuel (String c1 r1) r2 fuel' in\n              longer_string x y\n          end\n      end\n  end.",
                "code": "(* Use fuel = length(s1) + length(s2) to guarantee termination and sufficient exploration *)\n  lcs_fuel s1 s2 (addn (strlen s1) (strlen s2))",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Subsequence relation over Coq strings *)\nInductive subseq : string -> string -> Prop :=\n| subseq_empty : forall s, subseq EmptyString s\n| subseq_skip  : forall (a : ascii) (s t : string), subseq s t -> subseq s (String a t)\n| subseq_match : forall (a : ascii) (s t : string), subseq s t -> subseq (String a s) (String a t).\n\n(* String length (to compare lengths for maximality) *)\nFixpoint strlen (s : string) : nat :=\n  match s with\n  | EmptyString => 0\n  | String _ t => S (strlen t)\n  end.",
                "postcond": "subseq result s1 /\\\n  subseq result s2 /\\\n  (forall u, subseq u s1 /\\ subseq u s2 -> strlen u <= strlen result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_28": {
          "data_id": "verina_advanced_28",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Membership test in a list of Z using Z.eqb *)\nFixpoint mem_z (x : Z) (l : list Z) : bool :=\n  match l with\n  | [] => false\n  | y :: ys => if Z.eqb x y then true else mem_z x ys\n  end.\n\n(* Length of the consecutive run starting at x (including x), bounded by fuel *)\nFixpoint cons_len (fuel : nat) (x : Z) (l : list Z) : nat :=\n  match fuel with\n  | O => 0\n  | S f' =>\n      if mem_z (x + 1) l\n      then S (cons_len f' (x + 1) l)\n      else 1\n  end.\n\n(* Compute the longest consecutive sequence length by scanning the list.\n   For each element x that is a start (x-1 not in the list), compute the\n   run length starting at x and take the maximum over all such starts. *)\nFixpoint longest_from (l : list Z) (all : list Z) (fuel : nat) : nat :=\n  match l with\n  | [] => 0\n  | x :: xs =>\n      let tail := longest_from xs all fuel in\n      if negb (mem_z (x - 1) all)\n      then Nat.max (cons_len fuel x all) tail\n      else tail\n  end.",
                "code": "let fuel := length nums in\n  longest_from nums nums fuel",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* result is the maximum length k of a consecutive sequence present in nums *)\n  (exists x : Z, forall i : nat, (i < result)%nat -> In (x + Z.of_nat i) nums)\n  /\\\n  (forall k : nat, forall x : Z,\n      (forall i : nat, (i < k)%nat -> In (x + Z.of_nat i) nums) ->\n      (k <= result)%nat)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_28": {
          "data_id": "verina_basic_28",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Check if d divides n by searching for a multiplier q with 1 â‰¤ q â‰¤ n such that d * q = n *)\nDefinition dividesb (n d : nat) : bool :=\n  match d with\n  | 0 => false  (* by convention, 0 does not divide any n in this boolean checker *)\n  | _ =>\n      (* Loop over q from 1 to n (inclusive). Structural recursion on q ensures termination. *)\n      let fix loop (q : nat) : bool :=\n        match q with\n        | 0 => false\n        | S q' => if Nat.eqb (d * (S q')) n then true else loop q'\n        end\n      in loop n\n  end.\n\n(* Search for any divisor d in the range [2 .. n-1].\n   We parameterize by k = n - 2 and enumerate d as k+1, k, ..., 2. *)\nFixpoint has_divisor_upto (n k : nat) : bool :=\n  match k with\n  | 0 => false\n  | S k' =>\n      let d := S (S k') in  (* d = 2 + k' runs from n-1 down to 2 *)\n      if dividesb n d then true else has_divisor_upto n k'\n  end.",
                "code": "(* Handle small n explicitly; for n >= 2, check absence of divisors in (1, n) *)\n  match n with\n  | 0 => false\n  | 1 => false\n  | S (S n') => negb (has_divisor_upto n n')\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "2 <= n",
                "postcond_aux": "",
                "postcond": "(* result = true iff n has no nontrivial divisor between 1 and n *)\n  ((result = true) <->\n    (forall k : nat, (1 < k /\\ k < n) -> forall m : nat, n <> m * k))\n  /\\\n  (* result = false iff there exists a nontrivial divisor of n *)\n  ((result = false) <->\n    (exists k : nat, 1 < k /\\ k < n /\\ exists m : nat, n = m * k))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_29": {
          "data_id": "verina_advanced_29",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: append element to the end of a list *)\nFixpoint snoc (l : list nat) (x : nat) : list nat :=\n  match l with\n  | [] => [x]\n  | y :: ys => y :: snoc ys x\n  end.\n\n(* Frequency map as association list: list (key, count) *)\n\nFixpoint get_freq (key : nat) (m : list (nat * nat)) : nat :=\n  match m with\n  | [] => 0\n  | (k, v) :: ms => if Nat.eqb key k then v else get_freq key ms\n  end.\n\nFixpoint set_freq (key : nat) (val : nat) (m : list (nat * nat)) : list (nat * nat) :=\n  match m with\n  | [] =>\n      if Nat.eqb val 0 then [] else [(key, val)]\n  | (k, v) :: ms =>\n      if Nat.eqb key k\n      then if Nat.eqb val 0 then ms else (k, val) :: ms\n      else (k, v) :: set_freq key val ms\n  end.\n\nDefinition inc_freq (key : nat) (m : list (nat * nat)) : list (nat * nat) :=\n  let f := get_freq key m in\n  set_freq key (S f) m.\n\nDefinition dec_freq (key : nat) (m : list (nat * nat)) : list (nat * nat) :=\n  let f := get_freq key m in\n  if Nat.eqb f 0 then m else set_freq key (Nat.pred f) m.\n\n(* Shrink the window from the left until the count of x is <= k.\n   Precondition (from the calling context): window is non-empty whenever needed. *)\nFixpoint shrink_until_valid\n  (x k : nat)\n  (window : list nat) (wlen : nat)\n  (freq : list (nat * nat)) : (list nat * nat * list (nat * nat)) :=\n  match window with\n  | [] => ([], 0, freq)\n  | y :: ys =>\n      let freq2 := dec_freq y freq in\n      let wlen2 := Nat.pred wlen in\n      if Nat.leb (get_freq x freq2) k\n      then (ys, wlen2, freq2)\n      else shrink_until_valid x k ys wlen2 freq2\n  end.\n\n(* Main sliding window loop over the remaining list \"rest\" *)\nFixpoint longest_good_loop\n  (window : list nat) (wlen : nat)\n  (rest : list nat)\n  (freq : list (nat * nat))\n  (k : nat)\n  (best : nat) {struct rest} : nat :=\n  match rest with\n  | [] => Nat.max best wlen\n  | x :: rest' =>\n      let freq1 := inc_freq x freq in\n      let cx := get_freq x freq1 in\n      if Nat.leb cx k then\n        let window1 := snoc window x in\n        let wlen1 := S wlen in\n        let best1 := Nat.max best wlen1 in\n        longest_good_loop window1 wlen1 rest' freq1 k best1\n      else\n        (* Need to shrink from the left until count of x <= k; note freq1 already includes x *)\n        let '(window2, wlen2, freq2) := shrink_until_valid x k window wlen freq1 in\n        let window3 := snoc window2 x in\n        let wlen3 := S wlen2 in\n        let best3 := Nat.max best wlen3 in\n        (* freq2 already accounts for x inside the window; do not increment again *)\n        longest_good_loop window3 wlen3 rest' freq2 k best3\n  end.",
                "code": "(* Sliding window with frequency map to ensure each element's count <= k *)\n  longest_good_loop [] 0 nums [] k 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* k is a positive natural number *)\n  exists p, k = S p",
                "postcond_aux": "(* Count occurrences of a value x in a list l *)\nFixpoint count (x : nat) (l : list nat) : nat :=\n  match l with\n  | [] => 0\n  | y :: ys => if Nat.eqb x y then S (count x ys) else count x ys\n  end.\n\n(* A list l is \"good\" w.r.t. k if every element's frequency is <= k *)\nDefinition good_array (l : list nat) (k : nat) : Prop :=\n  forall x, count x l <= k.\n\n(* l is a contiguous subarray of nums if nums = l1 ++ l ++ l2 for some l1 l2 *)\nDefinition is_subarray (l nums : list nat) : Prop :=\n  exists l1 l2, nums = l1 ++ l ++ l2.\n\n(* Non-empty good subarray predicate *)\nDefinition GoodSubarray (l nums : list nat) (k : nat) : Prop :=\n  is_subarray l nums /\\ l <> [] /\\ good_array l k.",
                "postcond": "(* Maximality and existence (or 0 if none exists) for the length of good subarrays *)\n  (forall l, GoodSubarray l nums k -> length l <= result)\n  /\\\n  ((exists l, GoodSubarray l nums k) -> exists l, GoodSubarray l nums k /\\ length l = result)\n  /\\\n  (~ (exists l, GoodSubarray l nums k) -> result = 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_29": {
          "data_id": "verina_basic_29",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Remove the element at index k (0-based) from a list of integers.\n   If k = 0, drop the head; otherwise, recurse on the tail decreasing k. *)\nFixpoint remove_at (l : list Z) (k : nat) : list Z :=\n  match l, k with\n  | [], _ => []\n  | _ :: xs, O => xs\n  | x :: xs, S k' => x :: remove_at xs k'\n  end.",
                "code": "remove_at s k",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* k must be a valid index into s *)\n  k < length s",
                "postcond_aux": "",
                "postcond": "(* The result is s with the element at index k removed, preserving order *)\n  exists (l1 : list Z) (x : Z) (l2 : list Z),\n    s = l1 ++ x :: l2 /\\ length l1 = k /\\ result = l1 ++ l2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_30": {
          "data_id": "verina_basic_30",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Auxiliary recursive function to compute element-wise modulo.\n   It recurses structurally on the first list [a]. The precondition\n   of the main function guarantees that [a] and [b] have the same\n   length and that all elements of [b] are non-zero. *)\nFixpoint elementWiseModuloAux (a b : list Z) : list Z :=\n  match a with\n  | [] => []\n  | x :: xs =>\n      match b with\n      | [] => [] (* Should not happen due to precondition *)\n      | y :: ys => (Z.rem x y) :: elementWiseModuloAux xs ys\n      end\n  end.",
                "code": "(* Directly delegate to the structurally recursive auxiliary function. *)\n  elementWiseModuloAux a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* Arrays must be non-empty, have equal lengths, and divisors are non-zero *)\n  a <> [] /\\ b <> [] /\\\n  length a = length b /\\\n  Forall (fun y : Z => y <> 0) b",
                "postcond_aux": "",
                "postcond": "(* The result has the same length as the inputs, and each element is the modulo\n     of the corresponding elements from a and b. We use List.nth with a default 0,\n     but only for indices i < length a (and hence < length b by the precondition). *)\n  length result = length a /\\\n  forall (i : nat),\n    i < length a ->\n    List.nth i result 0 = (List.nth i a 0) mod (List.nth i b 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_30": {
          "data_id": "verina_advanced_30",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper that scans the list while tracking:\n   - prev: the previous element (if any)\n   - cur:  current length of the ongoing increasing streak\n   - maxlen: maximum streak length seen so far\n   The recursion structurally decreases on the list l. *)\nFixpoint longest_streak_aux (prev : option Z) (cur maxlen : nat) (l : list Z) {struct l} : nat :=\n  match l with\n  | nil => Nat.max cur maxlen\n  | x :: xs =>\n      match prev with\n      | None =>\n          (* Start a new streak with the first element *)\n          longest_streak_aux (Some x) 1 maxlen xs\n      | Some p =>\n          (* Continue streak if strictly increasing, otherwise reset *)\n          if Z.ltb p x\n          then longest_streak_aux (Some x) (S cur) maxlen xs\n          else longest_streak_aux (Some x) 1 (Nat.max maxlen cur) xs\n      end\n  end.",
                "code": "(* Initialize with no previous element, current streak 0, and max 0. *)\n  longest_streak_aux None 0 0 nums",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* A subarray is contiguous if it appears as a block within the list. *)\nDefinition Subarray (sub l : list Z) : Prop :=\n  exists l1 l2, l = l1 ++ sub ++ l2.\n\n(* Non-empty list helper. *)\nDefinition NonEmpty {A} (l : list A) : Prop :=\n  exists x t, l = x :: t.\n\n(* Strictly increasing on consecutive elements. *)\nFixpoint StrictlyIncreasing (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: t => x < y /\\ StrictlyIncreasing (y :: t)\n  end.",
                "postcond": "(* Empty list yields 0. Otherwise, result is exactly the maximum length\n     among all non-empty, strictly increasing contiguous subarrays. *)\n  (nums = [] -> result = 0) /\\\n  (nums <> [] ->\n    exists sub,\n      Subarray sub nums /\\\n      NonEmpty sub /\\\n      StrictlyIncreasing sub /\\\n      length sub = result) /\\\n  (forall sub,\n      Subarray sub nums ->\n      NonEmpty sub ->\n      StrictlyIncreasing sub ->\n      length sub <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_31": {
          "data_id": "verina_advanced_31",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Replace the first element in tails that is >= x with x; if none, append x at the end.\n   This maintains tails as a nondecreasing list of minimal possible tail values for\n   increasing subsequences of each length. *)\nFixpoint update_tails (x : Z) (ts : list Z) {struct ts} : list Z :=\n  match ts with\n  | [] => [x]\n  | t :: ts' =>\n      if Z.leb x t\n      then x :: ts'\n      else t :: update_tails x ts'\n  end.\n\n(* Process the input list, updating the tails list for each element. *)\nFixpoint process_lis (xs : list Z) (tails : list Z) {struct xs} : list Z :=\n  match xs with\n  | [] => tails\n  | x :: xs' => process_lis xs' (update_tails x tails)\n  end.",
                "code": "(* The length of the tails list after processing equals the LIS length. *)\n  length (process_lis xs [])",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Subsequence relation: s is a subsequence of l if s can be obtained by deleting\n   zero or more elements from l without changing the order of the remaining ones. *)\nInductive subseq : list Z -> list Z -> Prop :=\n| subseq_nil : forall l, subseq [] l\n| subseq_skip : forall x l1 l2, subseq l1 l2 -> subseq l1 (x :: l2)\n| subseq_take : forall x l1 l2, subseq l1 l2 -> subseq (x :: l1) (x :: l2).\n\n(* Strictly increasing sequence predicate *)\nFixpoint strictly_increasing (l : list Z) : Prop :=\n  match l with\n  | nil => True\n  | _ :: nil => True\n  | x :: y :: t => Z.lt x y /\\ strictly_increasing (y :: t)\n  end.",
                "postcond": "(* Soundness: result is the length of some strictly increasing subsequence of xs.\n     Completeness: no strictly increasing subsequence of xs is longer than result. *)\n  (exists s : list Z,\n      subseq s xs /\\ strictly_increasing s /\\ List.length s = result)\n  /\\ (forall s' : list Z,\n        subseq s' xs -> strictly_increasing s' -> List.length s' <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_31": {
          "data_id": "verina_basic_31",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Convert a single ascii character to uppercase if it is a lowercase letter *)\nDefinition is_lowercase_ascii (c : ascii) : bool :=\n  let n := Ascii.nat_of_ascii c in\n  andb (Nat.leb 97 n) (Nat.leb n 122).\n\nDefinition to_upper_ascii (c : ascii) : ascii :=\n  let n := Ascii.nat_of_ascii c in\n  if is_lowercase_ascii c\n  then Ascii.ascii_of_nat (n - 32)\n  else c.\n\n(* Map a function over all characters of a string *)\nFixpoint map_string (f : ascii -> ascii) (s : string) : string :=\n  match s with\n  | EmptyString => EmptyString\n  | String c rest => String (f c) (map_string f rest)\n  end.",
                "code": "(* Map the per-character uppercase conversion across the whole string *)\n  map_string to_upper_ascii s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Character-level predicate: c' is the uppercase-converted version of c.\n   - If c is a lowercase ASCII letter ('a'..'z'), then c' has code (code c - 32).\n   - Otherwise, c' equals c. *)\nDefinition is_lower_ascii (c : ascii) : Prop :=\n  97 <= nat_of_ascii c /\\ nat_of_ascii c <= 122.\n\nDefinition char_map_upper (c c' : ascii) : Prop :=\n  (is_lower_ascii c -> nat_of_ascii c' = nat_of_ascii c - 32) /\\\n  (~ is_lower_ascii c -> c' = c).\n\n(* String-level relation: result is obtained by pointwise applying char_map_upper *)\nInductive map_upper (s r : string) : Prop :=\n| map_upper_nil :\n    map_upper EmptyString EmptyString\n| map_upper_cons :\n    forall (c c' : ascii) (s' r' : string),\n      char_map_upper c c' ->\n      map_upper s' r' ->\n      map_upper (String c s') (String c' r').",
                "postcond": "map_upper s result /\\ String.length s = String.length result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_32": {
          "data_id": "verina_advanced_32",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Maximum of two natural numbers defined structurally *)\nFixpoint max_nat (n m : nat) : nat :=\n  match n, m with\n  | O, _ => m\n  | S n', O => S n'\n  | S n', S m' => S (max_nat n' m')\n  end.\n\n(* Compute the maximum DP length among previous values strictly less than x *)\nFixpoint max_dp_lt (vals : list Z) (dps : list nat) (x : Z) : nat :=\n  match vals, dps with\n  | [], [] => 0\n  | v :: vs, d :: ds =>\n      let rest := max_dp_lt vs ds x in\n      if Z.ltb v x then max_nat d rest else rest\n  | _, _ => 0 (* safety for mismatched lists; should not occur in our use *)\n  end.\n\n(* Dynamic programming over the list to compute LIS length.\n   vals/dps store previously seen values and their LIS-ending lengths (in reverse order).\n   curMax tracks the best LIS length seen so far. *)\nFixpoint lis_dp (vals : list Z) (dps : list nat) (l : list Z) (curMax : nat) : nat :=\n  match l with\n  | [] => curMax\n  | x :: xs =>\n      let best_prev := max_dp_lt vals dps x in\n      let lenx := S best_prev in\n      let curMax' := max_nat curMax lenx in\n      lis_dp (x :: vals) (lenx :: dps) xs curMax'\n  end.",
                "code": "(* Initialize DP with empty history and current maximum 0 *)\n  lis_dp [] [] numbers 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Adjacent-all predicate over a list with a binary relation *)\nFixpoint adjacent_all {A : Type} (R : A -> A -> Prop) (l : list A) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: t => R x y /\\ adjacent_all R (y :: t)\n  end.\n\n(* All indices are within [0, n) *)\nDefinition indices_in_range (n : nat) (idxs : list nat) : Prop :=\n  Forall (fun i => (i < n)%nat) idxs.\n\n(* Relation for indices i < j selecting a strictly increasing pair of values from numbers *)\nDefinition incpair (numbers : list Z) (i j : nat) : Prop :=\n  (i < j)%nat /\\\n  (i < length numbers)%nat /\\\n  (j < length numbers)%nat /\\\n  Z.lt (List.nth numbers i 0%Z) (List.nth numbers j 0%Z).\n\n(* An increasing subsequence is given by a strictly increasing list of indices,\n   all in range, whose corresponding values are strictly increasing pairwise on adjacent indices. *)\nDefinition inc_subseq (numbers : list Z) (idxs : list nat) : Prop :=\n  indices_in_range (length numbers) idxs /\\\n  adjacent_all (incpair numbers) idxs.",
                "postcond": "(* result is exactly the maximum length of any strictly increasing subsequence *)\n  (exists idxs : list nat, inc_subseq numbers idxs /\\ length idxs = result)\n  /\\\n  (forall idxs : list nat, inc_subseq numbers idxs -> length idxs <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_32": {
          "data_id": "verina_basic_32",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper that splits a non-empty list into (all-but-last, last) *)\nFixpoint split_last (l : list Z) : option (list Z * Z) :=\n  match l with\n  | nil => None\n  | x :: nil => Some (nil, x)\n  | x :: xs =>\n      match split_last xs with\n      | None => None\n      | Some (init, last) => Some (x :: init, last)\n      end\n  end.",
                "code": "(* Handle by structure of the list:\n     - empty or singleton: unchanged\n     - otherwise: move last to front and first to end, keep middle intact *)\n  match a with\n  | nil => nil\n  | x :: nil => [x]\n  | x :: xs =>\n      match split_last xs with\n      | Some (init', last) => last :: init' ++ [x]\n      | None => x :: xs (* unreachable given the pattern above, fallback to original *)\n      end\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* The input list must be non-empty to allow swapping first and last elements. *)\n  a <> []",
                "postcond_aux": "",
                "postcond": "(* If the list has exactly one element, the result is identical. *)\n  (exists x : Z, a = [x] /\\ result = [x])\n  \\/\n  (* If the list has at least two elements, swap the first and last while keeping the middle intact. *)\n  (exists (x y : Z) (m : list Z),\n      a = x :: m ++ [y]\n   /\\ result = y :: m ++ [x])",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_33": {
          "data_id": "verina_advanced_33",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Return the first index i in l such that l[i] >= x. If no such element exists, return length l.\n   This is a linear \"lower_bound\" specialized to Z with >= comparison (strict LIS needs >=). *)\nFixpoint lower_bound_ge (l : list Z) (x : Z) : nat :=\n  match l with\n  | [] => 0\n  | y :: ys =>\n      if Z.leb x y then 0\n      else S (lower_bound_ge ys x)\n  end.\n\n(* Update the n-th element of the list with x (0-based).\n   If n is out of bounds, we return [] (should not happen in our usage). *)\nFixpoint update_nth (l : list Z) (n : nat) (x : Z) : list Z :=\n  match l, n with\n  | [], _ => []\n  | _ :: ys, 0 => x :: ys\n  | y :: ys, S n' => y :: update_nth ys n' x\n  end.\n\n(* Process the input numbers, maintaining the classic \"tails\" array for LIS.\n   - tails[k] stores the minimum possible tail value of an increasing subsequence of length k+1.\n   For each x:\n     i := first index with tails[i] >= x\n     if i == length tails then append x\n     else set tails[i] := x *)\nFixpoint lis_tails (nums : list Z) (tails : list Z) : list Z :=\n  match nums with\n  | [] => tails\n  | x :: xs =>\n      let i := lower_bound_ge tails x in\n      let tails' :=\n        if Nat.eqb i (length tails)\n        then tails ++ [x]\n        else update_nth tails i x in\n      lis_tails xs tails'\n  end.",
                "code": "(* The LIS length is simply the length of the computed tails list. *)\n  length (lis_tails nums [])",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* A standard subsequence relation: xs is a subsequence of ys if xs can be\n   obtained by deleting zero or more elements from ys without reordering. *)\nInductive subseq : list Z -> list Z -> Prop :=\n| subseq_nil : forall ys, subseq [] ys\n| subseq_cons_both : forall x xs ys, subseq xs ys -> subseq (x :: xs) (x :: ys)\n| subseq_cons_right : forall x xs ys, subseq xs ys -> subseq xs (x :: ys).\n\n(* Strictly increasing list of integers: every adjacent pair increases. *)\nFixpoint strictly_increasing (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: xs => x < y /\\ strictly_increasing (y :: xs)\n  end.",
                "postcond": "exists s : list Z,\n    subseq s nums /\\\n    strictly_increasing s /\\\n    length s = result /\\\n    (forall t : list Z, subseq t nums -> strictly_increasing t -> le (length t) result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_33": {
          "data_id": "verina_basic_33",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: scans the sorted list s while tracking the current expected number m.\n   - If head x < m, skip it (duplicates or smaller values).\n   - If head x = m, increment m and continue.\n   - If head x > m, m is the smallest missing number. *)\nFixpoint smallest_missing_from (s : list nat) (m : nat) : nat :=\n  match s with\n  | [] => m\n  | x :: xs =>\n      if Nat.leb x m then\n        if Nat.eqb x m then smallest_missing_from xs (S m)\n        else smallest_missing_from xs m\n      else m\n  end.",
                "code": "smallest_missing_from s 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(~ List.In result s) /\\\n  (forall m : nat, m < result -> List.In m s)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_34": {
          "data_id": "verina_basic_34",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: filter out only even numbers from a list of Z, preserving order *)\nFixpoint filter_even (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | x :: xs =>\n      if Z.even x\n      then x :: filter_even xs\n      else filter_even xs\n  end.",
                "code": "(* Use the helper to collect all even numbers in order *)\n  filter_even arr",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = List.filter Z.even arr",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_34": {
          "data_id": "verina_advanced_34",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper that computes the length of the longest strictly increasing subsequence\n   that can be formed from the list l starting with a previous chosen element p.\n   It returns the number of elements to add after p (p itself is not counted here). *)\nFixpoint inc_from (p : Z) (l : list Z) : Z :=\n  match l with\n  | nil => 0\n  | y :: ys =>\n      if Z.ltb p y\n      then Z.max (1 + inc_from y ys) (inc_from p ys)\n      else inc_from p ys\n  end.\n\n(* Main helper that computes the LIS length for the whole list. *)\nFixpoint lis_len (l : list Z) : Z :=\n  match l with\n  | nil => 0\n  | x :: xs => Z.max (1 + inc_from x xs) (lis_len xs)\n  end.",
                "code": "lis_len nums",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* A standard inductive definition of subsequence: s is a subsequence of l *)\nInductive subseq : list Z -> list Z -> Prop :=\n| subseq_nil : forall ys, subseq [] ys\n| subseq_skip : forall x xs ys, subseq xs ys -> subseq xs (x :: ys)\n| subseq_take : forall x xs ys, subseq xs ys -> subseq (x :: xs) (x :: ys).\n\n(* Strictly increasing list of integers: every adjacent pair increases *)\nFixpoint strictly_increasing (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: t => x < y /\\ strictly_increasing (y :: t)\n  end.",
                "postcond": "exists s : list Z,\n    subseq s nums /\\\n    strictly_increasing s /\\\n    result = Z.of_nat (length s) /\\\n    forall t : list Z,\n      subseq t nums ->\n      strictly_increasing t ->\n      (Z.of_nat (length t) <= result)%Z",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_35": {
          "data_id": "verina_advanced_35",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boyerâ€“Moore majority vote auxiliary: processes the list while carrying a candidate and its count *)\nFixpoint bm_aux (l : list Z) (cand : Z) (cnt : Z) : Z :=\n  match l with\n  | nil => cand\n  | x :: xs =>\n      if Z.eqb cnt 0 then\n        bm_aux xs x 1\n      else if Z.eqb x cand then\n        bm_aux xs cand (cnt + 1)\n      else\n        bm_aux xs cand (cnt - 1)\n  end.",
                "code": "(* Use Boyerâ€“Moore algorithm; precondition guarantees nums is non-empty and has a majority *)\n  match nums with\n  | nil => 0\n  | x :: xs => bm_aux xs x 1\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "exists x : Z, Z.of_nat (count_occ Z.eq_dec nums x) > Z.of_nat (length nums) / 2",
                "postcond_aux": "",
                "postcond": "Z.of_nat (count_occ Z.eq_dec nums result) > Z.of_nat (length nums) / 2 /\\\n  (forall x : Z, Z.of_nat (count_occ Z.eq_dec nums x) > Z.of_nat (length nums) / 2 -> x = result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_35": {
          "data_id": "verina_basic_35",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper that traverses the list once, collecting non-zeros and zeros in\n   accumulators, then reverses to restore original order and concatenates. *)\nFixpoint move_zeroes_aux (l nz_acc z_acc : list Z) {struct l} : list Z :=\n  match l with\n  | [] => rev nz_acc ++ rev z_acc\n  | x :: xs =>\n      if Z.eqb x 0\n      then move_zeroes_aux xs nz_acc (x :: z_acc)\n      else move_zeroes_aux xs (x :: nz_acc) z_acc\n  end.",
                "code": "move_zeroes_aux arr [] []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result =\n    (List.filter (fun z => negb (Z.eqb z 0%Z)) arr) ++\n    (List.repeat 0%Z (List.count_occ Z.eq_dec arr 0%Z))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_36": {
          "data_id": "verina_basic_36",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to replace a single character: space, comma, or dot -> colon; otherwise unchanged *)\nDefinition replace_char (c : Ascii.ascii) : Ascii.ascii :=\n  if Ascii.ascii_dec c (\" \"%char) then (\":\"%char)\n  else if Ascii.ascii_dec c (\",\"%char) then (\":\"%char)\n  else if Ascii.ascii_dec c (\".\"%char) then (\":\"%char)\n  else c.\n\n(* Map a character-wise function over a string *)\nFixpoint map_string (f : Ascii.ascii -> Ascii.ascii) (s : string) : string :=\n  match s with\n  | String.EmptyString => String.EmptyString\n  | String.String ch tl => String.String (f ch) (map_string f tl)\n  end.",
                "code": "(* Apply character-wise replacement over the entire string *)\n  map_string replace_char s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Extract the first character (ascii) of a non-empty string literal.\n   For known one-character literals like \" \", \",\", \".\", \":\" this yields the intended ascii. *)\nDefinition char_of_string (s : string) : ascii :=\n  match s with\n  | String c _ => c\n  | EmptyString => Ascii false false false false false false false false\n  end.\n\n(* Named ascii constants for clarity *)\nDefinition space : ascii := char_of_string \" \".\nDefinition comma : ascii := char_of_string \",\".\nDefinition dot   : ascii := char_of_string \".\".\nDefinition colon : ascii := char_of_string \":\".\n\n(* A character is subject to replacement iff it is space, comma, or dot *)\nDefinition is_replaced (c : ascii) : Prop :=\n  c = space \\/ c = comma \\/ c = dot.\n\n(* Relation between an input character and the corresponding output character *)\nDefinition char_rel (c_in c_out : ascii) : Prop :=\n  (is_replaced c_in -> c_out = colon) /\\\n  (~ is_replaced c_in -> c_out = c_in).\n\n(* Character-wise relational specification over strings.\n   It enforces equal length (mismatched lengths yield False) and per-character relation. *)\nFixpoint string_rel (s_in s_out : string) : Prop :=\n  match s_in, s_out with\n  | EmptyString, EmptyString => True\n  | String c_in t_in, String c_out t_out =>\n      char_rel c_in c_out /\\ string_rel t_in t_out\n  | _, _ => False\n  end.",
                "postcond": "string_rel s result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_36": {
          "data_id": "verina_advanced_36",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean equality on natural numbers, defined recursively *)\nFixpoint nat_eqb (a b : nat) : bool :=\n  match a, b with\n  | O, O => true\n  | S a', S b' => nat_eqb a' b'\n  | _, _ => false\n  end.\n\n(* Boyerâ€“Moore majority vote helper:\n   Processes the list maintaining a candidate and a counter.\n   Returns the final candidate and its counter (counter not used further). *)\nFixpoint majority_vote (xs : list nat) (cand : nat) (cnt : nat) : nat * nat :=\n  match xs with\n  | [] => (cand, cnt)\n  | x :: xs' =>\n      match cnt with\n      | O => majority_vote xs' x 1\n      | S k =>\n          if nat_eqb x cand\n          then majority_vote xs' cand (S (S k)) (* increment cnt = S cnt *)\n          else majority_vote xs' cand k         (* decrement cnt = pred cnt *)\n      end\n  end.\n\n(* Extract just the candidate from the majority vote process. *)\nDefinition majority_candidate (xs : list nat) : nat :=\n  let '(c, _) := majority_vote xs 0 0 in c.",
                "code": "(* By the precondition, a majority element exists, so the Boyerâ€“Moore\n     candidate is the correct answer. *)\n  majority_candidate xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "(* Boolean equality on nat *)\nFixpoint nat_eqb (x y : nat) : bool :=\n  match x, y with\n  | O, O => true\n  | S x', S y' => nat_eqb x' y'\n  | _, _ => false\n  end.\n\n(* Count occurrences of a value in a list of nat *)\nFixpoint count_nat (x : nat) (xs : list nat) : nat :=\n  match xs with\n  | [] => 0\n  | y :: ys => if nat_eqb x y then S (count_nat x ys) else count_nat x ys\n  end.",
                "precond": "(* A majority element exists *)\n  exists m : nat, (count_nat m xs > Nat.div (length xs) 2)%nat",
                "postcond_aux": "",
                "postcond": "(* result is the (unique) majority element *)\n  (count_nat result xs > Nat.div (length xs) 2)%nat /\\\n  (forall y : nat, (count_nat y xs > Nat.div (length xs) 2)%nat -> y = result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_37": {
          "data_id": "verina_advanced_37",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boyer-Moore majority vote algorithm to compute a candidate.\n   Since a majority element is guaranteed to exist (by the precondition),\n   the candidate returned will be the majority element. *)\nFixpoint majority_vote (l : list Z) (cand : Z) (count : nat) : Z :=\n  match l with\n  | nil => cand\n  | x :: xs =>\n      match count with\n      | O => majority_vote xs x 1%nat\n      | S k =>\n          if Z.eqb x cand\n          then majority_vote xs cand (S (S k)) (* increment count *)\n          else majority_vote xs cand k         (* decrement count *)\n      end\n  end.",
                "code": "(* Initialize the candidate from the first element, then fold the rest *)\n  match nums with\n  | nil => 0%Z (* Unused by spec since a majority element exists; provided for totality *)\n  | x :: xs => majority_vote xs x 1%nat\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "exists x : Z, Z.of_nat (count_occ Z.eq_dec nums x) > (Z.of_nat (length nums)) / 2",
                "postcond_aux": "",
                "postcond": "(Z.of_nat (count_occ Z.eq_dec nums result) > (Z.of_nat (length nums)) / 2) /\\\n  (forall y : Z, Z.of_nat (count_occ Z.eq_dec nums y) > (Z.of_nat (length nums)) / 2 -> y = result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_37": {
          "data_id": "verina_basic_37",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: scan the list from left to right with a current index (as Z).\n   Because the array is sorted in non-decreasing order, we can stop early\n   when the current element exceeds the target. *)\nFixpoint findFirstOccurrence_aux (l : list Z) (target : Z) (idx : Z) : Z :=\n  match l with\n  | [] => -1\n  | x :: xs =>\n      if Z.eqb x target then idx\n      else if Z.ltb target x then -1\n      else findFirstOccurrence_aux xs target (idx + 1)\n  end.",
                "code": "(* Start scanning from index 0 *)\n  findFirstOccurrence_aux arr target 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* arr is sorted in non-decreasing order *)\n  forall (i : nat), S i < List.length arr -> List.nth i arr 0 <= List.nth (S i) arr 0",
                "postcond_aux": "",
                "postcond": "(* Either target is absent and result = -1, or result encodes the first index k of target *)\n  ((result = -1) /\\ ~ List.In target arr)\n  \\/\n  (exists (k : nat),\n      result = Z.of_nat k /\\\n      k < List.length arr /\\\n      List.nth k arr 0 = target /\\\n      (forall (i : nat), i < k -> List.nth i arr 0 <> target)\n  )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_38": {
          "data_id": "verina_advanced_38",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Basic boolean comparison on nat *)\nFixpoint leb_nat (a b : nat) : bool :=\n  match a, b with\n  | O, _ => true\n  | S _, O => false\n  | S a', S b' => leb_nat a' b'\n  end.\n\n(* Truncated subtraction on nat *)\nFixpoint sub_nat (a b : nat) : nat :=\n  match a, b with\n  | O, _ => 0\n  | a', O => a'\n  | S a', S b' => sub_nat a' b'\n  end.\n\n(* Minimum and maximum on nat using leb_nat *)\nDefinition max_nat (a b : nat) : nat :=\n  if leb_nat a b then b else a.\n\nDefinition min_nat (a b : nat) : nat :=\n  if leb_nat a b then a else b.\n\n(* Normalize an interval so that start <= end *)\nDefinition normalize_interval (p : nat * nat) : nat * nat :=\n  let s := fst p in\n  let e := snd p in\n  (min_nat s e, max_nat s e).\n\n(* Insertion sort by interval start (fst) *)\nFixpoint insert_by_start (p : nat * nat) (l : list (nat * nat)) : list (nat * nat) :=\n  match l with\n  | [] => [p]\n  | q :: qs =>\n      if leb_nat (fst p) (fst q)\n      then p :: l\n      else q :: insert_by_start p qs\n  end.\n\nFixpoint isort_by_start (l : list (nat * nat)) : list (nat * nat) :=\n  match l with\n  | [] => []\n  | x :: xs => insert_by_start x (isort_by_start xs)\n  end.\n\n(* Compute coverage (length of union) of a list of intervals.\n   Assumes the list is normalized and sorted by start. *)\nFixpoint coverage_sorted_aux (cur : nat * nat) (rest : list (nat * nat)) (acc : nat) : nat :=\n  match rest with\n  | [] => acc + sub_nat (snd cur) (fst cur)\n  | h :: t =>\n      let s := fst h in\n      let e := snd h in\n      let cs := fst cur in\n      let ce := snd cur in\n      if leb_nat s ce\n      then\n        let new_ce := max_nat ce e in\n        coverage_sorted_aux (cs, new_ce) t acc\n      else\n        let acc' := acc + sub_nat ce cs in\n        coverage_sorted_aux h t acc'\n  end.\n\nDefinition coverage (l : list (nat * nat)) : nat :=\n  let lnorm := map normalize_interval l in\n  let lsorted := isort_by_start lnorm in\n  match lsorted with\n  | [] => 0\n  | h :: t => coverage_sorted_aux h t 0\n  end.\n\n(* Iterate over all possibilities of removing exactly one interval,\n   taking the maximum coverage of the remaining ones. *)\nFixpoint max_after_remove_aux (prefix_rev : list (nat * nat)) (l : list (nat * nat)) : nat :=\n  match l with\n  | [] => 0\n  | x :: xs =>\n      let candidate_list := rev prefix_rev ++ xs in\n      let cand := coverage candidate_list in\n      let rest := max_after_remove_aux (x :: prefix_rev) xs in\n      max_nat cand rest\n  end.",
                "code": "max_after_remove_aux [] intervals",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* At least one interval is provided *)\n  intervals <> []",
                "postcond_aux": "(* A helper relation capturing the list obtained by removing exactly one element\n   (preserving order) from the original list. *)\nDefinition removed_one (xs ys : list (nat * nat)) : Prop :=\n  exists l1 x l2, xs = l1 ++ x :: l2 /\\ ys = l1 ++ l2.\n\n(* The \"span\" of a list of intervals, defined as:\n   - 0 for the empty list;\n   - Otherwise, max over right endpoints minus min over left endpoints.\n   This models the convex hull span of the remaining intervals. *)\nDefinition list_span (ys : list (nat * nat)) (v : nat) : Prop :=\n  (ys = [] /\\ v = 0) \\/\n  (ys <> [] /\\\n   exists (m R : nat),\n     (* m is the minimal left endpoint present in ys *)\n     (exists p, In p ys /\\ m = fst p /\\ (forall q, In q ys -> m <= fst q)) /\\\n     (* R is the maximal right endpoint present in ys *)\n     (exists p, In p ys /\\ R = snd p /\\ (forall q, In q ys -> snd q <= R)) /\\\n     (* span equals R - m (natural subtraction) *)\n     v = R - m).",
                "postcond": "(* result is the maximum span achievable by removing exactly one interval *)\n  exists ys,\n    removed_one intervals ys /\\\n    list_span ys result /\\\n    (forall ys' v',\n        removed_one intervals ys' ->\n        list_span ys' v' ->\n        v' <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_38": {
          "data_id": "verina_basic_38",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean equality on ascii characters, defined by comparing all 8 bits *)\nDefinition ascii_beq (a b : ascii) : bool :=\n  match a, b with\n  | Ascii.Ascii a1 a2 a3 a4 a5 a6 a7 a8,\n    Ascii.Ascii b1 b2 b3 b4 b5 b6 b7 b8 =>\n      andb (Bool.eqb a1 b1)\n        (andb (Bool.eqb a2 b2)\n        (andb (Bool.eqb a3 b3)\n        (andb (Bool.eqb a4 b4)\n        (andb (Bool.eqb a5 b5)\n        (andb (Bool.eqb a6 b6)\n        (andb (Bool.eqb a7 b7)\n              (Bool.eqb a8 b8)))))))\n  end.\n\n(* Check that all characters in the string are equal to the given character *)\nFixpoint all_eq_char (c : ascii) (s : string) : bool :=\n  match s with\n  | EmptyString => true\n  | String c' s' => andb (ascii_beq c c') (all_eq_char c s')\n  end.",
                "code": "(* An empty or single-character string trivially has all characters identical *)\n  match s with\n  | EmptyString => true\n  | String c s' => all_eq_char c s'\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Fixpoint all_eq_char (c : ascii) (s : string) : Prop :=\n  match s with\n  | EmptyString => True\n  | String d s' => c = d /\\ all_eq_char c s'\n  end.\n\nDefinition all_chars_same (s : string) : Prop :=\n  match s with\n  | EmptyString => True\n  | String c s' => all_eq_char c s'\n  end.",
                "postcond": "(result = true <-> all_chars_same s) /\\ (result = false <-> ~ all_chars_same s)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_39": {
          "data_id": "verina_basic_39",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Move the last element of a list to the front, returning also the remaining \"init\" list *)\nFixpoint last_init (l : list Z) : option (Z * list Z) :=\n  match l with\n  | [] => None\n  | [x] => Some (x, [])\n  | x :: xs =>\n      match last_init xs with\n      | Some (last, init) => Some (last, x :: init)\n      | None => None (* unreachable due to the previous patterns *)\n      end\n  end.\n\n(* Single-step right rotation: for [], return []; otherwise move last element to front *)\nDefinition rot_right1 (l : list Z) : list Z :=\n  match last_init l with\n  | None => l\n  | Some (last, init) => last :: init\n  end.\n\n(* Rotate right by k positions by iterating single-step rotation k times *)\nFixpoint rotate_by (k : nat) (l : list Z) : list Z :=\n  match k with\n  | O => l\n  | S k' => rotate_by k' (rot_right1 l)\n  end.",
                "code": "(* Rotate the list to the right by n positions.\n     If the list is empty, repeated rotations keep it unchanged. *)\n  rotate_by n l",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* If the list is empty, the result must be the same list. *)\n  (length l = 0%nat /\\ result = l)\n  \\/\n  (* Otherwise, result is l rotated right by n positions:\n     there exist pre and suf such that l = pre ++ suf and\n     result = suf ++ pre, where the size of suf is the remainder\n     of n upon division by length l. *)\n  (exists (pre suf : list Z) (q : nat),\n      l = pre ++ suf /\\\n      result = suf ++ pre /\\\n      length suf < length l /\\\n      n = (q * length l + length suf)%nat)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_39": {
          "data_id": "verina_advanced_39",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function to compute the maximum of two natural numbers *)\nFixpoint max2 (a b : nat) : nat :=\n  if Nat.leb a b then b else a.\n\n(* Recursive function to compute the maximum of a list of natural numbers.\n   For the empty list, we return 0 (this case won't occur due to the precondition). *)\nFixpoint maxlist (l : list nat) : nat :=\n  match l with\n  | nil => 0\n  | x :: xs => max2 x (maxlist xs)\n  end.",
                "code": "maxlist lst",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "lst <> []",
                "postcond_aux": "",
                "postcond": "List.In result lst /\\\n  (forall y, List.In y lst -> y <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_40": {
          "data_id": "verina_basic_40",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function that, given the current smallest value 'a', an optional current\n   second-smallest value 'b', and the remaining list 'l', scans the list to find\n   the second-smallest value strictly greater than 'a'. *)\nFixpoint second_smallest_iter (a : Z) (b : option Z) (l : list Z) : option Z :=\n  match l with\n  | nil => b\n  | x :: xs =>\n      if Z.ltb x a then\n        (* Found a new smallest; the previous smallest 'a' becomes the new candidate second-smallest *)\n        second_smallest_iter x (Some a) xs\n      else if Z.eqb x a then\n        (* Equal to current smallest; ignore *)\n        second_smallest_iter a b xs\n      else\n        (* x > a: candidate for second-smallest *)\n        match b with\n        | None => second_smallest_iter a (Some x) xs\n        | Some bval =>\n            if Z.ltb x bval then\n              second_smallest_iter a (Some x) xs\n            else\n              second_smallest_iter a (Some bval) xs\n        end\n  end.",
                "code": "(* We handle general cases; under the precondition, the list has at least two elements\n     and at least two distinct values, so the final option will be Some. *)\n  match s with\n  | nil => 0 (* Should not occur under the precondition *)\n  | x :: xs =>\n      match second_smallest_iter x None xs with\n      | Some b => b\n      | None => x (* Should not occur due to the precondition ensuring a distinct second-smallest *)\n      end\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* At least two elements and at least two distinct values in the list *)\n  (exists x y l, s = x :: y :: l) /\\\n  (exists u v, List.In u s /\\ List.In v s /\\ u <> v)",
                "postcond_aux": "",
                "postcond": "(* result is the second-smallest value in s:\n     - there exists a minimum m in s\n     - result is strictly greater than m and is in s\n     - among all elements strictly greater than m, result is the least *)\n  List.In result s /\\\n  exists m,\n    List.In m s /\\\n    (forall x, List.In x s -> m <= x) /\\\n    m < result /\\\n    (forall x, List.In x s -> m < x -> result <= x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_40": {
          "data_id": "verina_advanced_40",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean less-than-or-equal for nat *)\nFixpoint leb_nat (n m : nat) : bool :=\n  match n, m with\n  | O, _ => true\n  | S _, O => false\n  | S n', S m' => leb_nat n' m'\n  end.\n\n(* Tail-recursive helper to compute the maximum with an accumulator *)\nFixpoint max_list_aux (acc : nat) (lst : list nat) : nat :=\n  match lst with\n  | [] => acc\n  | x :: xs =>\n      let acc' := if leb_nat acc x then x else acc in\n      max_list_aux acc' xs\n  end.",
                "code": "(* Since the list is non-empty by precondition, we seed the accumulator with the head.\n     For completeness, we return 0 on [] (unused under the precondition). *)\n  match lst with\n  | [] => 0\n  | x :: xs => max_list_aux x xs\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* The list must be non-empty *)\n  lst <> []",
                "postcond_aux": "",
                "postcond": "(* result is a maximum element of the non-empty list lst *)\n  List.In result lst /\\\n  (forall y : nat, List.In y lst -> y <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_41": {
          "data_id": "verina_basic_41",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: checks if all elements in the list are equal to a given value x *)\nFixpoint all_eq (x : Z) (l : list Z) : bool :=\n  match l with\n  | nil => true\n  | y :: ys => if Z.eqb y x then all_eq x ys else false\n  end.",
                "code": "(* Return true for empty list; otherwise, ensure all elements equal the head *)\n  match a with\n  | nil => true\n  | x :: xs => all_eq x xs\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true <-> (forall x y, List.In x a -> List.In y a -> x = y))\n  /\\\n  (result = false <-> exists x y, List.In x a /\\ List.In y a /\\ x <> y)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_41": {
          "data_id": "verina_advanced_41",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function to compute the maximum of two integers using Z.leb *)\nDefinition max2 (x y : Z) : Z :=\n  match Z.leb x y with\n  | true => y\n  | false => x\n  end.",
                "code": "(* Compute the maximum by combining pairwise maxima *)\n  let bc := max2 b c in\n  max2 a bc",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(a <= result /\\ b <= result /\\ c <= result) /\\ (result = a \\/ result = b \\/ result = c)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_42": {
          "data_id": "verina_advanced_42",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper recursive function that traverses the list once, keeping track of:\n   - min_so_far: the minimum price seen so far\n   - maxp: the maximum profit found so far *)\nFixpoint maxProfit_loop (l : list nat) (min_so_far : nat) (maxp : nat) : nat :=\n  match l with\n  | [] => maxp\n  | x :: xs =>\n      let min' := Nat.min min_so_far x in\n      let profit := x - min_so_far in\n      let maxp' := Nat.max maxp profit in\n      maxProfit_loop xs min' maxp'\n  end.",
                "code": "match prices with\n  | [] => 0\n  | p :: ps => maxProfit_loop ps p 0\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* result is the least upper bound (maximum) of all achievable profits pj - pi with i < j.\n     Profit is computed with Nat.sub, yielding 0 when pj <= pi (no loss allowed).\n     When there are no valid pairs, the second clause forces result = 0. *)\n  (forall i j pi pj,\n      i < j ->\n      nth_error prices i = Some pi ->\n      nth_error prices j = Some pj ->\n      Nat.sub pj pi <= result)\n  /\\\n  (forall r,\n      (forall i j pi pj,\n          i < j ->\n          nth_error prices i = Some pi ->\n          nth_error prices j = Some pj ->\n          Nat.sub pj pi <= r) ->\n      result <= r)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_42": {
          "data_id": "verina_basic_42",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to check if an ascii character is a decimal digit '0'..'9' *)\nDefinition is_digit_ascii (c : ascii) : bool :=\n  let n := Ascii.nat_of_ascii c in\n  andb (Nat.leb 48 n) (Nat.leb n 57).\n\n(* Recursive helper to count digits in a string *)\nFixpoint countDigits_aux (s : string) : nat :=\n  match s with\n  | EmptyString => 0\n  | String c s' =>\n      if is_digit_ascii c\n      then S (countDigits_aux s')\n      else countDigits_aux s'\n  end.",
                "code": "countDigits_aux s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Predicate: an ascii character is a decimal digit '0'..'9' *)\nDefinition is_digit_char (c : ascii) : Prop :=\n  let n := nat_of_ascii c in 48 <= n /\\ n <= 57.\n\n(* Relational specification counting the number of digit characters in a string *)\nInductive count_digits_rel : string -> nat -> Prop :=\n| cdr_nil :\n    count_digits_rel EmptyString 0\n| cdr_cons_digit :\n    forall (c : ascii) (s : string) (n : nat),\n      is_digit_char c ->\n      count_digits_rel s n ->\n      count_digits_rel (String c s) (S n)\n| cdr_cons_nondigit :\n    forall (c : ascii) (s : string) (n : nat),\n      ~ is_digit_char c ->\n      count_digits_rel s n ->\n      count_digits_rel (String c s) n.",
                "postcond": "(* The result must be exactly the number of digit characters in s *)\n  count_digits_rel s result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_43": {
          "data_id": "verina_basic_43",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Recursive helper computing the sum of fourth powers of the first n odd naturals *)\nFixpoint sumOddFourth (n : nat) : nat :=\n  match n with\n  | O => 0\n  | S k =>\n      sumOddFourth k + Nat.pow (2 * (S k) - 1) 4\n  end.",
                "code": "sumOddFourth n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Auxiliary function: sum of the fourth powers of the first n odd natural numbers.\n   This computes sum_{k=0}^{n-1} (2*k + 1)^4. *)\nFixpoint sum_pow4_first_n_odds (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S k => sum_pow4_first_n_odds k + Nat.pow (2 * k + 1) 4\n  end.",
                "postcond": "result = sum_pow4_first_n_odds n",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_43": {
          "data_id": "verina_advanced_43",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Product of a list of integers; neutral element is 1 *)\nFixpoint prod_list (l : list Z) : Z :=\n  match l with\n  | [] => 1\n  | x :: xs => x * prod_list xs\n  end.\n\n(* Check whether a list has odd length *)\nFixpoint odd_length_Z (l : list Z) : bool :=\n  match l with\n  | [] => false\n  | _ :: xs => negb (odd_length_Z xs)\n  end.\n\n(* Remove the first occurrence of an element from a list *)\nFixpoint remove_first (a : Z) (l : list Z) : list Z :=\n  match l with\n  | [] => []\n  | x :: xs => if Z.eqb x a then xs else x :: remove_first a xs\n  end.\n\n(* Find the element with minimal absolute value in a list (if any) *)\nFixpoint min_abs_Z_opt (l : list Z) : option Z :=\n  match l with\n  | [] => None\n  | x :: xs =>\n      match min_abs_Z_opt xs with\n      | None => Some x\n      | Some m => if Z.leb (Z.abs x) (Z.abs m) then Some x else Some m\n      end\n  end.\n\n(* Drop one element having the minimal absolute value (used on negatives when count is odd) *)\nDefinition drop_min_abs_one (l : list Z) : list Z :=\n  match min_abs_Z_opt l with\n  | None => []\n  | Some m => remove_first m l\n  end.\n\n(* Boolean: list non-empty *)\nDefinition nonempty (l : list Z) : bool :=\n  match l with\n  | [] => false\n  | _ => true\n  end.\n\n(* Boolean: list has at least two elements *)\nDefinition at_least_two (l : list Z) : bool :=\n  match l with\n  | _ :: _ :: _ => true\n  | _ => false\n  end.",
                "code": "(* Partition the input into positives, negatives, and zeros *)\n  let pos := List.filter (fun z => Z.gtb z 0) nums in\n  let neg := List.filter (fun z => Z.ltb z 0) nums in\n  let zeros := List.filter (fun z => Z.eqb z 0) nums in\n\n  let hasPos := nonempty pos in\n  let hasTwoNeg := at_least_two neg in\n\n  (* If we have any positive or at least two negatives, we can form a non-empty product\n     that is maximal by using all positives and an even number of negatives (drop the\n     negative with smallest |value| if the count is odd). *)\n  if orb hasPos hasTwoNeg then\n    let neg' := if odd_length_Z neg then drop_min_abs_one neg else neg in\n    prod_list (pos ++ neg')\n  else\n    (* Otherwise, there are no positives and fewer than two negatives.\n       - If there is at least one zero, the best we can do is pick 0.\n       - Else, there is exactly one negative: we must pick it. *)\n    match zeros with\n    | [] =>\n        match neg with\n        | [] => 0 (* Shouldn't occur if nums is non-empty, but safe fallback *)\n        | x :: _ => x\n        end\n    | _ :: _ => 0\n    end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "nums <> []",
                "postcond_aux": "(* Product of elements in nums selected by the corresponding boolean mask.\n   Requires masks of the same length for meaningful interpretation. *)\nFixpoint prod_mask (mask : list bool) (nums : list Z) : Z :=\n  match mask, nums with\n  | b :: ms, x :: xs => (if b then x else 1) * prod_mask ms xs\n  | _, _ => 1\n  end.\n\n(* Mask well-formedness w.r.t. nums. *)\nDefinition valid_mask (mask : list bool) (nums : list Z) : Prop :=\n  length mask = length nums.\n\n(* At least one element is selected by the mask. *)\nDefinition nonempty_sel (mask : list bool) : Prop :=\n  In true mask.",
                "postcond": "exists mask : list bool,\n    valid_mask mask nums /\\\n    nonempty_sel mask /\\\n    result = prod_mask mask nums /\\\n    (forall mask',\n        valid_mask mask' nums ->\n        nonempty_sel mask' ->\n        prod_mask mask' nums <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_44": {
          "data_id": "verina_advanced_44",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_44",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to update an optional maximum with a new candidate value *)\nDefinition opt_max (o : option Z) (v : Z) : option Z :=\n  match o with\n  | None => Some v\n  | Some b => Some (Z.max b v)\n  end.\n\n(* Inner loop: for a fixed start index, scan forward accumulating sums and\n   updating the best sum whenever the current length is a multiple of k. \n   We avoid Z modulo by maintaining the remainder (in nat) of the current\n   subarray length modulo k (k as nat). *)\nFixpoint inner_max_k (l : list Z) (k_nat rem : nat) (sum_acc : Z) (best : option Z) : option Z :=\n  match l with\n  | [] => best\n  | x :: xs =>\n      let sum' := sum_acc + x in\n      let rem_plus_one := rem + 1 in\n      let rem' := if Nat.eqb rem_plus_one k_nat then 0 else rem_plus_one in\n      (* Only consider multiples when k_nat > 0; by precondition k > 1, so k_nat >= 2 *)\n      let best' :=\n        if Nat.eqb k_nat 0 then best\n        else if Nat.eqb rem' 0 then opt_max best sum' else best in\n      inner_max_k xs k_nat rem' sum' best'\n  end.\n\n(* Outer loop: iterate over all start positions, threading the global best. *)\nFixpoint outer_max_k (l : list Z) (k_nat : nat) (best : option Z) : option Z :=\n  match l with\n  | [] => best\n  | _ :: xs =>\n      let best' := inner_max_k l k_nat 0 0 best in\n      outer_max_k xs k_nat best'\n  end.",
                "code": "(* Convert k to nat for remainder tracking; precondition ensures k > 1, so k_nat >= 2 *)\n  let k_nat := Z.to_nat k in\n  let res := outer_max_k arr k_nat None in\n  match res with\n  | None => 0\n  | Some m => m\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_44",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "1 < k",
                "postcond_aux": "(* Sum of a list of integers *)\nFixpoint sum_list (l : list Z) : Z :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum_list xs\n  end.\n\n(* Contiguous subarray starting at index i of length len *)\nDefinition subarray (arr : list Z) (i len : nat) : list Z :=\n  firstn len (skipn i arr).\n\n(* A valid subarray has positive length, fits within arr, and its length is divisible by k *)\nDefinition valid_subarray (arr : list Z) (k : Z) (i len : nat) : Prop :=\n  Nat.lt 0 len /\\\n  i + len <= length arr /\\\n  (Z.of_nat len mod k = 0).",
                "postcond": "(* result is the maximum positive sum over all valid subarrays, defaulting to 0 *)\n  0 <= result /\\\n  (forall (i len : nat),\n      valid_subarray arr k i len ->\n      0 < sum_list (subarray arr i len) ->\n      sum_list (subarray arr i len) <= result) /\\\n  (0 < result ->\n      exists (i len : nat),\n        valid_subarray arr k i len /\\\n        sum_list (subarray arr i len) = result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_45": {
          "data_id": "verina_advanced_45",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function implementing Kadane's algorithm.\n   It traverses the list once, maintaining:\n   - curr: the maximum subarray sum ending at the current position\n   - best: the maximum subarray sum seen so far *)\nFixpoint kadane_aux (xs : list Z) (curr : Z) (best : Z) : Z :=\n  match xs with\n  | nil => best\n  | y :: ys =>\n      let curr' := Z.max y (curr + y) in\n      let best' := Z.max best curr' in\n      kadane_aux ys curr' best'\n  end.",
                "code": "(* If the list is empty, the maximum subarray sum is 0. *)\n  match xs with\n  | nil => 0\n  | x :: xs' =>\n      (* Initialize with the first element, then process the rest. *)\n      kadane_aux xs' x x\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Fixpoint sumZ (l : list Z) : Z :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sumZ xs\n  end.\n\nDefinition is_segment (mid xs : list Z) : Prop :=\n  exists l r, xs = l ++ mid ++ r.",
                "postcond": "(xs = [] /\\ result = 0) \\/\n  (xs <> [] /\\\n   (exists mid l r, xs = l ++ mid ++ r /\\ mid <> [] /\\ result = sumZ mid) /\\\n   (forall mid l r, xs = l ++ mid ++ r -> mid <> [] -> Z.le (sumZ mid) result))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_45": {
          "data_id": "verina_basic_45",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Find the first even number in a list *)\nFixpoint find_first_even (l : list Z) : option Z :=\n  match l with\n  | nil => None\n  | x :: xs =>\n      match Z.even x with\n      | true => Some x\n      | false => find_first_even xs\n      end\n  end.\n\n(* Find the first odd number in a list *)\nFixpoint find_first_odd (l : list Z) : option Z :=\n  match l with\n  | nil => None\n  | x :: xs =>\n      match Z.odd x with\n      | true => Some x\n      | false => find_first_odd xs\n      end\n  end.",
                "code": "(* Using the precondition that there exists at least one even and one odd element *)\n  let fe := find_first_even lst in\n  let fo := find_first_odd lst in\n  match fe, fo with\n  | Some e, Some o => e * o\n  | _, _ => 0 (* Impossible under the given precondition; safe fallback *)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* The list contains at least one even and at least one odd element *)\n  (exists e, List.In e lst /\\ Z.even e = true) /\\\n  (exists o, List.In o lst /\\ Z.odd o = true)",
                "postcond_aux": "",
                "postcond": "(* result is the product of the first even and the first odd in the list *)\n  exists lbe lae e lbo lao o,\n    lst = lbe ++ e :: lae /\\\n    Z.even e = true /\\\n    (forall y, List.In y lbe -> Z.even y = false) /\\\n    lst = lbo ++ o :: lao /\\\n    Z.odd o = true /\\\n    (forall y, List.In y lbo -> Z.odd y = false) /\\\n    result = e * o",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_46": {
          "data_id": "verina_basic_46",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function:\n   - elem: the element to search for\n   - l: the remaining list to scan\n   - i: current index in Z\n   - last_found: last index (in Z) where elem was seen, or -1 if not seen yet\n   Recurses on the list l (decreasing argument). *)\nFixpoint last_pos_aux (elem : Z) (l : list Z) (i : Z) (last_found : Z) {struct l} : Z :=\n  match l with\n  | nil => last_found\n  | x :: xs =>\n      let last_found' := if Z.eqb x elem then i else last_found in\n      last_pos_aux elem xs (i + 1) last_found'\n  end.",
                "code": "(* Start scanning from index 0 with no occurrence yet (-1). *)\n  last_pos_aux elem arr 0 (-1)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* result = -1 iff elem does not occur in arr; otherwise, result is the last index where elem occurs *)\n  (result = -1 <-> ~ List.In elem arr) /\\\n  (result <> -1 ->\n     0 <= result /\\\n     result < Z.of_nat (List.length arr) /\\\n     List.nth (Z.to_nat result) arr 0 = elem /\\\n     (forall j : Z,\n        result < j ->\n        j < Z.of_nat (List.length arr) ->\n        List.nth (Z.to_nat j) arr 0 <> elem))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_46": {
          "data_id": "verina_advanced_46",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function implementing Kadane's algorithm.\n   It traverses the list once, maintaining:\n   - curr: the current running sum, clamped at 0\n   - best: the best (maximum) sum seen so far\n   If all numbers are negative, best remains 0. *)\nFixpoint kadane_aux (l : list Z) (curr best : Z) {struct l} : Z :=\n  match l with\n  | nil => best\n  | x :: xs =>\n      let curr' := Z.max 0 (curr + x) in\n      let best' := Z.max best curr' in\n      kadane_aux xs curr' best'\n  end.",
                "code": "(* Initialize running sum and best sum to 0, ensuring result is 0 for empty or all-negative lists *)\n  kadane_aux numbers 0 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* result is the maximum sum over all non-empty contiguous subarrays,\n     but at least 0 (empty subarray) when all such sums are non-positive. *)\n  0 <= result /\\\n  (* Upper bound: every non-empty contiguous subarray sum is <= result *)\n  (forall (i j : nat),\n     i < j /\\ j <= length numbers ->\n     List.fold_right Z.add 0 (firstn (j - i) (skipn i numbers)) <= result) /\\\n  (* Maximality/completeness:\n     either some non-empty contiguous subarray attains result,\n     or all non-empty contiguous subarray sums are <= 0 and result = 0. *)\n  ( (exists (i j : nat),\n       i < j /\\ j <= length numbers /\\\n       List.fold_right Z.add 0 (firstn (j - i) (skipn i numbers)) = result)\n    \\/\n    (result = 0 /\\\n     forall (i j : nat),\n       i < j /\\ j <= length numbers ->\n       List.fold_right Z.add 0 (firstn (j - i) (skipn i numbers)) <= 0) )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_47": {
          "data_id": "verina_basic_47",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function to compute the sum of a list of integers *)\nFixpoint sum_list (l : list Z) : Z :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum_list xs\n  end.",
                "code": "sum_list a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = List.fold_left Z.add a 0",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_47": {
          "data_id": "verina_advanced_47",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to extract first and second components of an interval *)\nDefinition fstZ (p : Z * Z) : Z :=\n  match p with\n  | (a, _) => a\n  end.\n\nDefinition sndZ (p : Z * Z) : Z :=\n  match p with\n  | (_, b) => b\n  end.\n\n(* Boolean max for Z *)\nDefinition maxZ (a b : Z) : Z :=\n  if Z.leb a b then b else a.\n\n(* Compare intervals by their start (first component) *)\nDefinition leStart (x y : Z * Z) : bool :=\n  Z.leb (fstZ x) (fstZ y).\n\n(* Insertion into a sorted list by start *)\nFixpoint insert_by_start (x : Z * Z) (l : list (Z * Z)) : list (Z * Z) :=\n  match l with\n  | [] => [x]\n  | y :: ys =>\n      if leStart x y\n      then x :: l\n      else y :: insert_by_start x ys\n  end.\n\n(* Insertion sort by start of intervals *)\nFixpoint sort_by_start (l : list (Z * Z)) : list (Z * Z) :=\n  match l with\n  | [] => []\n  | x :: xs => insert_by_start x (sort_by_start xs)\n  end.\n\n(* Merge a sorted list of intervals using an accumulator (stack), then reverse at the end *)\nFixpoint merge_sorted_aux (acc : list (Z * Z)) (l : list (Z * Z)) : list (Z * Z) :=\n  match l with\n  | [] => rev acc\n  | (s, e) :: xs =>\n      match acc with\n      | [] => merge_sorted_aux [(s, e)] xs\n      | (s1, e1) :: acc' =>\n          (* Intervals overlap if current start <= last end *)\n          if Z.leb s e1\n          then\n            let e' := maxZ e1 e in\n            merge_sorted_aux ((s1, e') :: acc') xs\n          else\n            merge_sorted_aux ((s, e) :: (s1, e1) :: acc') xs\n      end\n  end.",
                "code": "let sorted := sort_by_start intervals in\n  merge_sorted_aux [] sorted",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Pointwise membership of a Z in a closed interval (s, e). *)\nDefinition in_interval (p : Z * Z) (x : Z) : Prop :=\n  let '(s, e) := p in s <= x /\\ x <= e.\n\n(* Coverage of a point x by a list of intervals. *)\nDefinition covered_by (l : list (Z * Z)) (x : Z) : Prop :=\n  exists p, List.In p l /\\ in_interval p x.\n\n(* Sorted-by-start and pairwise non-overlapping (strict) for consecutive intervals. *)\nFixpoint sorted_disjoint (l : list (Z * Z)) : Prop :=\n  match l with\n  | [] => True\n  | _ :: [] => True\n  | (s1, e1) :: (s2, e2) :: tl =>\n      s1 <= s2 /\\ e1 < s2 /\\ sorted_disjoint ((s2, e2) :: tl)\n  end.",
                "postcond": "(* The result is a list of non-overlapping intervals sorted by start,\n     and it has exactly the same coverage (as sets of integers) as the input. *)\n  sorted_disjoint result /\\\n  (forall x : Z, covered_by intervals x <-> covered_by result x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_48": {
          "data_id": "verina_basic_48",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to check if there exists k <= limit such that k*k = n *)\nFixpoint has_square_le (n limit : nat) : bool :=\n  match limit with\n  | 0 => Nat.eqb 0 n\n  | S l' =>\n      if Nat.eqb ((S l') * (S l')) n\n      then true\n      else has_square_le n l'\n  end.",
                "code": "(* Check if n is a perfect square by searching k from n down to 0 *)\n  has_square_le n n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true <-> exists k : nat, k * k = n) /\\\n  (result = false <-> ~(exists k : nat, k * k = n))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_48": {
          "data_id": "verina_advanced_48",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Merge two sorted lists of integers in ascending order *)\nFixpoint merge (l1 l2 : list Z) : list Z :=\n  match l1, l2 with\n  | [], _ => l2\n  | _, [] => l1\n  | x :: xs, y :: ys =>\n      if Z.leb x y\n      then x :: merge xs (y :: ys)\n      else y :: merge (x :: xs) ys\n  end.\n\n(* Split a list into two lists by alternating elements *)\nFixpoint split_alt (l : list Z) : list Z * list Z :=\n  match l with\n  | [] => ([], [])\n  | [x] => ([x], [])\n  | x :: y :: t =>\n      let '(l1, l2) := split_alt t in\n      (x :: l1, y :: l2)\n  end.\n\n(* Auxiliary mergesort with a decreasing measure on n to ensure termination *)\nFixpoint mergeSortAux (n : nat) (lst : list Z) {struct n} : list Z :=\n  match n with\n  | O => lst\n  | S n' =>\n      match lst with\n      | [] => []\n      | [x] => [x]\n      | _ =>\n          let '(l1, l2) := split_alt lst in\n          let s1 := mergeSortAux n' l1 in\n          let s2 := mergeSortAux n' l2 in\n          merge s1 s2\n      end\n  end.",
                "code": "mergeSortAux (length lst) lst",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Count occurrences of an element in a list (for permutation as multiset equality) *)\nFixpoint occ (x : Z) (l : list Z) : nat :=\n  match l with\n  | [] => 0\n  | y :: ys => if Z.eqb x y then S (occ x ys) else occ x ys\n  end.\n\n(* Ascending sortedness: every adjacent pair is nondecreasing *)\nInductive sorted : list Z -> Prop :=\n| sorted_nil : sorted []\n| sorted_single : forall x, sorted [x]\n| sorted_cons : forall x y l, x <= y -> sorted (y :: l) -> sorted (x :: y :: l).",
                "postcond": "(* Correctness of merge sort:\n     - result is sorted in nondecreasing order\n     - result is a permutation (same multiset of elements) of the input *)\n  sorted result /\\ (forall z : Z, occ z result = occ z lst)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_49": {
          "data_id": "verina_basic_49",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to test if a Z integer is odd using modulo *)\nDefinition is_oddZ (z : Z) : bool :=\n  Z.eqb (Z.modulo z 2) 1.\n\n(* Recursive auxiliary function to find the first odd element's index *)\nFixpoint find_first_odd_aux (l : list Z) (i : nat) : option nat :=\n  match l with\n  | nil => None\n  | x :: xs =>\n      if is_oddZ x\n      then Some i\n      else find_first_odd_aux xs (S i)\n  end.",
                "code": "(* Start searching from index 0 *)\n  find_first_odd_aux a 0%nat",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "match result with\n  | None =>\n      (* No odd numbers exist in the array *)\n      forall j z, List.nth_error a j = Some z -> Z.odd z = false\n  | Some i =>\n      (* i is the smallest index with an odd number *)\n      exists z,\n        List.nth_error a i = Some z /\\ Z.odd z = true /\\\n        (forall j y, j < i -> List.nth_error a j = Some y -> Z.odd y = false)\n  end",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_49": {
          "data_id": "verina_advanced_49",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: merges two sorted lists using a fuel parameter to ensure termination.\n   The fuel starts as the total length of both lists and decreases on each recursive step\n   where we consume one element. *)\nFixpoint merge_with_fuel (fuel : nat) (l1 l2 : list Z) : list Z :=\n  match fuel with\n  | O => (* Should not happen if called with length l1 + length l2; fallback to concatenation *)\n         l1 ++ l2\n  | S fuel' =>\n      match l1, l2 with\n      | [], _ => l2\n      | _, [] => l1\n      | x :: xs, y :: ys =>\n          if Z.leb x y\n          then x :: merge_with_fuel fuel' xs (y :: ys)\n          else y :: merge_with_fuel fuel' (x :: xs) ys\n      end\n  end.",
                "code": "let fuel := (length arr1 + length arr2)%nat in\n  merge_with_fuel fuel arr1 arr2",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* A simple nondecreasing (ascending) sortedness predicate based on adjacent comparisons *)\nFixpoint sorted (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: xs => x <= y /\\ sorted (y :: xs)\n  end.\n\n(* Multiplicity count of an element in a list *)\nFixpoint count (x : Z) (l : list Z) : nat :=\n  match l with\n  | [] => 0\n  | y :: ys => if Z.eqb x y then S (count x ys) else count x ys\n  end.",
                "postcond": "(* The result is ascendingly sorted and its multiset of elements equals\n     the disjoint union (by multiplicity) of arr1 and arr2. *)\n  sorted result /\\\n  forall z : Z, count z result = count z arr1 + count z arr2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_50": {
          "data_id": "verina_basic_50",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Return the absolute value of x: if x < 0 then -x else x *)\n  if Z.ltb x 0 then - x else x",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "((0 <= x /\\ result = x) \\/ (x < 0 /\\ result = - x)) /\\ 0 <= result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_50": {
          "data_id": "verina_advanced_50",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Simple comparison type for natural numbers *)\nInductive nat_cmp := LT | EQ | GT.\n\n(* Structural comparison of natural numbers *)\nFixpoint nat_compare (n m : nat) : nat_cmp :=\n  match n, m with\n  | O, O => EQ\n  | O, S _ => LT\n  | S _, O => GT\n  | S n', S m' => nat_compare n' m'\n  end.\n\n(* Remove consecutive duplicates from a (supposedly) sorted list *)\nFixpoint dedup_sorted (l : list nat) : list nat :=\n  match l with\n  | [] => []\n  | [x] => [x]\n  | x :: y :: xs =>\n      match nat_compare x y with\n      | EQ => dedup_sorted (y :: xs)\n      | _  => x :: dedup_sorted (y :: xs)\n      end\n  end.\n\n(* Insert an element into a sorted list without introducing duplicates *)\nFixpoint insert_unique (x : nat) (l : list nat) : list nat :=\n  match l with\n  | [] => [x]\n  | y :: ys =>\n      match nat_compare x y with\n      | EQ => l                 (* x already present, do not insert *)\n      | LT => x :: l            (* x belongs before y *)\n      | GT => y :: insert_unique x ys  (* continue searching *)\n      end\n  end.\n\n(* Build the union by inserting each element of l1 into l2 *)\nFixpoint union_with (l1 l2 : list nat) : list nat :=\n  match l1 with\n  | [] => l2\n  | x :: xs => union_with xs (insert_unique x l2)\n  end.",
                "code": "(* Merge as a set-union of two sorted lists:\n     - First deduplicate the second list\n     - Then insert each element from the first list uniquely into it *)\n  union_with a1 (dedup_sorted a2)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "(* A standard non-decreasing sortedness predicate for lists of nat *)\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | [] => True\n  | x :: xs => Forall (fun y => x <= y) xs /\\ sorted xs\n  end.",
                "precond": "(* Inputs must be sorted (non-decreasing) for the merge to be well-defined. *)\n  sorted a1 /\\ sorted a2",
                "postcond_aux": "",
                "postcond": "(* Result is sorted, contains no duplicates, and its elements are exactly the\n     union of elements from a1 and a2. *)\n  sorted result /\\\n  NoDup result /\\\n  (forall x, In x result <-> In x a1 \\/ In x a2)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_51": {
          "data_id": "verina_advanced_51",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Auxiliary fuel-based merge to ensure structural recursion termination *)\nFixpoint merge_fuel (n : nat) (l1 l2 : list Z) : list Z :=\n  match n with\n  | O => l1 ++ l2 (* fallback; should not occur when called with sufficient fuel *)\n  | S n' =>\n    match l1, l2 with\n    | nil, _ => l2\n    | _, nil => l1\n    | x :: xs, y :: ys =>\n        if Z.leb x y\n        then x :: merge_fuel n' xs l2\n        else y :: merge_fuel n' l1 ys\n    end\n  end.",
                "code": "(* Call the fuel-based merge with enough fuel: total length of both lists *)\n  merge_fuel (length a + length b) a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "(* Non-decreasing sortedness for lists of integers (Z) *)\nFixpoint sorted_nondec (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: xs => x <= y /\\ sorted_nondec (y :: xs)\n  end.\n\n(* Interleaving (merge) predicate: result is formed by taking elements from the heads\n   of a or b, preserving the relative order within each input list. *)\nInductive merge_of : list Z -> list Z -> list Z -> Prop :=\n| merge_nil_l : forall b, merge_of [] b b\n| merge_nil_r : forall a, merge_of a [] a\n| merge_cons_l : forall x xs b r, merge_of xs b r -> merge_of (x :: xs) b (x :: r)\n| merge_cons_r : forall y ys a r, merge_of a ys r -> merge_of a (y :: ys) (y :: r).",
                "precond": "(* Inputs are sorted in non-decreasing order. *)\n  sorted_nondec a /\\ sorted_nondec b",
                "postcond_aux": "",
                "postcond": "(* The result is an interleaving (stable merge) of a and b and is non-decreasingly sorted. *)\n  merge_of a b result /\\ sorted_nondec result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_51": {
          "data_id": "verina_basic_51",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Linear-time lower-bound helper.\n   It returns the first index >= 0 where the element is >= key.\n   If all elements are < key, it returns the length of the list. *)\nFixpoint lower_bound_aux (a : list Z) (key : Z) (idx : nat) : nat :=\n  match a with\n  | nil => idx\n  | x :: xs =>\n      (* If current element is >= key, current index is the insertion point;\n         otherwise continue scanning. *)\n      if Z.geb x key then idx else lower_bound_aux xs key (S idx)\n  end.",
                "code": "(* Start scanning from index 0 *)\n  lower_bound_aux a key 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "Fixpoint sorted_nondecr (l : list Z) : Prop :=\n  match l with\n  | nil => True\n  | x :: nil => True\n  | x :: y :: tl => x <= y /\\ sorted_nondecr (y :: tl)\n  end.",
                "precond": "sorted_nondecr a",
                "postcond_aux": "",
                "postcond": "result <= List.length a /\\\n  (forall i zi, i < result -> List.nth_error a i = Some zi -> zi < key) /\\\n  (forall i zi, result <= i -> List.nth_error a i = Some zi -> key <= zi)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_52": {
          "data_id": "verina_advanced_52",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean equality on nat *)\nFixpoint nat_eqb (n m : nat) : bool :=\n  match n, m with\n  | 0, 0 => true\n  | S n', S m' => nat_eqb n' m'\n  | _, _ => false\n  end.\n\n(* Boolean less-or-equal on nat *)\nFixpoint nat_leb (n m : nat) : bool :=\n  match n, m with\n  | 0, _ => true\n  | S _, 0 => false\n  | S n', S m' => nat_leb n' m'\n  end.\n\n(* Membership test in a list of nat using nat_eqb *)\nFixpoint mem_nat (x : nat) (l : list nat) : bool :=\n  match l with\n  | [] => false\n  | y :: ys => if nat_eqb x y then true else mem_nat x ys\n  end.\n\n(* Safe predecessor *)\nDefinition dec (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S p => p\n  end.\n\n(* Core loop: scan a reversed list, counting removals until all 1..k are collected *)\nFixpoint collect_loop (l : list nat) (k : nat) (missing : nat) (seen : list nat) (ops : nat) : nat :=\n  match l with\n  | [] => ops\n  | x :: xs =>\n      if nat_eqb missing 0 then\n        ops\n      else\n        let ops' := S ops in\n        if nat_leb x k then\n          (* x in [1..k]? Since inputs are positive, x <> 0 suffices to exclude 0. *)\n          if nat_eqb x 0 then\n            collect_loop xs k missing seen ops'\n          else if mem_nat x seen then\n            collect_loop xs k missing seen ops'\n          else\n            collect_loop xs k (dec missing) (x :: seen) ops'\n        else\n          collect_loop xs k missing seen ops'\n  end.",
                "code": "let r := rev nums in\n  collect_loop r k k [] 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* Every integer from 1 to k appears somewhere in nums *)\n  forall i : nat, 1 <= i /\\ i <= k -> List.In i nums",
                "postcond_aux": "",
                "postcond": "(* The last [result] elements (the collected suffix) contain all integers 1..k,\n     and result is minimal with that property. *)\n  result <= List.length nums /\\\n  (forall i : nat, 1 <= i /\\ i <= k ->\n                   List.In i (List.skipn (List.length nums - result) nums)) /\\\n  (forall m : nat, m < result ->\n                   exists i : nat, 1 <= i /\\ i <= k /\\\n                                  ~ List.In i (List.skipn (List.length nums - m) nums))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_52": {
          "data_id": "verina_basic_52",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Perform one bubble pass over the list, bubbling the larger elements to the right *)\nFixpoint bubble_pass (l : list Z) : list Z :=\n  match l with\n  | x :: y :: t =>\n      if Z.leb x y\n      then x :: bubble_pass (y :: t)\n      else y :: bubble_pass (x :: t)\n  | _ => l\n  end.\n\n(* Iterate bubble passes n times *)\nFixpoint iter_bubble (n : nat) (l : list Z) : list Z :=\n  match n with\n  | O => l\n  | S k => iter_bubble k (bubble_pass l)\n  end.\n\n(* Bubble sort defined via iterating bubble passes length(a) times *)\nDefinition bubble_sort (a : list Z) : list Z :=\n  iter_bubble (List.length a) a.",
                "code": "bubble_sort a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* Sorted in non-decreasing order, same length, and same multiset of elements *)\n  length result = length a /\\\n  (forall i j : nat,\n      i < j ->\n      j < length result ->\n      nth i result 0 <= nth j result 0) /\\\n  (forall x : Z, count_occ Z.eq_dec result x = count_occ Z.eq_dec a x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_53": {
          "data_id": "verina_advanced_53",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to get the last element of a list, if any *)\nFixpoint last_of_list (l : list Z) : option Z :=\n  match l with\n  | nil => None\n  | [x] => Some x\n  | _ :: xs => last_of_list xs\n  end.\n\n(* Scan adjacent pairs to count the number of \"drops\" (where a[i] > a[i+1])\n   and record the first index i where the drop occurs. *)\nFixpoint scan_drops (prev : Z) (i : Z) (xs : list Z) : (Z * option Z) :=\n  match xs with\n  | nil => (0%Z, None)\n  | y :: ys =>\n      let res := scan_drops y (i + 1) ys in\n      let cnt_rest := fst res in\n      let idx_rest := snd res in\n      let drop_now := Z.ltb y prev in\n      let cnt := (if drop_now then 1%Z else 0%Z) + cnt_rest in\n      let idx := if drop_now then Some i else idx_rest in\n      (cnt, idx)\n  end.",
                "code": "match nums with\n  | nil => 0%Z\n  | x :: xs =>\n      let res := scan_drops x 0%Z xs in\n      let cnt := fst res in\n      let idxOpt := snd res in\n      let n := Z.of_nat (List.length nums) in\n      if Z.eqb cnt 0%Z then\n        0%Z\n      else if Z.eqb cnt 1%Z then\n        match last_of_list nums with\n        | None => 0%Z (* unreachable for non-empty list *)\n        | Some last =>\n            (* For a rotation of a strictly increasing list, last <= first must hold *)\n            if Z.leb last x then\n              match idxOpt with\n              | Some i => n - (i + 1)%Z\n              | None => (-1)%Z\n              end\n            else (-1)%Z\n        end\n      else\n        (-1)%Z\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Non-decreasing (ascending) order predicate on lists of Z *)\nFixpoint sorted_nondec (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | [_] => True\n  | x :: y :: xs => x <= y /\\ sorted_nondec (y :: xs)\n  end.\n\n(* Helpers for one right shift *)\nFixpoint lastZ (l : list Z) : Z :=\n  match l with\n  | [] => 0%Z (* unreachable in our use, as we branch on [] before calling lastZ *)\n  | [x] => x\n  | _ :: xs => lastZ xs\n  end.\n\nFixpoint remove_last (l : list Z) : list Z :=\n  match l with\n  | [] => []\n  | [_] => []\n  | x :: xs => x :: remove_last xs\n  end.\n\nDefinition rshift1 (l : list Z) : list Z :=\n  match l with\n  | [] => []\n  | _ => (lastZ l) :: (remove_last l)\n  end.\n\n(* k-times right shift *)\nFixpoint rshift (k : nat) (l : list Z) : list Z :=\n  match k with\n  | O => l\n  | S k' => rshift k' (rshift1 l)\n  end.",
                "postcond": "let P := exists k : nat, sorted_nondec (rshift k nums) in\n  (* If sorting by right shifts is possible, result encodes the minimal number of shifts (as a nonnegative Z);\n     otherwise, result is -1. *)\n  (P ->\n    exists r : nat,\n      result = Z.of_nat r /\\\n      sorted_nondec (rshift r nums) /\\\n      (forall k : nat, sorted_nondec (rshift k nums) -> (r <= k)%nat)\n  )\n  /\\\n  (~ P -> result = (-1)%Z)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_53": {
          "data_id": "verina_basic_53",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Recursive helper that sums the first n natural numbers *)\nFixpoint sum_first_n (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S k => S k + sum_first_n k\n  end.",
                "code": "(* Compute the sum recursively using the helper *)\n  sum_first_n N",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = Nat.div (Nat.mul N (Nat.add N 1)) 2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_54": {
          "data_id": "verina_advanced_54",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Sum of natural numbers from 1 to n (0 contributes nothing) *)\nFixpoint sum_upto (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S k => S k + sum_upto k\n  end.\n\n(* Sum of elements in a list of natural numbers *)\nFixpoint sum_list (l : list nat) : nat :=\n  match l with\n  | nil => 0\n  | x :: xs => x + sum_list xs\n  end.",
                "code": "let n := length nums in\n  sum_upto n - sum_list nums",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* If the input satisfies the problem's assumptions (all entries are within [0, length nums]\n     and there are no duplicates), then result is exactly the unique missing number in [0, length nums]. *)\n  (Forall (fun x => x <= length nums) nums /\\ NoDup nums) ->\n  result <= length nums /\\\n  ~ In result nums /\\\n  (forall k, k <= length nums -> (In k nums <-> k <> result))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_54": {
          "data_id": "verina_basic_54",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Minimum on nat without extra imports *)\nFixpoint min_nat (n m : nat) : nat :=\n  match n, m with\n  | O, _ => O\n  | _, O => O\n  | S n', S m' => S (min_nat n' m')\n  end.\n\n(* Absolute difference between two Zs, returned as nat *)\nDefinition abs_diff_nat (x y : Z) : nat :=\n  Z.to_nat (Z.abs (x - y)).\n\n(* Two-pointer traversal with fuel ensuring structural decrease *)\nFixpoint go (fuel : nat) (la lb : list Z) (best : nat) : nat :=\n  match fuel with\n  | O => best\n  | S fuel' =>\n      match la, lb with\n      | x :: xs, y :: ys =>\n          let d := abs_diff_nat x y in\n          let best' := min_nat best d in\n          if Z.eqb x y then\n            0%nat\n          else if Z.leb x y then\n            go fuel' xs (y :: ys) best'\n          else\n            go fuel' (x :: xs) ys best'\n      | _, _ => best\n      end\n  end.",
                "code": "(* Initialize best as the diff of heads if available (precond ensures non-empty) *)\n  let init_best :=\n    match a, b with\n    | x :: _, y :: _ => abs_diff_nat x y\n    | _, _ => 0%nat\n    end in\n  let fuel := Nat.add (length a) (length b) in\n  go fuel a b init_best",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "Fixpoint sorted_nondecr (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | x :: xs => Forall (fun y => x <= y) xs /\\ sorted_nondecr xs\n  end.",
                "precond": "a <> [] /\\ b <> [] /\\ sorted_nondecr a /\\ sorted_nondecr b",
                "postcond_aux": "",
                "postcond": "exists (x : Z) (y : Z),\n    List.In x a /\\ List.In y b /\\\n    (forall (x' y' : Z), List.In x' a -> List.In y' b ->\n      Z.abs (x - y) <= Z.abs (x' - y')) /\\\n    result = Z.to_nat (Z.abs (x - y))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_55": {
          "data_id": "verina_advanced_55",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Increment the count of a given integer in the frequency list *)\nFixpoint inc_count (z : Z) (fs : list (Z * Z)) : list (Z * Z) :=\n  match fs with\n  | [] => [(z, 1)]\n  | (k, c) :: t =>\n      if Z.eqb k z then (k, c + 1) :: t\n      else (k, c) :: inc_count z t\n  end.\n\n(* Build frequency map using a tail-recursive fold over the list *)\nFixpoint build_freq (xs : list Z) (acc : list (Z * Z)) : list (Z * Z) :=\n  match xs with\n  | [] => acc\n  | x :: t => build_freq t (inc_count x acc)\n  end.\n\n(* Find the maximum count in the frequency list *)\nFixpoint max_count (fs : list (Z * Z)) : Z :=\n  match fs with\n  | [] => 0\n  | (_, c) :: t =>\n      let m := max_count t in\n      if Z.leb c m then m else c\n  end.\n\n(* Lookup the count of a given integer in the frequency list *)\nFixpoint lookup_count (z : Z) (fs : list (Z * Z)) : Z :=\n  match fs with\n  | [] => 0\n  | (k, c) :: t =>\n      if Z.eqb k z then c else lookup_count z t\n  end.\n\n(* Find the first element in the list whose count equals the given maximum *)\nFixpoint find_first_with_count (xs : list Z) (fs : list (Z * Z)) (m : Z) : Z :=\n  match xs with\n  | [] => 0 (* Fallback; should not occur due to non-empty input and valid max *)\n  | x :: t =>\n      if Z.eqb (lookup_count x fs) m then x\n      else find_first_with_count t fs m\n  end.",
                "code": "let freqs := build_freq xs [] in\n  let m := max_count freqs in\n  find_first_with_count xs freqs m",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "xs <> []",
                "postcond_aux": "Fixpoint count_occZ (x : Z) (xs : list Z) : nat :=\n  match xs with\n  | [] => 0\n  | y :: ys => if Z.eq_dec x y then S (count_occZ x ys) else count_occZ x ys\n  end.",
                "postcond": "(* result is an element of xs *)\n  In result xs /\\\n  (* result has maximal frequency among elements of xs *)\n  (forall y, In y xs -> (count_occZ y xs <= count_occZ result xs)%nat) /\\\n  (* tie-breaking: among elements with maximal frequency, result is the earliest in xs *)\n  (exists pre suf,\n      xs = pre ++ result :: suf /\\\n      ~ In result pre /\\\n      (forall y, In y pre -> (count_occZ y xs < count_occZ result xs)%nat))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_55": {
          "data_id": "verina_basic_55",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "Z.eqb a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true <-> a = b) /\\ (result = false <-> a <> b)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_56": {
          "data_id": "verina_advanced_56",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: partition a list into (nonzeros, zeros) while preserving order *)\nFixpoint partition_zero (xs : list Z) : (list Z) * (list Z) :=\n  match xs with\n  | nil => (nil, nil)\n  | x :: xs' =>\n      let '(nz, z) := partition_zero xs' in\n      if Z.eqb x 0 then (nz, x :: z) else (x :: nz, z)\n  end.",
                "code": "(* Separate non-zero and zero elements, then append zeros to the end *)\n  let '(nz, z) := partition_zero xs in\n  nz ++ z",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Relation capturing \"remove all zeros while preserving the relative order of non-zero elements\" *)\nInductive remove_zeros : list Z -> list Z -> Prop :=\n| rz_nil : remove_zeros [] []\n| rz_cons_zero : forall x xs nz,\n    x = 0 ->\n    remove_zeros xs nz ->\n    remove_zeros (x :: xs) nz\n| rz_cons_nz : forall x xs nz,\n    x <> 0 ->\n    remove_zeros xs nz ->\n    remove_zeros (x :: xs) (x :: nz).\n\n(* Relation producing a list consisting solely of zeros, with length equal to\n   the number of zeros appearing in the source list. *)\nInductive zeros_from : list Z -> list Z -> Prop :=\n| zf_nil : zeros_from [] []\n| zf_cons_zero : forall x xs zs,\n    x = 0 ->\n    zeros_from xs zs ->\n    zeros_from (x :: xs) (0 :: zs)\n| zf_cons_nz : forall x xs zs,\n    x <> 0 ->\n    zeros_from xs zs ->\n    zeros_from (x :: xs) zs.",
                "postcond": "exists nz zs,\n    result = nz ++ zs /\\\n    remove_zeros xs nz /\\\n    zeros_from xs zs",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_56": {
          "data_id": "verina_basic_56",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: take the first n elements of a list *)\nFixpoint takeZ (n : nat) (l : list Z) : list Z :=\n  match n, l with\n  | O, _ => []\n  | S n', [] => []\n  | S n', x :: xs => x :: takeZ n' xs\n  end.\n\n(* Helper function: drop the first n elements of a list *)\nFixpoint dropZ (n : nat) (l : list Z) : list Z :=\n  match n, l with\n  | O, _ => l\n  | S n', [] => []\n  | S n', _ :: xs => dropZ n' xs\n  end.\n\n(* Helper function: sublist starting at index s of length len *)\nDefinition sublistZ (s len : nat) (l : list Z) : list Z :=\n  takeZ len (dropZ s l).",
                "code": "let prefix := takeZ dStart dest in\n  let middle := sublistZ sStart len src in\n  let suffix := dropZ (Nat.add dStart len) dest in\n  prefix ++ middle ++ suffix",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* The source has at least len elements starting at sStart,\n     and the destination has at least len slots starting at dStart. *)\n  sStart + len <= length src /\\\n  dStart + len <= length dest",
                "postcond_aux": "",
                "postcond": "(* Result has the same length as dest *)\n  length result = length dest /\\\n  (* Elements before dStart are unchanged *)\n  (forall (j : nat), j < dStart -> List.nth j result 0%Z = List.nth j dest 0%Z) /\\\n  (* Elements at indices >= dStart + len are unchanged *)\n  (forall (j : nat), dStart + len <= j -> j < length dest -> List.nth j result 0%Z = List.nth j dest 0%Z) /\\\n  (* The segment [dStart, dStart + len) in result equals the segment [sStart, sStart + len) in src *)\n  (forall (i : nat), i < len ->\n      List.nth (dStart + i) result 0%Z = List.nth (sStart + i) src 0%Z)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_57": {
          "data_id": "verina_advanced_57",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: drop elements until we find x; returns the list after x if found *)\nFixpoint drop_until_eq (x : Z) (l : list Z) : option (list Z) :=\n  match l with\n  | nil => None\n  | y :: ys => if Z.eqb y x then Some ys else drop_until_eq x ys\n  end.\n\n(* Helper: find the first element greater than x in the list *)\nFixpoint first_greater (x : Z) (l : list Z) : option Z :=\n  match l with\n  | nil => None\n  | y :: ys => if Z.ltb x y then Some y else first_greater x ys\n  end.\n\n(* Helper: compute next greater element of x as it appears in l *)\nDefinition next_greater_from_list (x : Z) (l : list Z) : Z :=\n  match drop_until_eq x l with\n  | Some rest =>\n      match first_greater x rest with\n      | Some y => y\n      | None => (-1)%Z\n      end\n  | None => (-1)%Z\n  end.",
                "code": "map (fun x => next_greater_from_list x nums2) nums1",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* nums1 is a subset of nums2 and both have unique elements *)\n  NoDup nums1 /\\ NoDup nums2 /\\ (forall x, List.In x nums1 -> List.In x nums2)",
                "postcond_aux": "(* y is the next greater element for x in l: y is the first element to the right of x that is > x *)\nDefinition is_next_greater (l : list Z) (x y : Z) : Prop :=\n  exists (i j : nat),\n    nth_error l i = Some x /\\\n    nth_error l j = Some y /\\\n    (i < j)%nat /\\\n    Z.lt x y /\\\n    (* Minimality of j: no element > x strictly between i and j *)\n    (forall (k : nat) (z : Z),\n        (i < k)%nat /\\ (k < j)%nat ->\n        nth_error l k = Some z ->\n        Z.le z x).\n\n(* There is no next greater element for x in l *)\nDefinition no_next_greater (l : list Z) (x : Z) : Prop :=\n  exists (i : nat),\n    nth_error l i = Some x /\\\n    (forall (j : nat) (z : Z),\n        (i < j)%nat ->\n        nth_error l j = Some z ->\n        Z.le z x).",
                "postcond": "(* result aligns with nums1: for each nums1[i], result[i] is the next greater element in nums2,\n     or -1 if none exists *)\n  length result = length nums1 /\\\n  forall (i : nat) (x : Z),\n    nth_error nums1 i = Some x ->\n    exists (r : Z),\n      nth_error result i = Some r /\\\n      (\n        (exists y : Z, is_next_greater nums2 x y /\\ r = y)\n        \\/\n        (no_next_greater nums2 x /\\ r = (-1))\n      )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_57": {
          "data_id": "verina_basic_57",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Count how many elements in the list are strictly less than the given threshold. *)\nFixpoint countLessThanAux (numbers : list Z) (threshold : Z) : nat :=\n  match numbers with\n  | nil => 0%nat\n  | x :: xs =>\n      let rest := countLessThanAux xs threshold in\n      if Z.ltb x threshold then S rest else rest\n  end.",
                "code": "countLessThanAux numbers threshold",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = List.length (List.filter (fun x : Z => Z.ltb x threshold) numbers)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_58": {
          "data_id": "verina_basic_58",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Recursive helper that traverses the list and doubles each element *)\nFixpoint double_array_elements_aux (l : list Z) : list Z :=\n  match l with\n  | [] => []\n  | x :: xs => (x + x) :: double_array_elements_aux xs\n  end.",
                "code": "(* Apply the helper to the input list to produce the doubled list *)\n  double_array_elements_aux s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = List.map (fun x => 2 * x) s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_58": {
          "data_id": "verina_advanced_58",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Return the i-th element of a list with a default if out of bounds *)\nFixpoint nth_default (l : list nat) (i d : nat) : nat :=\n  match l, i with\n  | [], _ => d\n  | x :: _, 0 => x\n  | _ :: xs, S i' => nth_default xs i' d\n  end.\n\n(* Append one element to the end of a list *)\nFixpoint snoc (l : list nat) (x : nat) : list nat :=\n  match l with\n  | [] => x :: []\n  | y :: ys => y :: snoc ys x\n  end.\n\n(* Minimum of two natural numbers *)\nDefinition min2 (a b : nat) : nat :=\n  if Nat.leb a b then a else b.\n\n(* Minimum of three natural numbers *)\nDefinition min3 (a b c : nat) : nat :=\n  min2 (min2 a b) c.\n\n(* Last element of a list, with a default for the empty list *)\nFixpoint last_elem (l : list nat) (d : nat) : nat :=\n  match l with\n  | [] => d\n  | x :: [] => x\n  | _ :: xs => last_elem xs d\n  end.\n\n(* Generate the sequence of ugly numbers up to the required count.\n   rem is how many additional ugly numbers to generate beyond the current list l.\n   l stores the ugly numbers in increasing order.\n   i2, i3, i5 are indices for multiples of 2, 3, and 5 respectively. *)\nFixpoint gen_ugly (rem : nat) (l : list nat) (i2 i3 i5 : nat) : nat :=\n  match rem with\n  | 0 => last_elem l 0\n  | S rem' =>\n      let v2 := Nat.mul (nth_default l i2 1) 2 in\n      let v3 := Nat.mul (nth_default l i3 1) 3 in\n      let v5 := Nat.mul (nth_default l i5 1) 5 in\n      let next := min3 v2 v3 v5 in\n      let i2' := if Nat.eqb v2 next then S i2 else i2 in\n      let i3' := if Nat.eqb v3 next then S i3 else i3 in\n      let i5' := if Nat.eqb v5 next then S i5 else i5 in\n      gen_ugly rem' (snoc l next) i2' i3' i5'\n  end.",
                "code": "match n with\n  | O => 0\n  | S n' => gen_ugly n' (1 :: []) 0 0 0\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Predicate characterizing ugly numbers: generated from 1 by multiplying by 2, 3, or 5 *)\nInductive Ugly : nat -> Prop :=\n| Ugly1 : Ugly 1\n| UglyMul2 : forall n, Ugly n -> Ugly (2 * n)\n| UglyMul3 : forall n, Ugly n -> Ugly (3 * n)\n| UglyMul5 : forall n, Ugly n -> Ugly (5 * n).",
                "postcond": "exists (f : nat -> nat),\n    f 0 = 1 /\\\n    (forall k, Ugly (f k)) /\\\n    (forall k, f k < f (S k)) /\\\n    (forall m, Ugly m -> exists k, f k = m) /\\\n    result = f (Nat.pred n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_59": {
          "data_id": "verina_basic_59",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Return the pair (2*x, 4*x) *)\n  (2 * x, 4 * x)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (2 * x, 4 * x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_59": {
          "data_id": "verina_advanced_59",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Basic boolean comparisons for nat *)\nFixpoint leb (n m : nat) : bool :=\n  match n, m with\n  | O, _ => true\n  | S _, O => false\n  | S n', S m' => leb n' m'\n  end.\n\nDefinition ltb (n m : nat) : bool := leb (S n) m.\n\nFixpoint beq_nat (n m : nat) : bool :=\n  match n, m with\n  | O, O => true\n  | O, S _ => false\n  | S _, O => false\n  | S n', S m' => beq_nat n' m'\n  end.\n\n(* Check numeric ranges using nat_of_ascii *)\nDefinition nat_between_inclusive (x a b : nat) : bool :=\n  andb (leb a x) (leb x b).\n\nDefinition isDigit (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n  nat_between_inclusive n 48 57.  (* '0'..'9' *)\n\nDefinition isUpper (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n  nat_between_inclusive n 65 90.  (* 'A'..'Z' *)\n\nDefinition isLower (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n  nat_between_inclusive n 97 122. (* 'a'..'z' *)\n\nDefinition isAlpha (c : ascii) : bool :=\n  orb (isUpper c) (isLower c).\n\nDefinition isAlnum (c : ascii) : bool :=\n  orb (isAlpha c) (isDigit c).\n\n(* Convert to lowercase (only affects 'A'..'Z') *)\nDefinition toLowerASCII (c : ascii) : ascii :=\n  let n := nat_of_ascii c in\n  if isUpper c\n  then ascii_of_nat (n + 32)\n  else c.\n\n(* Normalize a string: keep only alphanumeric, map letters to lowercase *)\nFixpoint normalize (s : string) : string :=\n  match s with\n  | EmptyString => EmptyString\n  | String c rest =>\n      if isAlnum c\n      then String (toLowerASCII c) (normalize rest)\n      else normalize rest\n  end.\n\n(* Reverse a string using an accumulator *)\nFixpoint rev_acc (s acc : string) : string :=\n  match s with\n  | EmptyString => acc\n  | String c rest => rev_acc rest (String c acc)\n  end.\n\nDefinition rev_string (s : string) : string := rev_acc s EmptyString.\n\n(* Boolean equality for ascii via their nat codes *)\nDefinition eqb_ascii (a b : ascii) : bool :=\n  beq_nat (nat_of_ascii a) (nat_of_ascii b).\n\n(* Boolean equality for strings *)\nFixpoint eqb_string (s1 s2 : string) : bool :=\n  match s1, s2 with\n  | EmptyString, EmptyString => true\n  | String c1 r1, String c2 r2 =>\n      if eqb_ascii c1 c2 then eqb_string r1 r2 else false\n  | _, _ => false\n  end.",
                "code": "let ns := normalize s in\n  eqb_string ns (rev_string ns)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* ASCII classification helpers *)\nDefinition is_digit_range (n : nat) : Prop := 48 <= n /\\ n <= 57.\nDefinition is_upper_range (n : nat) : Prop := 65 <= n /\\ n <= 90.\nDefinition is_lower_range (n : nat) : Prop := 97 <= n /\\ n <= 122.\nDefinition is_letter_range (n : nat) : Prop := is_upper_range n \\/ is_lower_range n.\n\n(* Alphanumeric predicate on characters *)\nDefinition is_alnum_ascii (c : Ascii.ascii) : Prop :=\n  let n := Ascii.nat_of_ascii c in\n  is_digit_range n \\/ is_letter_range n.\n\n(* Case-normalization at the nat-code level: map uppercase letters to lowercase; leave others unchanged *)\nDefinition lower_of_nat (n l : nat) : Prop :=\n  (is_upper_range n /\\ l = n + 32) \\/ (~ is_upper_range n /\\ l = n).\n\n(* Case-insensitive character equality: characters are equal after lowercasing *)\nDefinition char_ci_eq (c1 c2 : Ascii.ascii) : Prop :=\n  let n1 := Ascii.nat_of_ascii c1 in\n  let n2 := Ascii.nat_of_ascii c2 in\n  exists l1 l2, lower_of_nat n1 l1 /\\ lower_of_nat n2 l2 /\\ l1 = l2.\n\n(* List append (avoids needing List imports) *)\nFixpoint app_ascii (l1 l2 : list Ascii.ascii) : list Ascii.ascii :=\n  match l1 with\n  | nil => l2\n  | x :: xs => x :: app_ascii xs l2\n  end.\n\n(* List reverse for ascii lists *)\nFixpoint rev_ascii (l : list Ascii.ascii) : list Ascii.ascii :=\n  match l with\n  | nil => nil\n  | x :: xs => app_ascii (rev_ascii xs) (x :: nil)\n  end.\n\n(* Pointwise list relation using case-insensitive character equality *)\nFixpoint list_rel_ci (l1 l2 : list Ascii.ascii) : Prop :=\n  match l1, l2 with\n  | nil, nil => True\n  | x1 :: t1, x2 :: t2 => char_ci_eq x1 x2 /\\ list_rel_ci t1 t2\n  | _, _ => False\n  end.\n\n(* Relational definition of filtering: keep only alphanumeric characters, in order *)\nInductive filter_alnum_rel : string -> list Ascii.ascii -> Prop :=\n| filter_nil : filter_alnum_rel String.EmptyString nil\n| filter_cons_keep (c : Ascii.ascii) (s : string) (l : list Ascii.ascii) :\n    is_alnum_ascii c ->\n    filter_alnum_rel s l ->\n    filter_alnum_rel (String.String c s) (c :: l)\n| filter_cons_drop (c : Ascii.ascii) (s : string) (l : list Ascii.ascii) :\n    ~ is_alnum_ascii c ->\n    filter_alnum_rel s l ->\n    filter_alnum_rel (String.String c s) l.",
                "postcond": "(* result is true iff, after removing non-alphanumerics and ignoring case, the string reads the same forwards and backwards *)\n  result = true <->\n    exists l : list Ascii.ascii,\n      filter_alnum_rel s l /\\\n      list_rel_ci l (rev_ascii l)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_60": {
          "data_id": "verina_basic_60",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean test for even integers using modulo 2 *)\nDefinition evenb (z : Z) : bool :=\n  Z.eqb (z mod 2) 0.\n\n(* Filter helper that retains only even numbers, preserving order *)\nFixpoint filter_even (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | x :: xs =>\n      if evenb x then x :: filter_even xs\n      else filter_even xs\n  end.",
                "code": "(* Return the list of even numbers from arr, preserving original order *)\n  filter_even arr",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = filter (fun z => Z.even z) arr",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_60": {
          "data_id": "verina_advanced_60",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to test evenness via structural recursion *)\nFixpoint evenb (n : nat) : bool :=\n  match n with\n  | O => true\n  | S O => false\n  | S (S n') => evenb n'\n  end.\n\n(* Oddness as the negation of evenness *)\nDefinition oddb (n : nat) : bool := negb (evenb n).\n\n(* Tail-recursive partition with accumulators, preserving input order via final reversals *)\nFixpoint partition_aux (l : list nat) (evens odds : list nat) : (list nat * list nat) :=\n  match l with\n  | [] => (rev evens, rev odds)\n  | x :: xs =>\n      if evenb x\n      then partition_aux xs (x :: evens) odds\n      else partition_aux xs evens (x :: odds)\n  end.",
                "code": "partition_aux nums [] []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Parity predicates without extra imports *)\nDefinition even (n : nat) : Prop := exists k, n = k + k.\nDefinition odd  (n : nat) : Prop := exists k, n = S (k + k).\n\n(* Order-preserving subsequence relation *)\nInductive subseq : list nat -> list nat -> Prop :=\n| subseq_nil  : forall l, subseq [] l\n| subseq_cons : forall x xs ys, subseq xs ys -> subseq (x :: xs) (x :: ys)\n| subseq_skip : forall x y xs ys, subseq (x :: xs) ys -> subseq (x :: xs) (y :: ys).",
                "postcond": "let evens := fst result in\n  let odds  := snd result in\n  subseq evens nums /\\\n  subseq odds nums /\\\n  (forall x : nat, In x evens <-> In x nums /\\ even x) /\\\n  (forall x : nat, In x odds  <-> In x nums /\\ odd x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_61": {
          "data_id": "verina_advanced_61",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Build a list of prefix products: at position i, the product of all elements before i *)\nFixpoint prefix_products (l : list Z) (acc : Z) : list Z :=\n  match l with\n  | [] => []\n  | x :: xs => acc :: prefix_products xs (acc * x)\n  end.\n\n(* Simple tail-recursive list reversal *)\nFixpoint rev_aux (l acc : list Z) : list Z :=\n  match l with\n  | [] => acc\n  | x :: xs => rev_aux xs (x :: acc)\n  end.\n\nDefinition rev_list (l : list Z) : list Z := rev_aux l [].\n\n(* Suffix products via reversing and reusing prefix products.\n   For index i, this yields the product of all elements after i. *)\nDefinition suffix_products (l : list Z) : list Z :=\n  let rev_l := rev_list l in\n  let pre_rev := prefix_products rev_l 1%Z in\n  rev_list pre_rev.\n\n(* Pointwise multiplication of two lists (truncates to the shorter list) *)\nFixpoint map2_mul (l1 l2 : list Z) : list Z :=\n  match l1, l2 with\n  | x1 :: t1, x2 :: t2 => (x1 * x2) :: map2_mul t1 t2\n  | _, _ => []\n  end.",
                "code": "(* Compute prefix (products before each index) and suffix (products after each index),\n     then multiply elementwise to get the product of array except self. *)\n  let pref := prefix_products nums 1%Z in\n  let suff := suffix_products nums in\n  map2_mul pref suff",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Fixpoint prod_list (l : list Z) : Z :=\n  match l with\n  | [] => 1\n  | x :: xs => x * prod_list xs\n  end.\n\nFixpoint remove_nth_Z (n : nat) (l : list Z) : list Z :=\n  match n, l with\n  | O, _ :: xs => xs\n  | S n', x :: xs => x :: remove_nth_Z n' xs\n  | _, [] => []\n  end.",
                "postcond": "(* The result list has the same length as the input,\n     and each valid index i in result equals the product of all elements of nums except at i. *)\n  List.length result = List.length nums /\\\n  forall (i : nat),\n    i < List.length nums ->\n    List.nth i result 0 = prod_list (remove_nth_Z i nums)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_61": {
          "data_id": "verina_basic_61",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Check whether an ASCII character is a digit '0'..'9' *)\nDefinition isDigitAscii (c : Ascii.ascii) : bool :=\n  let n := Ascii.nat_of_ascii c in\n  andb (Nat.leb 48 n) (Nat.leb n 57).\n\n(* Recursive helper to verify all characters in a string are digits *)\nFixpoint allDigits_aux (s : string) : bool :=\n  match s with\n  | EmptyString => true\n  | String a s' => andb (isDigitAscii a) (allDigits_aux s')\n  end.",
                "code": "allDigits_aux s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Fixpoint ForallString (P : ascii -> Prop) (s : string) : Prop :=\n  match s with\n  | EmptyString => True\n  | String c s' => P c /\\ ForallString P s'\n  end.\n\nDefinition is_digit_ascii (c : ascii) : Prop :=\n  let n := nat_of_ascii c in\n  nat_of_ascii \"0\"%char <= n /\\ n <= nat_of_ascii \"9\"%char.",
                "postcond": "result = true <-> ForallString is_digit_ascii s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_62": {
          "data_id": "verina_advanced_62",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Compute the running maximum from the left *)\nFixpoint left_maxes (l : list Z) (m : Z) : list Z :=\n  match l with\n  | [] => []\n  | h :: t =>\n      let m' := Z.max m h in\n      m' :: left_maxes t m'\n  end.\n\n(* Compute the running maximum from the right by reversing,\n   computing left maxima, then reversing back *)\nDefinition right_maxes (l : list Z) : list Z :=\n  let rl := rev l in\n  let rp := left_maxes rl 0 in\n  rev rp.\n\n(* Sum of trapped water at each position *)\nFixpoint total_trapped (hs lms rms : list Z) : Z :=\n  match hs, lms, rms with\n  | h :: hs', lm :: lms', rm :: rms' =>\n      let cap := Z.min lm rm - h in\n      let add := if Z.ltb cap 0 then 0 else cap in\n      add + total_trapped hs' lms' rms'\n  | _, _, _ => 0\n  end.",
                "code": "let lms := left_maxes heights 0 in\n  let rms := right_maxes heights in\n  total_trapped heights lms rms",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Indices 0 .. n-1 *)\nFixpoint indices (n : nat) : list nat :=\n  match n with\n  | 0 => []\n  | S n' => 0 :: map S (indices n')\n  end.\n\nDefinition indices_list (l : list Z) : list nat := indices (length l).\n\n(* Sum over a list of Z *)\nFixpoint sum_Z (l : list Z) : Z :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum_Z xs\n  end.\n\n(* Max over a list of Z; default 0 for empty (safe as water is clamped at 0) *)\nFixpoint max_list_Z (l : list Z) : Z :=\n  match l with\n  | [] => 0\n  | x :: xs => Z.max x (max_list_Z xs)\n  end.\n\n(* nth with default 0 on Z *)\nDefinition nthZ (l : list Z) (i : nat) : Z := List.nth i l 0%Z.\n\n(* Water at index i per standard trapping rain water formula *)\nDefinition water_at (h : list Z) (i : nat) : Z :=\n  Z.max 0\n    (Z.min\n       (max_list_Z (firstn (S i) h))        (* left max up to and including i *)\n       (max_list_Z (skipn i h))             (* right max from i to end *)\n     - nthZ h i).                           (* height at i *)\n\n(* Total trapped water *)\nDefinition total_trapped (h : list Z) : Z :=\n  sum_Z (map (fun i => water_at h i) (indices_list h)).",
                "postcond": "result = total_trapped heights",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_62": {
          "data_id": "verina_basic_62",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: linear scan returning the first index (as Z) where key appears, or -1 if absent *)\nFixpoint find_first_aux (l : list Z) (key : Z) (idx : Z) : Z :=\n  match l with\n  | [] => (-1)\n  | x :: xs =>\n      if Z.eqb x key then idx\n      else find_first_aux xs key (idx + 1)\n  end.",
                "code": "(* Start linear search from index 0 *)\n  find_first_aux a key 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "((result = (-1)%Z) <-> (forall i : nat, i < length a -> nth_error a i <> Some key))\n  /\\\n  (result <> (-1)%Z ->\n    0 <= result /\\\n    result < Z.of_nat (length a) /\\\n    nth_error a (Z.to_nat result) = Some key /\\\n    (forall j : nat, j < Z.to_nat result -> nth_error a j <> Some key))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_63": {
          "data_id": "verina_basic_63",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean comparison x < y for real numbers, using the decidable order on R *)\nDefinition Rltb (x y : R) : bool :=\n  match Rlt_dec x y with\n  | left _ => true\n  | right _ => false\n  end.\n\n(* Boolean test for inequality x <> y via trichotomy: x <> y iff x<y or y<x *)\nDefinition Rneqb (x y : R) : bool :=\n  orb (Rltb x y) (Rltb y x).\n\n(* Two numbers are \"close\" if they are distinct and their absolute difference is < threshold *)\nDefinition closeb (x y t : R) : bool :=\n  andb (Rneqb x y) (Rltb (Rabs (x - y)) t).\n\n(* Check within a list if there exists an element close to x under threshold t *)\nFixpoint exists_close_with (x : R) (l : list R) (t : R) : bool :=\n  match l with\n  | [] => false\n  | y :: ys =>\n      if closeb x y t\n      then true\n      else exists_close_with x ys t\n  end.\n\n(* Quadratic scan to find any close pair in the list under threshold t *)\nFixpoint has_close_pairs (l : list R) (t : R) : bool :=\n  match l with\n  | [] => false\n  | x :: [] => false\n  | x :: xs =>\n      if exists_close_with x xs t\n      then true\n      else has_close_pairs xs t\n  end.",
                "code": "has_close_pairs numbers threshold",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true <->\n  exists (i j : nat) (x y : R),\n    nth_error numbers i = Some x /\\\n    nth_error numbers j = Some y /\\\n    i <> j /\\\n    Rabs (x - y) < threshold",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_63": {
          "data_id": "verina_advanced_63",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to count additional unique elements given the previous seen element *)\nFixpoint count_uniques_from (prev : Z) (l : list Z) : nat :=\n  match l with\n  | nil => 0\n  | x :: xs =>\n      if Z.eqb x prev\n      then count_uniques_from prev xs\n      else S (count_uniques_from x xs)\n  end.",
                "code": "match nums with\n  | nil => 0%nat\n  | x :: xs => S (count_uniques_from x xs)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "exists l' : list Z,\n    NoDup l' /\\\n    (forall x : Z, In x l' <-> In x nums) /\\\n    result = length l'",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_64": {
          "data_id": "verina_advanced_64",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean equality on natural numbers, defined recursively *)\nFixpoint nat_eqb (a b : nat) {struct a} : bool :=\n  match a, b with\n  | O, O => true\n  | S a', S b' => nat_eqb a' b'\n  | _, _ => false\n  end.\n\n(* Helper function that removes all occurrences of [target] from [l] while preserving order *)\nFixpoint remove_element (target : nat) (l : list nat) : list nat :=\n  match l with\n  | [] => []\n  | x :: xs =>\n      if nat_eqb x target\n      then remove_element target xs\n      else x :: remove_element target xs\n  end.",
                "code": "(* Use the helper recursive function to remove all occurrences of [target] from [lst] *)\n  remove_element target lst",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* A relational specification capturing the result of removing all occurrences\n   of [target] from [lst] while preserving the relative order of the remaining elements. *)\nInductive remove_all_spec (target : nat) : list nat -> list nat -> Prop :=\n| ras_nil :\n    remove_all_spec target [] []\n| ras_drop (x : nat) (xs rs : list nat) :\n    x = target ->\n    remove_all_spec target xs rs ->\n    remove_all_spec target (x :: xs) rs\n| ras_keep (x : nat) (xs rs : list nat) :\n    x <> target ->\n    remove_all_spec target xs rs ->\n    remove_all_spec target (x :: xs) (x :: rs).",
                "postcond": "remove_all_spec target lst result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_64": {
          "data_id": "verina_basic_64",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: take the first n elements from a list *)\nFixpoint take (n : nat) (xs : list ascii) : list ascii :=\n  match n, xs with\n  | O, _ => []\n  | S n', [] => []\n  | S n', x :: xs' => x :: take n' xs'\n  end.\n\n(* Helper function: drop the first n elements from a list *)\nFixpoint drop (n : nat) (xs : list ascii) : list ascii :=\n  match n, xs with\n  | O, _ => xs\n  | S n', [] => []\n  | S n', _ :: xs' => drop n' xs'\n  end.",
                "code": "(* Construct the result by:\n     - taking the first [atPos] characters from the first [l] of oline,\n     - then the first [p] characters from nl,\n     - then the remaining characters from the first [l] of oline after [atPos]. *)\n  let base := take l oline in\n  let pre := take atPos base in\n  let ins := take p nl in\n  let suf := drop atPos base in\n  pre ++ ins ++ suf",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* atPos within [0, l], and l, p within bounds of their respective lists *)\n  atPos <= l /\\ l <= length oline /\\ p <= length nl",
                "postcond_aux": "",
                "postcond": "(* The result is precisely the prefix of length atPos from the first l of oline,\n     followed by the first p of nl, followed by the remainder of the first l of oline starting at atPos. *)\n  result = (firstn atPos (firstn l oline)) ++ (firstn p nl) ++ (skipn atPos (firstn l oline))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_65": {
          "data_id": "verina_basic_65",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: bounded linear search up to k steps, increasing r while (S r)^2 â‰¤ N *)\nFixpoint sqrt_aux (N r k : nat) : nat :=\n  match k with\n  | O => r\n  | S k' =>\n      if Nat.leb ((S r) * (S r)) N\n      then sqrt_aux N (S r) k'\n      else r\n  end.",
                "code": "(* Start from r = 0, with a fuel of S N steps (enough since the result r â‰¤ N) *)\n  sqrt_aux N 0 (S N)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result * result <= N /\\ N < (result + 1) * (result + 1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_65": {
          "data_id": "verina_advanced_65",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Tail-recursive string reversal using an accumulator *)\nFixpoint rev_str_acc (s acc : string) : string :=\n  match s with\n  | EmptyString => acc\n  | String c s' => rev_str_acc s' (String c acc)\n  end.",
                "code": "(* Reverse the string by accumulating characters into an initially empty string *)\n  rev_str_acc s EmptyString",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Tail-recursive string reversal to characterize the result *)\nFixpoint str_rev_acc (s acc : string) : string :=\n  match s with\n  | EmptyString => acc\n  | String c s' => str_rev_acc s' (String c acc)\n  end.\n\nDefinition str_rev (s : string) : string := str_rev_acc s EmptyString.",
                "postcond": "result = str_rev s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_66": {
          "data_id": "verina_basic_66",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* An integer is even iff its remainder modulo 2 is 0 *)\n  Z.eqb (x mod 2) 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true <-> x mod 2 = 0",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_66": {
          "data_id": "verina_advanced_66",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: ASCII space character *)\nDefinition space_char : Ascii.ascii := Ascii.ascii_of_nat 32.\n\n(* Helper: check if an ascii character is a space *)\nDefinition is_space (c : Ascii.ascii) : bool :=\n  if Ascii.ascii_dec c space_char then true else false.\n\n(* Helper: append a character to the end of a string *)\nFixpoint snoc (s : string) (c : Ascii.ascii) : string :=\n  match s with\n  | EmptyString => String c EmptyString\n  | String c' s' => String c' (snoc s' c)\n  end.\n\n(* Helper: add current word to accumulator if non-empty *)\nDefinition add_current_to_acc (current : string) (acc : list string) : list string :=\n  match current with\n  | EmptyString => acc\n  | _ => current :: acc\n  end.\n\n(* Parse the input into a list of words in reverse order, removing extra spaces *)\nFixpoint parse_words_rev (s : string) (current : string) (acc : list string) : list string :=\n  match s with\n  | EmptyString => add_current_to_acc current acc\n  | String ch rest =>\n      if is_space ch then\n        (* Word boundary: push current if non-empty and reset *)\n        parse_words_rev rest EmptyString (add_current_to_acc current acc)\n      else\n        (* Build current word by appending character at the end *)\n        parse_words_rev rest (snoc current ch) acc\n  end.\n\n(* Helper: string append *)\nFixpoint str_append (s1 s2 : string) : string :=\n  match s1 with\n  | EmptyString => s2\n  | String c s1' => String c (str_append s1' s2)\n  end.\n\n(* One-space string *)\nDefinition space_str : string := String space_char EmptyString.\n\n(* Join a list of words with single spaces (list is assumed to be in desired order) *)\nFixpoint join_with_space (l : list string) : string :=\n  match l with\n  | nil => EmptyString\n  | cons w nil => w\n  | cons w tl => str_append w (str_append space_str (join_with_space tl))\n  end.",
                "code": "let words_rev := parse_words_rev words_str EmptyString nil in\n  (* words_rev holds the words in reverse order of appearance *)\n  join_with_space words_rev",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Auxiliary definitions to formalize \"words\", reversing their order, and joining with single spaces *)\n\n(* Character and string helpers *)\nDefinition space_char : ascii := (\" \"%char).\nDefinition space_str : string := String space_char EmptyString.\n\n(* Decide if a character is a space *)\nDefinition is_space (c : ascii) : bool :=\n  if Ascii.ascii_dec c space_char then true else false.\n\n(* List reverse with accumulator *)\nFixpoint list_rev_aux {A : Type} (l acc : list A) : list A :=\n  match l with\n  | nil => acc\n  | cons x xs => list_rev_aux xs (cons x acc)\n  end.\n\nDefinition list_rev {A : Type} (l : list A) : list A := list_rev_aux l nil.\n\n(* String reverse with accumulator *)\nFixpoint string_rev_aux (s acc : string) : string :=\n  match s with\n  | EmptyString => acc\n  | String c s' => string_rev_aux s' (String c acc)\n  end.\n\nDefinition string_rev (s : string) : string := string_rev_aux s EmptyString.\n\n(* Extract words: maximal sequences of non-space characters, ignoring extra spaces *)\nFixpoint words_acc (s cur : string) (acc : list string) : list string :=\n  match s with\n  | EmptyString =>\n      match cur with\n      | EmptyString => list_rev acc\n      | _ => list_rev (cons (string_rev cur) acc)\n      end\n  | String c s' =>\n      if is_space c then\n        match cur with\n        | EmptyString => words_acc s' EmptyString acc\n        | _ => words_acc s' EmptyString (cons (string_rev cur) acc)\n        end\n      else\n        (* accumulate current non-space character; we prepend and will reverse at word end *)\n        words_acc s' (String c cur) acc\n  end.\n\nDefinition words (s : string) : list string := words_acc s EmptyString nil.\n\n(* Join a list of words with a single space between them, no leading/trailing space *)\nFixpoint join_with_spaces (ws : list string) : string :=\n  match ws with\n  | nil => EmptyString\n  | cons w nil => w\n  | cons w ws' => String.append w (String.append space_str (join_with_spaces ws'))\n  end.",
                "postcond": "(* The result string equals the words of the input, reversed in order,\n     joined by single spaces, with no leading or trailing spaces. *)\n  result = join_with_spaces (list_rev (words words_str))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_67": {
          "data_id": "verina_advanced_67",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Reverse a list using an accumulator (to avoid extra imports). *)\nFixpoint rev_acc {A : Type} (l acc : list A) : list A :=\n  match l with\n  | nil => acc\n  | cons x xs => rev_acc xs (cons x acc)\n  end.\n\nDefinition rev_list {A : Type} (l : list A) : list A := rev_acc l nil.\n\n(* Core RLE with an accumulator.\n   - s: remaining input string\n   - curr: current run's character (if any)\n   - n: length of the current run (valid only when curr = Some _)\n   - acc: accumulated result in reverse order\n*)\nFixpoint rle_acc\n  (s : string) (curr : option ascii) (n : nat) (acc : list (ascii * nat))\n  : list (ascii * nat) :=\n  match s with\n  | String.EmptyString =>\n      (* Flush the last run if present, then reverse the accumulator\n         to get the output in left-to-right order. *)\n      match curr with\n      | None => rev_list acc\n      | Some c0 => rev_list ((c0, n) :: acc)\n      end\n  | String.String c s' =>\n      match curr with\n      | None =>\n          (* Start a new run with the current character. *)\n          rle_acc s' (Some c) 1 acc\n      | Some c0 =>\n          (* Continue the run if the same character; otherwise, flush and start new. *)\n          match Ascii.ascii_dec c c0 with\n          | left _ => rle_acc s' (Some c0) (S n) acc\n          | right _ => rle_acc s' (Some c) 1 ((c0, n) :: acc)\n          end\n      end\n  end.\n\nDefinition rle (s : string) : list (ascii * nat) :=\n  rle_acc s None 0 nil.",
                "code": "rle s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Repeat a character c, n times, as a string *)\nFixpoint repeat_char (c : ascii) (n : nat) : string :=\n  match n with\n  | 0 => EmptyString\n  | S k => String c (repeat_char c k)\n  end.\n\n(* String concatenation *)\nFixpoint str_app (s1 s2 : string) : string :=\n  match s1 with\n  | EmptyString => s2\n  | String c s1' => String c (str_app s1' s2)\n  end.\n\n(* Decode a run-length encoded list into a string *)\nFixpoint decode (l : list (ascii * nat)) : string :=\n  match l with\n  | nil => EmptyString\n  | (c, n) :: t => str_app (repeat_char c n) (decode t)\n  end.\n\n(* All run-lengths are positive (i.e., non-zero) *)\nFixpoint all_pos (l : list (ascii * nat)) : Prop :=\n  match l with\n  | nil => True\n  | (_, n) :: t => n <> 0 /\\ all_pos t\n  end.\n\n(* No two consecutive pairs have the same character *)\nFixpoint no_adj_same (l : list (ascii * nat)) : Prop :=\n  match l with\n  | nil => True\n  | _ :: nil => True\n  | (c1, _) :: (c2, _) :: t => c1 <> c2 /\\ no_adj_same ((c2, 0) :: t) (* the 0 here is ignored by pattern, but keep structure *)\n  end.",
                "postcond": "(* Result is a valid run-length encoding:\n     - all run-lengths are positive\n     - adjacent pairs do not repeat the same character\n     - decoding yields the original string\n  *)\n  all_pos result /\\\n  no_adj_same result /\\\n  decode result = s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_67": {
          "data_id": "verina_basic_67",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean equality on ascii using the decidable equality ascii_dec *)\nDefinition eqb_ascii (a b : ascii) : bool :=\n  match ascii_dec a b with\n  | left _ => true\n  | right _ => false\n  end.\n\n(* Boolean equality on lists of ascii *)\nFixpoint eqb_list_ascii (l1 l2 : list ascii) : bool :=\n  match l1, l2 with\n  | [], [] => true\n  | a1 :: t1, a2 :: t2 =>\n      if eqb_ascii a1 a2 then eqb_list_ascii t1 t2 else false\n  | _, _ => false\n  end.",
                "code": "(* A list is a palindrome iff it equals its reverse *)\n  eqb_list_ascii x (rev x)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true <-> x = rev x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_68": {
          "data_id": "verina_advanced_68",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Append for strings to avoid relying on external notations *)\nFixpoint str_append (s1 s2 : string) : string :=\n  match s1 with\n  | EmptyString => s2\n  | String c s1' => String c (str_append s1' s2)\n  end.\n\n(* Clamp a natural number to at most 9 *)\nDefinition min9 (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S n1 =>\n    match n1 with\n    | 0 => 1\n    | S n2 =>\n      match n2 with\n      | 0 => 2\n      | S n3 =>\n        match n3 with\n        | 0 => 3\n        | S n4 =>\n          match n4 with\n          | 0 => 4\n          | S n5 =>\n            match n5 with\n            | 0 => 5\n            | S n6 =>\n              match n6 with\n              | 0 => 6\n              | S n7 =>\n                match n7 with\n                | 0 => 7\n                | S n8 =>\n                  match n8 with\n                  | 0 => 8\n                  | S n9 =>\n                    match n9 with\n                    | 0 => 9\n                    | S _ => 9\n                    end\n                  end\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n  end.\n\n(* Convert a single digit (0..9) to its ASCII character *)\nDefinition nat_to_digit (n : nat) : ascii :=\n  Ascii.ascii_of_nat (48 + n).\n\n(* Emit one or more (char,digit) pairs for a run, splitting counts > 9 *)\nFixpoint emit_pairs (ch : ascii) (n : nat) : string :=\n  match n with\n  | 0 => EmptyString\n  | _ =>\n      let m := min9 n in\n      let d := nat_to_digit m in\n      String ch (String d (emit_pairs ch (n - m)))\n  end.\n\n(* Core RLE over the remainder of the string given current run *)\nFixpoint rle_go (curr : ascii) (count : nat) (s : string) : string :=\n  match s with\n  | EmptyString => emit_pairs curr count\n  | String ch rest =>\n      match Ascii.ascii_dec ch curr with\n      | left _ => rle_go curr (S count) rest\n      | right _ => str_append (emit_pairs curr count) (rle_go ch 1 rest)\n      end\n  end.\n\n(* Entry for RLE *)\nFixpoint rle_start (s : string) : string :=\n  match s with\n  | EmptyString => EmptyString\n  | String ch rest => rle_go ch 1 rest\n  end.",
                "code": "rle_start input",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "(* Predicate stating that a character is an ASCII digit '0'..'9' *)\nDefinition IsDigit (c : ascii) : Prop :=\n  c = \"0\"%char \\/ c = \"1\"%char \\/ c = \"2\"%char \\/ c = \"3\"%char \\/ c = \"4\"%char \\/\n  c = \"5\"%char \\/ c = \"6\"%char \\/ c = \"7\"%char \\/ c = \"8\"%char \\/ c = \"9\"%char.\n\n(* Input constraint: the input string must not contain any digit characters *)\nFixpoint NoDigits (s : string) : Prop :=\n  match s with\n  | EmptyString => True\n  | String ch rest => ~ IsDigit ch /\\ NoDigits rest\n  end.",
                "precond": "(* The input may be any string of non-digit characters *)\n  NoDigits input",
                "postcond_aux": "(* Digit value relation mapping a digit character to its numeric value *)\nInductive DigitVal : ascii -> nat -> Prop :=\n| DV0 : DigitVal \"0\"%char 0\n| DV1 : DigitVal \"1\"%char 1\n| DV2 : DigitVal \"2\"%char 2\n| DV3 : DigitVal \"3\"%char 3\n| DV4 : DigitVal \"4\"%char 4\n| DV5 : DigitVal \"5\"%char 5\n| DV6 : DigitVal \"6\"%char 6\n| DV7 : DigitVal \"7\"%char 7\n| DV8 : DigitVal \"8\"%char 8\n| DV9 : DigitVal \"9\"%char 9.\n\n(* Repeat a character n times to form a string *)\nFixpoint repeat (n : nat) (c : ascii) : string :=\n  match n with\n  | O => EmptyString\n  | S k => String c (repeat k c)\n  end.\n\n(* Decoding relation: an encoded string (strictly alternating char/digit pairs)\n   decodes to the original input string. This enforces that:\n   - encoded string consists of pairs (non-digit character, digit character)\n   - each pair contributes 'digit' repetitions of that character\n   - concatenation of all contributions equals the original string\n*)\nInductive Decodes : string -> string -> Prop :=\n| DecEmpty :\n    Decodes EmptyString EmptyString\n| DecPair :\n    forall (c d : ascii) (rest enc_out : string) (n : nat),\n      ~ IsDigit c ->\n      DigitVal d n ->\n      Decodes rest enc_out ->\n      Decodes (String c (String d rest)) (String.append (repeat n c) enc_out).",
                "postcond": "(* The result must:\n     1) Strictly alternate between non-digit characters and digit characters and\n        decode back to the original input (captured by Decodes).\n     2) Be non-empty iff the input is non-empty. *)\n  Decodes result input\n  /\\ ((input = EmptyString) <-> (result = EmptyString))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_68": {
          "data_id": "verina_basic_68",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: scan the list left-to-right with an index accumulator.\n   If e is found at position i, return i; if not found, return the final i,\n   which equals the original list length. *)\nFixpoint find_index (l : list Z) (e : Z) (i : nat) : nat :=\n  match l with\n  | nil => i\n  | x :: xs =>\n      if Z.eqb x e then i\n      else find_index xs e (S i)\n  end.",
                "code": "(* Start scanning from index 0. If e is not present, this returns length a. *)\n  find_index a e 0%nat",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* Either result is the first index where e appears, or e is absent and result is the array length *)\n  (exists l1 l2 : list Z,\n      a = l1 ++ e :: l2\n   /\\ result = length l1\n   /\\ ~ List.In e l1)\n  \\/\n  (result = length a /\\ ~ List.In e a)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_69": {
          "data_id": "verina_advanced_69",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function that traverses the list with an index accumulator.\n   It returns the smallest index idx such that the element at idx is >= target,\n   or the length of the list if no such element exists. *)\nFixpoint searchInsertAcc (xs : list Z) (target : Z) (idx : nat) : nat :=\n  match xs with\n  | nil => idx\n  | x :: xs' =>\n      if Z.leb target x then idx\n      else searchInsertAcc xs' target (S idx)\n  end.",
                "code": "(* Start the search from index 0 *)\n  searchInsertAcc xs target 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* xs is strictly increasing (sorted in strictly increasing order, hence no duplicates) *)\n  forall (i j : nat) (xi xj : Z),\n    (i < j)%nat ->\n    List.nth_error xs i = Some xi ->\n    List.nth_error xs j = Some xj ->\n    Z.lt xi xj",
                "postcond_aux": "",
                "postcond": "(* r is a valid insertion/search index that preserves sorted order *)\n  (* 1) Bound on r *)\n  result <= List.length xs /\\\n  (* 2) All elements strictly before r are < target *)\n  (forall (k : nat) (y : Z),\n      (k < result)%nat ->\n      List.nth_error xs k = Some y ->\n      Z.lt y target) /\\\n  (* 3) If there is an element at r, it is >= target *)\n  (forall (y : Z),\n      List.nth_error xs result = Some y ->\n      Z.le target y) /\\\n  (* 4) All elements strictly after r are > target *)\n  (forall (k : nat) (y : Z),\n      (result < k)%nat ->\n      List.nth_error xs k = Some y ->\n      Z.lt target y)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_69": {
          "data_id": "verina_basic_69",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: recursively scan the list carrying the current index.\n   It returns the first index n where the element equals e.\n   The recursion is structurally decreasing on the list argument [lst]. *)\nFixpoint find_index (e : Z) (lst : list Z) (n : nat) : nat :=\n  match lst with\n  | nil => n (* By precondition, this case won't be reached when called with n = 0 on a. *)\n  | x :: xs =>\n      if Z.eqb x e then n\n      else find_index e xs (S n)\n  end.",
                "code": "(* Start searching from index 0 *)\n  find_index e a 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "List.In e a",
                "postcond_aux": "",
                "postcond": "exists (l1 l2 : list Z),\n    a = l1 ++ e :: l2 /\\\n    result = length l1 /\\\n    (forall x : Z, List.In x l1 -> x <> e)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_70": {
          "data_id": "verina_basic_70",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: traverses the list from left to right, carrying the current index i.\n   Returns the index of the first element satisfying P.\n   If no element satisfies P, returns i (this case is ruled out by the precondition). *)\nFixpoint find_first_from (l : list Z) (i : nat) (P : Z -> bool) : nat :=\n  match l with\n  | nil => i\n  | x :: xs =>\n      if P x\n      then i\n      else find_first_from xs (S i) P\n  end.",
                "code": "(* Start searching from index 0 *)\n  find_first_from a 0 P",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "exists i : nat, i < length a /\\ P (nth i a 0%Z) = true",
                "postcond_aux": "",
                "postcond": "result < length a /\\\n  P (nth result a 0%Z) = true /\\\n  (forall j : nat, j < result -> P (nth j a 0%Z) = false)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_70": {
          "data_id": "verina_advanced_70",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: compute the length of a list as a Z *)\nFixpoint lengthZ (l : list Z) : Z :=\n  match l with\n  | [] => 0\n  | _ :: t => 1 + lengthZ t\n  end.\n\n(* Helper: find the index (0-based) of a given value x in list l, returning an option Z *)\nFixpoint index_of (x : Z) (l : list Z) (i : Z) : option Z :=\n  match l with\n  | [] => None\n  | y :: ys =>\n      if Z.eqb x y then Some i\n      else index_of x ys (i + 1)\n  end.\n\n(* Helper: extract value from option with a default (used safely under precondition) *)\nDefinition fromOptionZ (o : option Z) (d : Z) : Z :=\n  match o with\n  | Some z => z\n  | None => d\n  end.",
                "code": "(* Compute n = length(nums) as Z *)\n  let n := lengthZ nums in\n  (* Trivial cases: if length <= 1, already semi-ordered, 0 swaps *)\n  if Z.leb n 1 then 0\n  else\n    (* Positions (0-based) of 1 and n in the permutation *)\n    let pos1 := fromOptionZ (index_of 1 nums 0) 0 in\n    let posn := fromOptionZ (index_of n nums 0) 0 in\n    (* Swaps to bring 1 to front plus swaps to bring n to back *)\n    let moves := pos1 + ((n - 1) - posn) in\n    (* If 1 is to the right of n, they cross once, subtract 1 *)\n    if Z.ltb posn pos1 then moves - 1 else moves",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* nums is a permutation of [1..length nums] and length at least 1 *)\n  (1 <= Z.of_nat (List.length nums)) /\\\n  NoDup nums /\\\n  (forall x : Z, List.In x nums <-> (1 <= x /\\ x <= Z.of_nat (List.length nums)))",
                "postcond_aux": "",
                "postcond": "(* Let len = length nums, i = index of 1, j = index of n (= len).\n     The minimal adjacent swaps needed to make the array semi-ordered is:\n       i + (len - 1 - j)  if i <= j\n       i + (len - 1 - j) - 1  if i > j\n     where indices are 0-based. *)\n  exists (i j : nat),\n    i < List.length nums /\\\n    j < List.length nums /\\\n    List.nth i nums 0 = 1 /\\\n    List.nth j nums 0 = Z.of_nat (List.length nums) /\\\n    (\n      (Z.of_nat i <= Z.of_nat j /\\\n       result = Z.of_nat i + Z.of_nat (List.length nums - S j)) \\/\n      (Z.of_nat i > Z.of_nat j /\\\n       result = Z.of_nat i + Z.of_nat (List.length nums - S j) - 1)\n    )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_71": {
          "data_id": "verina_advanced_71",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Basic boolean comparisons on nat *)\nFixpoint lt_natb (a b : nat) : bool :=\n  match a, b with\n  | O, O => false\n  | O, S _ => true\n  | S _, O => false\n  | S a', S b' => lt_natb a' b'\n  end.\n\nFixpoint eq_natb (a b : nat) : bool :=\n  match a, b with\n  | O, O => true\n  | S a', S b' => eq_natb a' b'\n  | _, _ => false\n  end.\n\n(* ASCII and string helpers *)\nDefinition ascii_lt (a b : ascii) : bool :=\n  lt_natb (Ascii.nat_of_ascii a) (Ascii.nat_of_ascii b).\n\nFixpoint string_lt (a b : string) : bool :=\n  match a, b with\n  | String.EmptyString, String.EmptyString => false\n  | String.EmptyString, _ => true\n  | _, String.EmptyString => false\n  | String.String ca sa, String.String cb sb =>\n      if eq_natb (Ascii.nat_of_ascii ca) (Ascii.nat_of_ascii cb)\n      then string_lt sa sb\n      else ascii_lt ca cb\n  end.\n\nFixpoint str_drop (n : nat) (s : string) : string :=\n  match n, s with\n  | O, _ => s\n  | S n', String.String _ t => str_drop n' t\n  | S _, String.EmptyString => String.EmptyString\n  end.\n\nFixpoint str_take (n : nat) (s : string) : string :=\n  match n, s with\n  | O, _ => String.EmptyString\n  | S n', String.String c t => String.String c (str_take n' t)\n  | S _, String.EmptyString => String.EmptyString\n  end.\n\nDefinition substr (s : string) (start len : nat) : string :=\n  str_take len (str_drop start s).\n\n(* Collect positions (0-based) of '1' in the string *)\nFixpoint positions_of_ones (s : string) (i : nat) : list nat :=\n  match s with\n  | String.EmptyString => nil\n  | String.String ch rest =>\n      let tail := positions_of_ones rest (S i) in\n      if Ascii.eqb ch (Ascii.ascii_of_nat 49) (* '1' = ASCII 49 *)\n      then i :: tail\n      else tail\n  end.\n\n(* List helpers *)\nFixpoint drop_list {A} (n : nat) (l : list A) : list A :=\n  match n, l with\n  | O, _ => l\n  | S n', _ :: t => drop_list n' t\n  | S _, nil => nil\n  end.\n\nFixpoint zip_nat (l1 l2 : list nat) : list (nat * nat) :=\n  match l1, l2 with\n  | x :: xs, y :: ys => (x, y) :: zip_nat xs ys\n  | _, _ => nil\n  end.\n\n(* Fold over (l,r) pairs to find the best (shortest, then lexicographically smallest) substring *)\nFixpoint fold_pairs_best (s : string) (ps : list (nat * nat)) (best : option (nat * string)) : option (nat * string) :=\n  match ps with\n  | nil => best\n  | (l, r) :: t =>\n      let len := S (r - l) in\n      let ss := substr s l len in\n      let best' :=\n        match best with\n        | None => Some (len, ss)\n        | Some (bl, bs) =>\n            if lt_natb len bl then Some (len, ss)\n            else if eq_natb len bl then\n                   if string_lt ss bs then Some (len, ss) else Some (bl, bs)\n                 else Some (bl, bs)\n        end in\n      fold_pairs_best s t best'\n  end.",
                "code": "match k with\n  | O => String.EmptyString\n  | S k' =>\n      let pos := positions_of_ones s 0 in\n      let pairs := zip_nat pos (drop_list k' pos) in\n      match fold_pairs_best s pairs None with\n      | Some (_, res) => res\n      | None => String.EmptyString\n      end\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Count occurrences of the ASCII character '1' (code 49) in a string *)\nDefinition ascii_1 : Ascii.ascii := Ascii.ascii_of_nat 49.\n\nFixpoint count_ones (s : string) : nat :=\n  match s with\n  | EmptyString => 0\n  | String.String c rest =>\n      (if Ascii.eqb c ascii_1 then 1 else 0) + count_ones rest\n  end.\n\n(* Contiguous substring relation: t is a substring of s if s = p ++ t ++ q *)\nDefinition substring (t s : string) : Prop :=\n  exists p q, s = String.append p (String.append t q).\n\n(* Lexicographic strict order on strings using ASCII code order *)\nFixpoint lex_lt (x y : string) : Prop :=\n  match x, y with\n  | EmptyString, EmptyString => False\n  | EmptyString, _ => True\n  | _, EmptyString => False\n  | String.String c1 s1, String.String c2 s2 =>\n      if Nat.ltb (Ascii.nat_of_ascii c1) (Ascii.nat_of_ascii c2) then True\n      else if Nat.ltb (Ascii.nat_of_ascii c2) (Ascii.nat_of_ascii c1) then False\n      else lex_lt s1 s2\n  end.\n\n(* Candidate substring: a substring of s containing exactly k ones *)\nDefinition is_candidate (s : string) (k : nat) (t : string) : Prop :=\n  substring t s /\\ count_ones t = k.\n\n(* Minimality: shortest candidate; among ties, lexicographically smallest *)\nDefinition minimal_result (s : string) (k : nat) (r : string) : Prop :=\n  is_candidate s k r /\\\n  (forall t : string, is_candidate s k t -> String.length r <= String.length t) /\\\n  (forall t : string, is_candidate s k t ->\n                      String.length t = String.length r ->\n                      ~ lex_lt t r).",
                "postcond": "(* If there exists a substring with exactly k ones, result is a shortest such substring,\n     and in case of ties (same minimal length), result is lexicographically smallest.\n     If no such substring exists, result is the empty string. *)\n  ((exists t : string, is_candidate s k t) -> minimal_result s k result)\n/\\ ((forall t : string, ~ is_candidate s k t) -> result = EmptyString)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_71": {
          "data_id": "verina_basic_71",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Auxiliary function computing the longest common prefix of two lists of ascii characters *)\nFixpoint lcp_aux (l1 l2 : list ascii) {struct l1} : list ascii :=\n  match l1, l2 with\n  | c1 :: t1, c2 :: t2 =>\n      if Ascii.eqb c1 c2 then c1 :: lcp_aux t1 t2 else []\n  | _, _ => []\n  end.",
                "code": "(* Use the auxiliary recursive function to compute the result *)\n  lcp_aux str1 str2",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* result is a common prefix of str1 and str2, and is of maximal length among all common prefixes *)\n  (exists t1, str1 = result ++ t1) /\\\n  (exists t2, str2 = result ++ t2) /\\\n  (forall p,\n      ((exists t1, str1 = p ++ t1) /\\ (exists t2, str2 = p ++ t2)) ->\n      length p <= length result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_72": {
          "data_id": "verina_advanced_72",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: boolean divisibility test by repeated subtraction.\n   dividesb d n = true iff d > 0 and d divides n; by convention dividesb d 0 = true for d > 0.\n   The recursion decreases on n when n >= d (since d >= 1 in that branch). *)\nFixpoint dividesb (d n : nat) : bool :=\n  match d with\n  | 0 => false (* 0 does not divide anything in this boolean convention *)\n  | S _ =>\n    match n with\n    | 0 => true\n    | _ =>\n      if Nat.leb d n then dividesb d (Nat.sub n d) else false\n    end\n  end.",
                "code": "(* Check primes less than 10 in increasing order: 2, 3, 5, 7 *)\n  if dividesb 2 n then 2\n  else if dividesb 3 n then 3\n  else if dividesb 5 n then 5\n  else if dividesb 7 n then 7\n  else 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "((result = 0) <->\n    ~ (exists p, (p = 2 \\/ p = 3 \\/ p = 5 \\/ p = 7) /\\ exists k, n = p * k))\n  /\\\n  (result <> 0 ->\n     (result = 2 \\/ result = 3 \\/ result = 5 \\/ result = 7)\n     /\\ (exists k, n = result * k)\n     /\\ (forall p, (p = 2 \\/ p = 3 \\/ p = 5 \\/ p = 7) ->\n            (exists k, n = p * k) -> result <= p)\n  )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_72": {
          "data_id": "verina_basic_72",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Append an element to the end of a list using structural recursion on the list *)\nFixpoint append_to_end (l : list Z) (b : Z) : list Z :=\n  match l with\n  | nil => b :: nil\n  | x :: xs => x :: append_to_end xs b\n  end.",
                "code": "append_to_end a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = a ++ [b]",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_73": {
          "data_id": "verina_advanced_73",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function that traverses the list with an expected next natural number.\n   - expected starts at 0\n   - if the head equals expected, we move to the tail and increment expected\n   - otherwise, expected is the smallest missing number *)\nFixpoint smallestMissing_aux (l : list nat) (expected : nat) {struct l} : nat :=\n  match l with\n  | nil => expected\n  | h :: t =>\n      if Nat.eqb h expected then\n        smallestMissing_aux t (S expected)\n      else\n        expected\n  end.",
                "code": "(* Start searching with expected = 0 *)\n  smallestMissing_aux l 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(~ List.In result l) /\\ (forall n, n < result -> List.In n l)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_73": {
          "data_id": "verina_basic_73",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Check if an ascii character is the '?' wildcard (ASCII code 63 = 0b00111111). *)\nDefinition is_qmark (c : ascii) : bool :=\n  match c with\n  | Ascii.Ascii true true true true true true false false => true\n  | _ => false\n  end.\n\n(* Boolean equality on ascii characters by comparing all 8 bits. *)\nDefinition ascii_eqb (c1 c2 : ascii) : bool :=\n  match c1, c2 with\n  | Ascii.Ascii a0 a1 a2 a3 a4 a5 a6 a7,\n    Ascii.Ascii b0 b1 b2 b3 b4 b5 b6 b7 =>\n      andb (Bool.eqb a0 b0)\n      (andb (Bool.eqb a1 b1)\n      (andb (Bool.eqb a2 b2)\n      (andb (Bool.eqb a3 b3)\n      (andb (Bool.eqb a4 b4)\n      (andb (Bool.eqb a5 b5)\n      (andb (Bool.eqb a6 b6) (Bool.eqb a7 b7)))))))\n  end.\n\n(* Recursive matcher: allows '?' in pattern to match any character; requires lengths to align. *)\nFixpoint match_wildcard (s p : string) : bool :=\n  match s, p with\n  | EmptyString, EmptyString => true\n  | String a s', String b p' =>\n      if is_qmark b\n      then match_wildcard s' p'\n      else andb (ascii_eqb a b) (match_wildcard s' p')\n  | _, _ => false\n  end.",
                "code": "match_wildcard s p",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Predicate recognizing the wildcard '?' character by its ASCII code (63). *)\nDefinition is_qmark (c : ascii) : Prop :=\n  Ascii.nat_of_ascii c = 63.\n\n(* Structural definition of pattern matching:\n   - Both strings must have the same length (enforced by the structure).\n   - At each position, either characters are equal or the pattern has '?'. *)\nFixpoint pat_match (s p : string) : Prop :=\n  match s, p with\n  | EmptyString, EmptyString => True\n  | String cs ss, String cp pp =>\n      (is_qmark cp \\/ cp = cs) /\\ pat_match ss pp\n  | _, _ => False\n  end.",
                "postcond": "result = true <-> pat_match s p",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_74": {
          "data_id": "verina_basic_74",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to compute the maximum of two integers using Z.leb *)\nDefinition Zmaxb (x y : Z) : Z :=\n  if Z.leb x y then y else x.\n\n(* Tail-recursive helper to compute the maximum of a list given an accumulator *)\nFixpoint list_max_from (acc : Z) (l : list Z) : Z :=\n  match l with\n  | [] => acc\n  | h :: t => list_max_from (Zmaxb acc h) t\n  end.",
                "code": "(* Since the precondition guarantees that [a] is non-empty, we safely\n     initialize the accumulator with the head and fold over the tail. *)\n  match a with\n  | [] => 0 (* Unused case due to precondition; provided for completeness *)\n  | h :: t => list_max_from h t\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "a <> []",
                "postcond_aux": "",
                "postcond": "(forall x, In x a -> x <= result) /\\ In result a",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_74": {
          "data_id": "verina_advanced_74",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean membership check for nat in a list *)\nFixpoint mem_nat (x : nat) (l : list nat) : bool :=\n  match l with\n  | [] => false\n  | y :: ys => if Nat.eqb x y then true else mem_nat x ys\n  end.\n\n(* Sum of squares of distinct counts for all prefixes of a given suffix.\n   seen: list of distinct elements seen so far\n   d: current count of distinct elements *)\nFixpoint sum_prefix_squares (s : list nat) (seen : list nat) (d : nat) : nat :=\n  match s with\n  | [] => 0\n  | x :: xs =>\n      let m := mem_nat x seen in\n      let d' := if m then d else S d in\n      let seen' := if m then seen else x :: seen in\n      d' * d' + sum_prefix_squares xs seen' d'\n  end.\n\n(* Sum over all starting positions: for each suffix l', add the sum over its prefixes *)\nFixpoint sum_all_subarrays (l : list nat) : nat :=\n  match l with\n  | [] => 0\n  | _ :: xs as l' => sum_prefix_squares l' [] 0 + sum_all_subarrays xs\n  end.",
                "code": "sum_all_subarrays nums",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Boolean equality on nat *)\nFixpoint nat_beq (x y : nat) : bool :=\n  match x, y with\n  | O, O => true\n  | S x', S y' => nat_beq x' y'\n  | _, _ => false\n  end.\n\n(* Boolean membership using nat_beq *)\nFixpoint inb (l : list nat) (x : nat) : bool :=\n  match l with\n  | [] => false\n  | y :: ys => if nat_beq x y then true else inb ys x\n  end.\n\n(* Count of distinct elements using an accumulator of seen elements *)\nFixpoint distinct_count_aux (l acc : list nat) : nat :=\n  match l with\n  | [] => length acc\n  | x :: xs => if inb acc x then distinct_count_aux xs acc\n               else distinct_count_aux xs (x :: acc)\n  end.\n\nDefinition distinct_count (l : list nat) : nat :=\n  distinct_count_aux l [].\n\n(* Square function *)\nDefinition square (n : nat) : nat := n * n.\n\n(* Contiguous subarray: take [len] elements after skipping [i] *)\nDefinition subarray (l : list nat) (i len : nat) : list nat :=\n  firstn len (skipn i l).\n\n(* Summation over 0,1,...,n-1 *)\nFixpoint sum_upto (n : nat) (f : nat -> nat) : nat :=\n  match n with\n  | 0 => 0\n  | S n' => sum_upto n' f + f n'\n  end.\n\n(* Total sum over all subarrays:\n   For each start index i in [0, length l),\n   for each length k' in [0, length l - i), consider subarray of length S k'. *)\nDefinition total_sum_squared_distinct (l : list nat) : nat :=\n  sum_upto (length l) (fun i =>\n    sum_upto (length l - i) (fun k' =>\n      square (distinct_count (subarray l i (S k'))))).",
                "postcond": "result = total_sum_squared_distinct nums",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_75": {
          "data_id": "verina_advanced_75",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Kadane's algorithm helper: iteratively compute the maximum subarray sum *)\nFixpoint kadane_aux (l : list Z) (cur maxsofar : Z) : Z :=\n  match l with\n  | nil => maxsofar\n  | x :: xs =>\n      let cur' := Z.max (cur + x) x in\n      let max' := Z.max maxsofar cur' in\n      kadane_aux xs cur' max'\n  end.",
                "code": "(* Use the first element to initialize current and overall maximums *)\n  match sequence with\n  | nil => 0 (* Should not happen due to precondition, but provided for totality *)\n  | x :: xs => kadane_aux xs x x\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* The sequence must be non-empty to initialize Kadane's algorithm. *)\n  sequence <> []",
                "postcond_aux": "(* Sum of a list of integers (Z) *)\nFixpoint sumZ (l : list Z) : Z :=\n  match l with\n  | nil => 0\n  | x :: xs => x + sumZ xs\n  end.\n\n(* mid is a contiguous subarray of seq iff seq = left ++ mid ++ right *)\nDefinition is_subarray (mid seq : list Z) : Prop :=\n  exists left right, seq = left ++ mid ++ right.",
                "postcond": "(* result is the maximum sum over all non-empty contiguous subarrays *)\n  exists mid,\n    is_subarray mid sequence /\\\n    mid <> [] /\\\n    result = sumZ mid /\\\n    (forall mid', is_subarray mid' sequence -> mid' <> [] -> sumZ mid' <= result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_75": {
          "data_id": "verina_basic_75",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper recursive function to compute the minimum of a list, given a current minimum.\n   It traverses the list once, updating the current minimum when a smaller element is found. *)\nFixpoint loop_min (cur : Z) (l : list Z) : Z :=\n  match l with\n  | nil => cur\n  | x :: xs =>\n      let new_min := if Z.leb x cur then x else cur in\n      loop_min new_min xs\n  end.",
                "code": "(* By precondition, a is non-empty. We still pattern match to keep totality. *)\n  match a with\n  | nil => 0 (* Unused due to precondition; placeholder to satisfy totality. *)\n  | x :: xs => loop_min x xs\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "a <> []",
                "postcond_aux": "",
                "postcond": "List.In result a /\\ Forall (fun y : Z => result <= y) a",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_76": {
          "data_id": "verina_basic_76",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Return the smaller of x and y using Z.leb (<=?) *)\n  if x <=? y then x else y",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(Z.le x y -> result = x) /\\ (Z.gt x y -> result = y)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_76": {
          "data_id": "verina_advanced_76",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Increment the count for key x in the association list m, or insert with count 1 if absent *)\nFixpoint inc_count (x : Z) (m : list (Z * nat)) : list (Z * nat) :=\n  match m with\n  | [] => [(x, 1%nat)]\n  | (y, c) :: t =>\n      if Z.eqb x y then (y, S c) :: t\n      else (y, c) :: inc_count x t\n  end.\n\n(* Build a frequency map from a list of Zs into an association list Z * nat *)\nFixpoint build_freq (l : list Z) (m : list (Z * nat)) : list (Z * nat) :=\n  match l with\n  | [] => m\n  | x :: xs => build_freq xs (inc_count x m)\n  end.\n\nDefinition freq_of_list (l : list Z) : list (Z * nat) :=\n  build_freq l [].\n\n(* Remove a key from the association list *)\nFixpoint remove_key (x : Z) (m : list (Z * nat)) : list (Z * nat) :=\n  match m with\n  | [] => []\n  | (y, c) :: t =>\n      if Z.eqb x y then t\n      else (y, c) :: remove_key x t\n  end.\n\n(* Find the pair with maximum frequency (by snd) *)\nFixpoint max_pair (m : list (Z * nat)) : option (Z * nat) :=\n  match m with\n  | [] => None\n  | p :: t =>\n      let r := max_pair t in\n      match r with\n      | None => Some p\n      | Some (z', c') =>\n          let '(z, c) := p in\n          if Nat.leb c' c then Some (z, c) else Some (z', c')\n      end\n  end.\n\n(* Pick top k keys by repeatedly selecting the maximum and removing it *)\nFixpoint pick_top_k (m : list (Z * nat)) (k : nat) : list Z :=\n  match k with\n  | 0%nat => []\n  | S k' =>\n      match max_pair m with\n      | None => [] (* Should not happen if precondition ensures k <= number of distinct elements *)\n      | Some (z, _) => z :: pick_top_k (remove_key z m) k'\n      end\n  end.",
                "code": "let m := freq_of_list nums in\n  pick_top_k m k",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "exists d : list Z,\n    NoDup d /\\\n    (forall x : Z, In x nums <-> In x d) /\\\n    (k <= length d)%nat",
                "postcond_aux": "Definition freq (l : list Z) (x : Z) : nat := count_occ Z.eq_dec l x.",
                "postcond": "(* result has exactly k elements, all distinct and drawn from nums *)\n  length result = k /\\\n  NoDup result /\\\n  (forall x : Z, In x result -> In x nums) /\\\n  (* non-increasing order of frequencies along result *)\n  (forall (i j : nat),\n      (i < length result)%nat ->\n      (j < length result)%nat ->\n      (i < j)%nat ->\n      freq nums (List.nth i result 0%Z) >= freq nums (List.nth j result 0%Z)) /\\\n  (* maximality: no element outside result has strictly greater frequency\n     than the last element's frequency; when k = 0 this holds trivially *)\n  (forall z : Z,\n      In z nums -> ~ In z result ->\n      (k = 0%nat \\/ freq nums z <= freq nums (List.nth (Nat.pred k) result 0%Z)))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_77": {
          "data_id": "verina_advanced_77",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Compute the running maximum from the left. For each position, we store the\n   maximum value seen up to and including that position. *)\nFixpoint prefix_max_list (cur : nat) (l : list nat) : list nat :=\n  match l with\n  | [] => []\n  | x :: xs =>\n      let m := Nat.max cur x in\n      m :: prefix_max_list m xs\n  end.\n\n(* Left maxima for the original list. *)\nDefinition left_max_list (l : list nat) : list nat :=\n  prefix_max_list 0 l.\n\n(* Right maxima for the original list: compute prefix maxima on the reversed list,\n   then reverse back to align indices. *)\nDefinition right_max_list (l : list nat) : list nat :=\n  rev (prefix_max_list 0 (rev l)).\n\n(* Sum the trapped water at each index using the precomputed left and right maxima.\n   Water at index i is min(left_max[i], right_max[i]) - height[i], saturated at 0\n   due to nat subtraction semantics. *)\nFixpoint sum_water_lists (lm rm h : list nat) : nat :=\n  match lm, rm, h with\n  | l :: ls, r :: rs, x :: xs =>\n      (Nat.min l r - x) + sum_water_lists ls rs xs\n  | _, _, _ => 0\n  end.",
                "code": "let lm := left_max_list height in\n  let rm := right_max_list height in\n  sum_water_lists lm rm height",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Maximum of a list of nats, defaulting to 0 on empty lists *)\nDefinition max_list (l : list nat) : nat :=\n  fold_left Nat.max l 0.\n\n(* Water trapped at index i *)\nDefinition water_at (height : list nat) (i : nat) : nat :=\n  let left_max  := max_list (firstn (S i) height) in\n  let right_max := max_list (skipn i height) in\n  let hi        := nth i height 0 in\n  Nat.sub (Nat.min left_max right_max) hi.\n\n(* Total trapped water across all indices *)\nDefinition trapped_water (height : list nat) : nat :=\n  fold_right Nat.add 0 (map (water_at height) (seq 0 (length height))).",
                "postcond": "result = trapped_water height",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_77": {
          "data_id": "verina_basic_77",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Replace the element at index n in a list with a new value x.\n   If n is out of bounds, returns the list with truncation at that point (precondition ensures validity). *)\nFixpoint replace_nth {A : Type} (l : list A) (n : nat) (x : A) : list A :=\n  match l, n with\n  | [], _ => []\n  | _ :: xs, 0 => x :: xs\n  | y :: ys, S n' => y :: replace_nth ys n' x\n  end.\n\n(* Modify a 2D list: only update the element at (i1, i2) to val, leaving all others unchanged. *)\nFixpoint modify_2D (arr : list (list nat)) (i1 i2 val : nat) : list (list nat) :=\n  match arr, i1 with\n  | [], _ => []\n  | row :: rows, 0 => replace_nth row i2 val :: rows\n  | row :: rows, S i1' => row :: modify_2D rows i1' i2 val\n  end.",
                "code": "(* Use the helper to perform the targeted update *)\n  modify_2D arr index1 index2 val",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* index1 must be a valid index of the outer list,\n     and index2 must be a valid index of the corresponding inner list *)\n  exists (inner : list nat),\n    nth_error arr index1 = Some inner /\\\n    index2 < length inner",
                "postcond_aux": "",
                "postcond": "(* All outer arrays remain the same except possibly at index1 *)\n  (forall i, i <> index1 -> nth_error result i = nth_error arr i)\n  /\\\n  (* At index1, only the element at index2 is replaced with val, others unchanged *)\n  exists (inner inner' : list nat),\n    nth_error arr index1 = Some inner /\\\n    nth_error result index1 = Some inner' /\\\n    (* All positions except index2 are identical *)\n    (forall j, j <> index2 -> nth_error inner' j = nth_error inner j) /\\\n    (* The position index2 is set to val *)\n    nth_error inner' index2 = Some val",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_78": {
          "data_id": "verina_basic_78",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(x + y, x - y)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "fst result = x + y /\\ snd result = x - y",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_78": {
          "data_id": "verina_advanced_78",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to search for a complement in the tail of the list.\n   Given a fixed x and target, traverse ys with current index j,\n   returning the first j such that x + y = target, if any. *)\nFixpoint find_in_rest (x target : Z) (ys : list Z) (j : nat) : option nat :=\n  match ys with\n  | nil => None\n  | y :: ys' =>\n      if Z.eqb (x + y) target then Some j\n      else find_in_rest x target ys' (S j)\n  end.\n\n(* Outer search: iterate over the list with index i, and for each element\n   search for its complement in the remainder of the list. *)\nFixpoint two_sum_from (xs : list Z) (i : nat) (target : Z) : option (nat * nat) :=\n  match xs with\n  | nil => None\n  | x :: ys =>\n      match find_in_rest x target ys (S i) with\n      | Some j => Some (i, j)\n      | None => two_sum_from ys (S i) target\n      end\n  end.",
                "code": "(* Use the helper; precondition guarantees existence, but we add a default. *)\n  match two_sum_from nums 0%nat target with\n  | Some p => p\n  | None => (0%nat, 0%nat)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* There exists exactly one ordered pair of distinct indices (i < j)\n     within bounds whose elements sum to target. *)\n  exists (i j : nat),\n    i < j /\\\n    i < List.length nums /\\\n    j < List.length nums /\\\n    List.nth i nums 0 + List.nth j nums 0 = target /\\\n    (* Uniqueness of the solution among ordered pairs *)\n    (forall (i' j' : nat),\n        i' < j' /\\\n        i' < List.length nums /\\\n        j' < List.length nums /\\\n        List.nth i' nums 0 + List.nth j' nums 0 = target ->\n        i' = i /\\ j' = j)",
                "postcond_aux": "",
                "postcond": "(* The returned indices form an ordered in-bounds pair summing to target,\n     and (redundantly) are the unique such pair. *)\n  let i := fst result in\n  let j := snd result in\n  i < j /\\\n  i < List.length nums /\\\n  j < List.length nums /\\\n  List.nth i nums 0 + List.nth j nums 0 = target /\\\n  (forall (i' j' : nat),\n      i' < j' /\\\n      i' < List.length nums /\\\n      j' < List.length nums /\\\n      List.nth i' nums 0 + List.nth j' nums 0 = target ->\n      i' = i /\\ j' = j)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_79": {
          "data_id": "verina_basic_79",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Compute the maximum among the first [x] elements of the list.\n   If [firstn x a] is empty (should not happen under precondition 1 â‰¤ x),\n   we return 0 as a safe default. *)\nDefinition max_firstn (l : list Z) (x : nat) : Z :=\n  match firstn x l with\n  | nil => 0%Z\n  | h :: t => fold_left Z.max t h\n  end.\n\n(* Find the first index (absolute, counted from the original list start)\n   at or after [base] such that the element is strictly greater than [m].\n   We scan the provided list [l], which is typically [skipn base a].\n   Returns [Some idx] when found, otherwise [None]. *)\nFixpoint find_first_gt_from (l : list Z) (base : nat) (m : Z) : option nat :=\n  match l with\n  | nil => None\n  | h :: t =>\n      if Z.ltb m h\n      then Some base\n      else find_first_gt_from t (S base) m\n  end.",
                "code": "let m := max_firstn a x in\n  let suffix := skipn x a in\n  match find_first_gt_from suffix x m with\n  | Some p => (m, p)\n  | None => (m, Nat.pred (length a))\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(1 <= x)%nat /\\ (x < List.length a)%nat",
                "postcond_aux": "",
                "postcond": "let m := fst result in\n  let p := snd result in\n  (* m is the maximum among the first x elements (indices 0..x-1) *)\n  (exists j, (j < x)%nat /\\ List.nth j a 0 = m)\n  /\\\n  (forall i, (i < x)%nat -> Z.le (List.nth i a 0) m)\n  /\\\n  (* p is an index with x <= p < length a *)\n  (x <= p)%nat /\\ (p < List.length a)%nat\n  /\\\n  (* If there exists an element from index x onward that is strictly greater than m,\n     then p is the first such index (a[p] > m and all earlier indices q in [x, p) satisfy a[q] <= m). *)\n  ( (exists i, (x <= i)%nat /\\ (i < List.length a)%nat /\\ Z.lt m (List.nth i a 0)) ->\n      Z.lt m (List.nth p a 0)\n      /\\ (forall q, (x <= q)%nat -> (q < p)%nat -> Z.le (List.nth q a 0) m)\n    )\n  /\\\n  (* Otherwise, p is the last index of the array. *)\n  ( ~(exists i, (x <= i)%nat /\\ (i < List.length a)%nat /\\ Z.lt m (List.nth i a 0)) ->\n      p = (List.length a - 1)%nat\n    )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_79": {
          "data_id": "verina_advanced_79",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Search the tail list ys for the first index j (absolute) such that x + y = target.\n   The search starts from absolute index j and proceeds forward, ensuring lexicographic order. *)\nFixpoint find_match_from (x : Z) (target : Z) (ys : list Z) (j : nat) : option nat :=\n  match ys with\n  | nil => None\n  | y :: ys' =>\n      if Z.eqb (x + y) target\n      then Some j\n      else find_match_from x target ys' (S j)\n  end.\n\n(* Iterate over the list with current absolute index i.\n   For each head x, search its tail for the first matching partner producing the smallest j > i.\n   If none is found, continue with the tail and index S i, ensuring lexicographic minimality. *)\nFixpoint twoSum_impl (nums : list Z) (i : nat) (target : Z) : option (nat * nat) :=\n  match nums with\n  | nil => None\n  | x :: xs =>\n      match find_match_from x target xs (S i) with\n      | Some j => Some (i, j)\n      | None => twoSum_impl xs (S i) target\n      end\n  end.",
                "code": "twoSum_impl nums 0%nat target",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "match result with\n  | None =>\n      (* No valid pair exists *)\n      forall i j xi xj,\n        List.nth_error nums i = Some xi ->\n        List.nth_error nums j = Some xj ->\n        (i < j)%nat ->\n        xi + xj = target ->\n        False\n  | Some (i, j) =>\n      (* Returned pair is in-bounds, sums to target, and is lexicographically minimal *)\n      exists xi xj,\n        List.nth_error nums i = Some xi /\\\n        List.nth_error nums j = Some xj /\\\n        (i < j)%nat /\\\n        xi + xj = target /\\\n        (* i is minimal among all valid pairs *)\n        (forall i' j' xi' xj',\n            List.nth_error nums i' = Some xi' ->\n            List.nth_error nums j' = Some xj' ->\n            (i' < j')%nat ->\n            xi' + xj' = target ->\n            (i <= i')%nat) /\\\n        (* Among pairs with the same i, j is minimal *)\n        (forall j' xj',\n            List.nth_error nums j' = Some xj' ->\n            (i < j')%nat ->\n            xi + xj' = target ->\n            (j <= j')%nat)\n  end",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_80": {
          "data_id": "verina_advanced_80",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: search the tail for a complement to x, tracking the index j *)\nFixpoint find_with (x target : Z) (l : list Z) (j : nat) : option nat :=\n  match l with\n  | nil => None\n  | y :: ys =>\n      if Z.eqb (x + y) target\n      then Some j\n      else find_with x target ys (S j)\n  end.\n\n(* Main search over the list, tracking the current index i *)\nFixpoint find_pairs (l : list Z) (target : Z) (i : nat) : option (nat * nat) :=\n  match l with\n  | nil => None\n  | x :: xs =>\n      match find_with x target xs (S i) with\n      | Some j => Some (i, j)  (* i < j by construction, so indices are sorted *)\n      | None => find_pairs xs target (S i)\n      end\n  end.",
                "code": "(* Use the helpers to locate the pair of indices; precondition guarantees existence *)\n  match find_pairs nums target 0%nat with\n  | Some (i, j) => [i; j]\n  | None => [] (* Fallback; should not occur under the given precondition *)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "exists (i j : nat),\n    Nat.lt i j /\\\n    Nat.lt i (length nums) /\\\n    Nat.lt j (length nums) /\\\n    List.nth i nums 0%Z + List.nth j nums 0%Z = target /\\\n    result = [i; j]",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_80": {
          "data_id": "verina_basic_80",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Count occurrences of a key in a list of integers *)\nFixpoint count_occ_z (l : list Z) (k : Z) : nat :=\n  match l with\n  | nil => 0\n  | x :: xs => if Z.eqb x k then S (count_occ_z xs k) else count_occ_z xs k\n  end.",
                "code": "(* True iff the key appears exactly once *)\n  let n := count_occ_z a key in\n  match n with\n  | S O => true    (* exactly one occurrence *)\n  | _ => false\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(* The result is true exactly when the key occurs exactly once in the list. *)\n  (result = true <-> count_occ Z.eq_dec a key = 1%nat)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_81": {
          "data_id": "verina_advanced_81",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Insert an element into a sorted, duplicate-free list, preserving order and uniqueness *)\nFixpoint insert_unique (x : Z) (l : list Z) : list Z :=\n  match l with\n  | nil => x :: nil\n  | h :: t =>\n      if Z.ltb x h then x :: l\n      else if Z.eqb x h then l\n      else h :: insert_unique x t\n  end.\n\n(* Build a sorted, duplicate-free list by inserting each element *)\nFixpoint uniq_sort (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | h :: t => insert_unique h (uniq_sort t)\n  end.",
                "code": "uniq_sort arr",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "Fixpoint nondecreasing (l : list Z) : Prop :=\n  match l with\n  | [] => True\n  | _ :: [] => True\n  | x :: y :: xs => Z.le x y /\\ nondecreasing (y :: xs)\n  end.",
                "postcond": "NoDup result /\\\n  nondecreasing result /\\\n  (forall x : Z, List.In x result <-> List.In x arr)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_81": {
          "data_id": "verina_basic_81",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Return (remainder, quotient) as a pair of integers *)\n  match y with\n  | O => (Z.of_nat x, 0%Z)\n  | S y' =>\n      let zx := Z.of_nat x in\n      let zy := Z.of_nat (S y') in\n      (Z.modulo zx zy, Z.div zx zy)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(y = 0%nat -> result = (Z.of_nat x, 0)) /\\\n  (y <> 0%nat ->\n      snd result * Z.of_nat y + fst result = Z.of_nat x /\\\n      0 <= fst result /\\\n      fst result < Z.of_nat y /\\\n      0 <= snd result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_82": {
          "data_id": "verina_basic_82",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_82",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Return the list without its first element.\n     The precondition guarantees that 'a' is non-empty, but we still\n     pattern match exhaustively for completeness. *)\n  match a with\n  | [] => []\n  | _ :: t => t\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_82",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "a <> []",
                "postcond_aux": "",
                "postcond": "exists (x : Z) (tl : list Z), a = x :: tl /\\ result = tl",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_83": {
          "data_id": "verina_basic_83",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_83",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* A simple recursive helper that appends two lists of integers (Z).\n   It traverses the first list and conses its elements in front of the result. *)\nFixpoint concat_aux (a b : list Z) : list Z :=\n  match a with\n  | nil => b\n  | cons x xs => cons x (concat_aux xs b)\n  end.",
                "code": "(* Use the helper to concatenate a and b *)\n  concat_aux a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_83",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = a ++ b",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_84": {
          "data_id": "verina_basic_84",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_84",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function that processes the list recursively.\n   For each element x, if x > k then replace with -1, otherwise keep x. *)\nFixpoint replace_aux (arr : list Z) (k : Z) : list Z :=\n  match arr with\n  | nil => nil\n  | x :: xs =>\n      let y := if Z.ltb k x then (-1)%Z else x in\n      y :: replace_aux xs k\n  end.",
                "code": "(* Use the helper to produce the transformed list *)\n  replace_aux arr k",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_84",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "List.length result = List.length arr /\\\n  forall (i : nat), (i < List.length arr)%nat ->\n    let ai := List.nth i arr 0 in\n    let ri := List.nth i result 0 in\n    (Z.gt ai k -> ri = -1) /\\\n    (Z.le ai k -> ri = ai)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_85": {
          "data_id": "verina_basic_85",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_85",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Tail-recursive helper to reverse a list using an accumulator *)\nFixpoint rev_acc (l : list Z) (acc : list Z) : list Z :=\n  match l with\n  | nil => acc\n  | x :: xs => rev_acc xs (x :: acc)\n  end.",
                "code": "(* Reverse the list by accumulating into an initially empty list *)\n  rev_acc a []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_85",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = rev a",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_86": {
          "data_id": "verina_basic_86",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_86",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper functions to take and drop elements from a list, defined with Fixpoint *)\nFixpoint takeZ (n : nat) (l : list Z) : list Z :=\n  match n, l with\n  | O, _ => []\n  | S n', [] => []\n  | S n', x :: xs => x :: takeZ n' xs\n  end.\n\nFixpoint dropZ (n : nat) (l : list Z) : list Z :=\n  match n, l with\n  | O, _ => l\n  | S n', [] => []\n  | S n', _ :: xs => dropZ n' xs\n  end.",
                "code": "(* If the list is empty, rotation yields an empty list *)\n  match a with\n  | [] => []\n  | _ =>\n      (* Compute rotation offset modulo the list length *)\n      let n := length a in\n      let k := Z.to_nat (offset mod (Z.of_nat n)) in\n      (* Rotate left by k: drop k elements and append the first k elements *)\n      dropZ k a ++ takeZ k a\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_86",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "0 <= offset",
                "postcond_aux": "",
                "postcond": "length result = length a /\\\n  forall i : Z,\n    0 <= i /\\ i < Z.of_nat (length a) ->\n      List.nth (Z.to_nat i) result 0 =\n      List.nth (Z.to_nat ((i + offset) mod (Z.of_nat (length a)))) a 0",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_87": {
          "data_id": "verina_basic_87",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_87",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Compute the minimum of a non-empty list by threading a current minimum. *)\nFixpoint min_list (m : Z) (l : list Z) : Z :=\n  match l with\n  | [] => m\n  | y :: ys =>\n      let m' := if Z.leb y m then y else m in\n      min_list m' ys\n  end.\n\n(* Remove the first occurrence of an element from a list (using Z.eqb for equality). *)\nFixpoint remove_one (x : Z) (l : list Z) : list Z :=\n  match l with\n  | [] => []\n  | y :: ys => if Z.eqb x y then ys else y :: remove_one x ys\n  end.\n\n(* Selection sort implemented via repeatedly extracting the minimum element. *)\nFixpoint selection_sort (l : list Z) : list Z :=\n  match l with\n  | [] => []\n  | x :: xs =>\n      let m := min_list x xs in\n      let rest := remove_one m (x :: xs) in\n      m :: selection_sort rest\n  end.",
                "code": "(* Run selection sort on the input list. The precondition is not needed here. *)\n  selection_sort a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_87",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Count the occurrences of a value in a list *)\nFixpoint countZ (x : Z) (l : list Z) : nat :=\n  match l with\n  | nil => 0%nat\n  | y :: ys => if Z.eqb x y then S (countZ x ys) else countZ x ys\n  end.\n\n(* Two lists are permutations of each other if every value appears the same number of times *)\nDefinition is_permutation (l1 l2 : list Z) : Prop :=\n  forall z : Z, countZ z l1 = countZ z l2.\n\n(* Non-decreasing sortedness: each adjacent pair is ordered *)\nFixpoint sorted_nondec (l : list Z) : Prop :=\n  match l with\n  | nil => True\n  | _ :: nil => True\n  | x :: y :: xs => x <= y /\\ sorted_nondec (y :: xs)\n  end.",
                "postcond": "sorted_nondec result /\\ is_permutation result a",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_88": {
          "data_id": "verina_basic_88",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_88",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Since the target \"array\" is represented as a list in this setting,\n     we can return the input list directly to preserve order and length. *)\n  xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_88",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "List.length result = List.length xs /\\\n  (forall (i : nat), i < List.length xs -> List.nth i result 0 = List.nth i xs 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_89": {
          "data_id": "verina_basic_89",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_89",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Boolean membership check for Z in a list using Z.eqb *)\nFixpoint memZ (x : Z) (l : list Z) : bool :=\n  match l with\n  | [] => false\n  | y :: ys => if Z.eqb x y then true else memZ x ys\n  end.\n\n(* Deduplication with accumulators:\n   - seen: elements already encountered\n   - acc:  elements collected (in reverse order for efficiency)\n   Returns the final list in the original order by reversing acc at the end. *)\nFixpoint dedup_acc (l : list Z) (seen : list Z) (acc : list Z) : list Z :=\n  match l with\n  | [] => rev acc\n  | x :: xs =>\n      if memZ x seen\n      then dedup_acc xs seen acc\n      else dedup_acc xs (x :: seen) (x :: acc)\n  end.",
                "code": "(* Start with empty 'seen' and 'acc' accumulators *)\n  dedup_acc s [] []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_89",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "NoDup result /\\\n  (forall x : Z, List.In x result <-> List.In x s) /\\\n  (forall x y : Z,\n      x <> y ->\n      (* x's first occurrence in s precedes y's first occurrence in s *)\n      (exists l1 l2 l3 : list Z,\n          s = l1 ++ x :: l2 ++ y :: l3 /\\\n          ~ List.In x l1 /\\\n          ~ List.In y (l1 ++ x :: l2)) ->\n      (* then x appears before y in result *)\n      (exists l1' l2' l3' : list Z,\n          result = l1' ++ x :: l2' ++ y :: l3'))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_90": {
          "data_id": "verina_basic_90",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_90",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Staircase search helper:\n   - row and col are 0-based nat indices\n   - fuel guarantees termination: each step moves either down (row+1) or left (col-1) *)\nFixpoint search_staircase (a : list (list Z)) (key : Z) (row col fuel : nat) : (Z * Z) :=\n  match fuel with\n  | 0 => (-1, -1)\n  | S fuel' =>\n      match nth_error a row with\n      | None => (-1, -1) (* row out of bounds *)\n      | Some rowList =>\n          match nth_error rowList col with\n          | None => (-1, -1) (* col out of bounds for this row *)\n          | Some el =>\n              if Z.eqb el key then\n                (Z.of_nat row, Z.of_nat col)\n              else if Z.ltb key el then\n                (* Move left if possible; otherwise not found *)\n                match col with\n                | 0 => (-1, -1)\n                | S col' => search_staircase a key row col' fuel'\n                end\n              else\n                (* el < key: move down *)\n                search_staircase a key (S row) col fuel'\n          end\n      end\n  end.",
                "code": "(* Handle degenerate cases: empty matrix or empty first row *)\n  match a with\n  | [] => (-1, -1)\n  | row1 :: _ =>\n      match row1 with\n      | [] => (-1, -1)\n      | _ =>\n          (* Start from top-right corner *)\n          let cols := length row1 in\n          let init_col := Nat.pred cols in\n          let fuel := S (Nat.add (length a) cols) in\n          search_staircase a key 0 init_col fuel\n      end\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_90",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(\n    (exists (i j : nat) (row : list Z),\n        List.nth_error a i = Some row /\\\n        List.nth_error row j = Some key)\n    ->\n    exists (i j : nat),\n      result = (Z.of_nat i, Z.of_nat j) /\\\n      exists row,\n        List.nth_error a i = Some row /\\\n        List.nth_error row j = Some key\n  )\n  /\\\n  (\n    ~ (exists (i j : nat) (row : list Z),\n          List.nth_error a i = Some row /\\\n          List.nth_error row j = Some key)\n    ->\n    result = (-1, -1)\n  )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_91": {
          "data_id": "verina_basic_91",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_91",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(Y, X)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_91",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (Y, X)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_92": {
          "data_id": "verina_basic_92",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_92",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Swap the two integers by returning them in reversed order *)\n  (Y, X)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_92",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (Y, X)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_93": {
          "data_id": "verina_basic_93",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_93",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Swap using XOR operations on 8-bit integers represented as Z *)\n  let t := Z.lxor X Y in\n  let newX := Z.lxor X t in\n  let newY := Z.lxor Y t in\n  (newX, newY)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_93",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* Inputs represent 8-bit unsigned integers *)\n  0 <= X /\\ X < 256 /\\\n  0 <= Y /\\ Y < 256",
                "postcond_aux": "",
                "postcond": "(* The result pair must be the inputs swapped *)\n  result = (Y, X)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_94": {
          "data_id": "verina_basic_94",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_94",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function to create a copy of a list by recursively reconstructing it *)\nFixpoint copy_list (l : list Z) : list Z :=\n  match l with\n  | nil => nil\n  | cons x xs => cons x (copy_list xs)\n  end.",
                "code": "copy_list s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_94",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_95": {
          "data_id": "verina_basic_95",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_95",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper: traverse the list once, replacing elements at positions inat and jnat *)\nFixpoint swap_with_values (l : list Z) (k inat jnat : nat) (vi vj : Z) : list Z :=\n  match l with\n  | [] => []\n  | x :: xs =>\n      let y :=\n        if Nat.eqb k inat then vj\n        else if Nat.eqb k jnat then vi\n        else x in\n      y :: swap_with_values xs (S k) inat jnat vi vj\n  end.",
                "code": "let inat := Z.to_nat i in\n  let jnat := Z.to_nat j in\n  match nth_error arr inat, nth_error arr jnat with\n  | Some vi, Some vj => swap_with_values arr 0 inat jnat vi vj\n  | _, _ => arr\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_95",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* Indices i and j are within bounds (0-based) of the array *)\n  0 <= i /\\ 0 <= j /\\\n  i < Z.of_nat (List.length arr) /\\\n  j < Z.of_nat (List.length arr)",
                "postcond_aux": "",
                "postcond": "(* Same size, and values swapped at indices i and j while others unchanged *)\n  List.length result = List.length arr /\\\n  forall (k : nat),\n    k < List.length arr ->\n    (k = Z.to_nat i -> List.nth result k 0 = List.nth arr (Z.to_nat j) 0) /\\\n    (k = Z.to_nat j -> List.nth result k 0 = List.nth arr (Z.to_nat i) 0) /\\\n    (k <> Z.to_nat i /\\ k <> Z.to_nat j -> List.nth result k 0 = List.nth arr k 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_96": {
          "data_id": "verina_basic_96",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_96",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(Y, X)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_96",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (Y, X)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_97": {
          "data_id": "verina_basic_97",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_97",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function: update the element at index j to 60 in a list of Z *)\nFixpoint update_at (l : list Z) (j : nat) : list Z :=\n  match l, j with\n  | nil, _ => nil\n  | _ :: xs, O => 60 :: xs\n  | x :: xs, S j' => x :: update_at xs j'\n  end.",
                "code": "(* Use the helper to set the element at index j to 60 *)\n  update_at a j",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_97",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "j < length a",
                "postcond_aux": "",
                "postcond": "length result = length a /\\\n  nth_error result j = Some 60 /\\\n  forall i, i < length a -> i <> j -> nth_error result i = nth_error a i",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_98": {
          "data_id": "verina_basic_98",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_98",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "3 * x",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_98",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 3 * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_99": {
          "data_id": "verina_basic_99",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_99",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Branch on whether x < 18; both branches compute 3*x in different ways *)\n  match Z.ltb x 18 with\n  | true => (x + x) + x\n  | false => 3 * x\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_99",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 3 * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_100": {
          "data_id": "verina_basic_100",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_100",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "match Z.eqb x 0 with\n  | true => 0\n  | false => x + 2 * x\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_100",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 3 * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_101": {
          "data_id": "verina_basic_101",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_101",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Compute double first using a local binding, then add the original x to get triple *)\n  let double := x + x in\n  double + x",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_101",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 3 * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_102": {
          "data_id": "verina_basic_102",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_102",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper to scan for a matching partner j for a fixed i (with value si),\n   traversing the suffix list xs while keeping track of the absolute index j. *)\nFixpoint scan_j (xs : list Z) (j : nat) (si : Z) (target : Z) : option nat :=\n  match xs with\n  | [] => None\n  | y :: ys =>\n      if Z.eqb (si + y) target\n      then Some j\n      else scan_j ys (S j) si target\n  end.\n\n(* Outer search: iterate i over the array by consuming the list from the head.\n   For each i (current head x), search j in the remaining suffix xs.\n   This ensures lexicographically smallest (i, j): smallest i first, then smallest j. *)\nFixpoint find_from (i : nat) (l : list Z) (target : Z) : option (nat * nat) :=\n  match l with\n  | [] => None\n  | x :: xs =>\n      match scan_j xs (S i) x target with\n      | Some j => Some (i, j)\n      | None => find_from (S i) xs target\n      end\n  end.",
                "code": "match find_from 0 nums target with\n  | Some p => p\n  | None => (0%nat, 0%nat) (* Unreachable under the given precondition *)\n  end",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_102",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "exists (i j : nat),\n    Nat.lt i j /\\\n    Nat.lt j (List.length nums) /\\\n    List.nth i nums 0%Z + List.nth j nums 0%Z = target",
                "postcond_aux": "",
                "postcond": "let i := fst result in\n  let j := snd result in\n  (* result is a valid index pair producing the target sum *)\n  Nat.lt i j /\\\n  Nat.lt j (List.length nums) /\\\n  List.nth i nums 0%Z + List.nth j nums 0%Z = target /\\\n  (* lexicographic minimality: minimize i first, then j for that i *)\n  (forall i' j' : nat,\n      Nat.lt i' j' ->\n      Nat.lt j' (List.length nums) ->\n      List.nth i' nums 0%Z + List.nth j' nums 0%Z = target ->\n      Nat.lt i i' \\/ (i = i' /\\ Nat.le j j'))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_103": {
          "data_id": "verina_basic_103",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_103",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function that traverses the list, keeping track of the current index (0-based),\n   updating index 4 by adding 3 and index 7 by setting to 516, leaving others unchanged. *)\nFixpoint update_positions (l : list Z) (idx : nat) : list Z :=\n  match l with\n  | nil => nil\n  | x :: xs =>\n      let x' :=\n        if Nat.eqb idx 4 then x + 3\n        else if Nat.eqb idx 7 then 516\n        else x in\n      x' :: update_positions xs (S idx)\n  end.",
                "code": "(* Start processing from index 0 *)\n  update_positions a 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_103",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(8 <= List.length a)%nat",
                "postcond_aux": "",
                "postcond": "(* Length preserved *)\n  List.length result = List.length a /\\\n  (* Index 4 increased by 3 relative to original *)\n  List.nth 4 result 0 = List.nth 4 a 0 + 3 /\\\n  (* Index 7 set to 516 *)\n  List.nth 7 result 0 = 516 /\\\n  (* All other indices unchanged *)\n  (forall j, (j < List.length a)%nat ->\n             j <> 4%nat -> j <> 7%nat ->\n             List.nth j result 0 = List.nth j a 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_104": {
          "data_id": "verina_basic_104",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_104",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Remove all entries with a given key from a map (list of pairs) *)\nFixpoint remove_key (k : Z) (m : list (Z * Z)) : list (Z * Z) :=\n  match m with\n  | nil => nil\n  | cons p t =>\n      match p with\n      | (k', v') =>\n          if Z.eqb k k'\n          then remove_key k t\n          else cons p (remove_key k t)\n      end\n  end.\n\n(* Update/override m1 with all bindings from m2; keys from m2 take precedence *)\nFixpoint update_from_m2 (m1 : list (Z * Z)) (m2 : list (Z * Z)) : list (Z * Z) :=\n  match m2 with\n  | nil => m1\n  | cons p t =>\n      match p with\n      | (k, v) =>\n          (* Remove any existing key k in m1, then add (k, v) from m2 *)\n          let m1' := cons (k, v) (remove_key k m1) in\n          update_from_m2 m1' t\n      end\n  end.\n\n(* Insertion into a sorted list by key (ascending order) *)\nFixpoint insert_sorted (p : Z * Z) (l : list (Z * Z)) : list (Z * Z) :=\n  match l with\n  | nil => cons p nil\n  | cons q t =>\n      match p, q with\n      | (k1, v1), (k2, v2) =>\n          if Z.leb k1 k2\n          then cons p (cons q t)\n          else cons q (insert_sorted p t)\n      end\n  end.\n\n(* Insertion sort of a list of pairs by key (ascending order) *)\nFixpoint sort_pairs (l : list (Z * Z)) : list (Z * Z) :=\n  match l with\n  | nil => nil\n  | cons h t => insert_sorted h (sort_pairs t)\n  end.",
                "code": "(* First, override m1 with all bindings from m2, then sort by keys *)\n  sort_pairs (update_from_m2 m1 m2)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_104",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Key membership in a map (list of key-value pairs) *)\nDefinition InKey (k : Z) (m : list (Z * Z)) : Prop :=\n  exists v, List.In (k, v) m.\n\n(* Sortedness by non-decreasing keys *)\nFixpoint sorted_by_key (l : list (Z * Z)) : Prop :=\n  match l with\n  | nil => True\n  | cons _ nil => True\n  | cons x (cons y tl) =>\n      Z.le (fst x) (fst y) /\\ sorted_by_key (cons y tl)\n  end.",
                "postcond": "(* Result is sorted by key and implements right-biased union semantics *)\n  sorted_by_key result /\\\n  forall k v,\n    List.In (k, v) result <->\n      (* If key appears in m2, its value (from m2) is in the result *)\n      (exists v2, List.In (k, v2) m2 /\\ v = v2) \\/\n      (* Otherwise, if key only appears in m1, keep its value from m1 *)\n      (~ InKey k m2 /\\ exists v1, List.In (k, v1) m1 /\\ v = v1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_105": {
          "data_id": "verina_basic_105",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_105",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Pad the remaining elements of the second list by multiplying them with 0 *)\nFixpoint arrayProduct_pad_right (b : list Z) : list Z :=\n  match b with\n  | [] => []\n  | y :: ys => (0 * y) :: arrayProduct_pad_right ys\n  end.\n\n(* Element-wise product with padding by 0 when one list is shorter.\n   This function is structurally recursive on the first list. *)\nFixpoint arrayProduct_rec (a b : list Z) : list Z :=\n  match a with\n  | [] => arrayProduct_pad_right b\n  | x :: xs =>\n      match b with\n      | [] => (x * 0) :: arrayProduct_rec xs []\n      | y :: ys => (x * y) :: arrayProduct_rec xs ys\n      end\n  end.",
                "code": "arrayProduct_rec a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_105",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* For the specification, we assume both input arrays have equal length. *)\n  length a = length b",
                "postcond_aux": "",
                "postcond": "(* Result must have the same length as both inputs,\n     and each element is the product of the corresponding inputs. *)\n  length result = length a /\\\n  length result = length b /\\\n  (forall (i : nat),\n      i < length a ->\n      nth i result 0 = (nth i a 0) * (nth i b 0))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_106": {
          "data_id": "verina_basic_106",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_106",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "Fixpoint sum_lists (l1 l2 : list Z) : list Z :=\n  match l1, l2 with\n  | nil, _ => nil\n  | _, nil => nil\n  | x :: xs, y :: ys => (x + y) :: sum_lists xs ys\n  end.",
                "code": "(* Element-wise sum of two lists, assuming equal lengths as per precondition *)\n  sum_lists a b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_106",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "(* Arrays must have equal length to allow element-wise summation *)\n  length a = length b",
                "postcond_aux": "",
                "postcond": "(* Result has same length as inputs and is the pointwise sum *)\n  length result = length a /\\\n  forall i : nat,\n    List.nth i result 0 = List.nth i a 0 + List.nth i b 0",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_107": {
          "data_id": "verina_basic_107",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_107",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(* Compute the integer average as floor((a + b) / 2), which ensures:\n     a + b - 1 â‰¤ 2 * avg â‰¤ a + b + 1 *)\n  (a + b) / 2",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_107",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "Z.le (a + b - 1) (2 * result) /\\ Z.le (2 * result) (a + b + 1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_108": {
          "data_id": "verina_basic_108",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_108",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "(* Helper function that builds the list of partial sums starting from the current accumulator\n   and tracks whether any of the partial sums after the initial 0 became negative. *)\nFixpoint partial_sums_and_neg (ops : list Z) (acc : Z) : (list Z * bool) :=\n  match ops with\n  | nil => (acc :: nil, false)\n  | x :: xs =>\n      let s := acc + x in\n      match partial_sums_and_neg xs s with\n      | (lst, neg_flag) =>\n          (* Prepend current accumulator to the list and update the neg_flag if s < 0 *)\n          (acc :: lst, if Z.ltb s 0 then true else neg_flag)\n      end\n  end.",
                "code": "partial_sums_and_neg operations 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_108",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "(* Partial sums (scanl with addition over Z), starting from an initial accumulator. *)\nFixpoint scanl_add (a : Z) (l : list Z) : list Z :=\n  match l with\n  | nil => [a]\n  | x :: xs => a :: scanl_add (a + x) xs\n  end.",
                "postcond": "(* sums is the list of partial sums starting at 0; flag indicates whether any partial sum after the initial 0 is negative *)\n  fst result = scanl_add 0 operations /\\\n  (snd result = true <-> exists z : Z, In z (tl (fst result)) /\\ z < 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        }
      }
    }
  }
}