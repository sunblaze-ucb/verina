{
  "config": {
    "output_dir": "output/gpt-5-lean-1rnd",
    "max_workers": 128,
    "run_type": "generate_only",
    "rounds": 1,
    "fewshot_example_names": [
      "verina_basic_15",
      "verina_basic_44"
    ],
    "itp_type": "lean",
    "coq_config": null,
    "gen_lm_config": {
      "provider": "openai",
      "model_name": "gpt-5",
      "api_base": null,
      "api_key": null,
      "max_tokens": null
    },
    "baseline_config": {
      "name": "baseline",
      "combind_task_preference": "NO_GENERATED_AS_REF",
      "resume_from_checkpoint": true,
      "refinements": null,
      "dspy_module": null,
      "custom_prompt_template": null,
      "itp_type": "lean"
    },
    "code_gen": true,
    "spec_gen": true,
    "proof_gen": false,
    "code_spec_gen": false,
    "code_proof_gen": false,
    "spec_proof_gen": false,
    "code_spec_proof_gen": false,
    "eval_spec_config": {
      "spec_proving_lm_config": null,
      "formal_proving": false,
      "unit_test": true,
      "unit_test_proving": false,
      "use_grind": false,
      "use_plausible_pass": true,
      "evidence_rel_dir": "./evidence",
      "generate_evidence_template": false,
      "use_evidence": false,
      "save_evidence": true
    }
  },
  "generation_timestamp": 1768730938,
  "evaluated_version_timestamp": 0,
  "evaluation_timestamp": 0,
  "rounds": {
    "0": {
      "experiment_id": "output/gpt-5-lean-1rnd",
      "data_reports": {
        "verina_basic_1": {
          "data_id": "verina_basic_1",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- True iff the product is negative, which happens exactly when a and b have opposite nonzero signs\n  decide (a * b < 0)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result ↔ ((0 < a ∧ b < 0) ∨ (a < 0 ∧ 0 < b))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_1": {
          "data_id": "verina_advanced_1",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Check whether a list contains a given integer\ndef containsInt (x : Int) : List Int → Bool\n| [] => false\n| y :: ys => if x == y then true else containsInt x ys\n\n-- Remove the first occurrence of an integer from a list\ndef removeFirstInt (x : Int) : List Int → List Int\n| [] => []\n| y :: ys => if x == y then ys else y :: removeFirstInt x ys\n\n-- Toggle presence of an integer in the accumulator:\n-- - if present, remove it\n-- - if absent, insert it\ndef toggle (acc : List Int) (x : Int) : List Int :=\n  if containsInt x acc then\n    removeFirstInt x acc\n  else\n    x :: acc",
                "code": "-- Accumulate by toggling each number; pairs cancel out, leaving the unique one\n  let acc := nums.foldl toggle []\n  -- Given the precondition, exactly one element remains\n  match acc with\n  | [v] => v\n  | _ => 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_1",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef count (xs : List Int) (x : Int) : Nat :=\n  match xs with\n  | [] => 0\n  | y :: ys => (if y = x then 1 else 0) + count ys x",
                "precond": "-- There exists exactly one element with count = 1, and any other element that appears does so exactly twice.\n  ∃ r : Int, count nums r = 1 ∧ ∀ y : Int, y ≠ r → (count nums y > 0 → count nums y = 2)",
                "postcond_aux": "",
                "postcond": "-- The result is precisely the unique element that appears exactly once in the list.\n  ∀ y : Int, count nums y = 1 ↔ y = result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_2": {
          "data_id": "verina_advanced_2",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Dynamic programming with rolling rows to compute the LCS length.\n  let n := a.size\n  let m := b.size\n\n  -- Initialize the \"previous\" DP row with zeros (length m + 1).\n  let prev0 : Array Int := Array.mkArray (m + 1) 0\n\n  -- Outer loop over indices of `a`, controlled by a fuel to ensure termination.\n  let rec outer (i : Nat) (prev : Array Int) (fuel : Nat) : Array Int :=\n    match fuel with\n    | 0 => prev\n    | fuel' + 1 =>\n      if h : i < n then\n        let ai := a[i]!\n        -- Build the current DP row starting from all zeros.\n        let cur0 : Array Int := Array.mkArray (m + 1) 0\n\n        -- Inner loop over indices of `b`, also controlled by fuel.\n        let rec inner (j : Nat) (cur : Array Int) (fuelj : Nat) : Array Int :=\n          match fuelj with\n          | 0 => cur\n          | fj' + 1 =>\n            if hj : j < m then\n              -- If elements match, take diagonal + 1; else take max of up and left.\n              let val :=\n                if ai == b[j]! then\n                  (prev[j]!) + 1\n                else\n                  let up := prev[j + 1]!\n                  let left := cur[j]!\n                  if up < left then left else up\n              let cur' := cur.set! (j + 1) val\n              inner (j + 1) cur' fj'\n            else\n              cur\n\n        let cur := inner 0 cur0 m\n        outer (i + 1) cur fuel'\n      else\n        prev\n\n  let last := outer 0 prev0 n\n  last[m]!",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef LCSWitness (a : Array Int) (b : Array Int) (n : Nat) : Prop :=\n  ∃ (fa fb : Fin n → Nat),\n    -- Every chosen index is within bounds of the respective array\n    (∀ k, fa k < a.size) ∧\n    (∀ k, fb k < b.size) ∧\n    -- The chosen indices are strictly increasing (preserve order)\n    (∀ (i j : Fin n), i < j → fa i < fa j) ∧\n    (∀ (i j : Fin n), i < j → fb i < fb j) ∧\n    -- Matched elements are equal at corresponding positions\n    (∀ k, a[fa k]! = b[fb k]!)",
                "postcond": "∃ n : Nat,\n    result = Int.ofNat n ∧\n    -- There exists a common subsequence of length exactly n\n    LCSWitness a b n ∧\n    -- Maximality: any common subsequence has length at most n\n    (∀ n' : Nat, LCSWitness a b n' → n' ≤ n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_2": {
          "data_id": "verina_basic_2",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- If the array is empty, there is no smallest element\n  if s.isEmpty then\n    none\n  else\n    -- Initialize with the first element (safe because not empty)\n    let init := s[0]!\n    -- Fold through the array to keep the current minimum\n    let minVal := s.foldl (fun acc x => if x < acc then x else acc) init\n    some minVal",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_2",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = none ↔ s.size = 0) ∧\n  (∀ m, result = some m →\n    (∃ i, i < s.size ∧ m = s[i]!) ∧\n    ∀ j, j < s.size → m ≤ s[j]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_3": {
          "data_id": "verina_advanced_3",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Dynamic programming with rolling rows (1D DP)\n  let m := a.size\n  let n := b.size\n\n  -- Initial DP row for i = 0 (all zeros, length n+1)\n  let initRow : Array Nat := Array.mkArray (n + 1) (0 : Nat)\n\n  -- Build the next DP row given the previous row and current a-value\n  let buildNextRow (aVal : Int) (prev : Array Nat) : Array Nat :=\n    -- Inner loop over b's indices (j from 0 to n-1), building a row of length n+1\n    let rec inner (j : Nat) (curr : Array Nat) (left : Nat) (k : Nat) : Array Nat :=\n      match k with\n      | 0 => curr\n      | k' + 1 =>\n        -- up = prev[j+1], diag = prev[j], bVal = b[j]\n        let up   := prev.get! (j + 1)\n        let diag := prev.get! j\n        let bVal := b.get! j\n        let v :=\n          if aVal == bVal then\n            diag + 1\n          else\n            Nat.max up left\n        inner (j + 1) (curr.push v) v k'\n    -- Start with j = 0, current row having the leading 0\n    inner 0 (Array.mkArray 1 (0 : Nat)) (0 : Nat) n\n\n  -- Outer loop over a's indices (i from 0 to m-1)\n  let rec outer (i : Nat) (prev : Array Nat) (k : Nat) : Array Nat :=\n    match k with\n    | 0 => prev\n    | k' + 1 =>\n      let aVal := a.get! i\n      let next := buildNextRow aVal prev\n      outer (i + 1) next k'\n\n  let finalRow := outer 0 initRow m\n  Int.ofNat (finalRow.get! n)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictlyIncreasing (xs : List Nat) : Prop :=\n  match xs with\n  | [] => True\n  | [_] => True\n  | i :: j :: rest => i < j ∧ StrictlyIncreasing (j :: rest)\n\n@[reducible, simp]\ndef ValidIdxs (a : Array Int) (idxs : List Nat) : Prop :=\n  StrictlyIncreasing idxs ∧ ∀ i, i ∈ idxs → i < a.size\n\n@[reducible, simp]\ndef elemsAt (a : Array Int) (idxs : List Nat) : List Int :=\n  idxs.map (fun i => a[i]!)\n\n@[reducible, simp]\ndef commonSubseqOfLen (a b : Array Int) (k : Nat) : Prop :=\n  ∃ idxA idxB,\n    idxA.length = k ∧\n    idxB.length = k ∧\n    ValidIdxs a idxA ∧\n    ValidIdxs b idxB ∧\n    elemsAt a idxA = elemsAt b idxB",
                "postcond": "∃ L : Nat,\n    result = Int.ofNat L ∧\n    commonSubseqOfLen a b L ∧\n    (∀ L', commonSubseqOfLen a b L' → L' ≤ L)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_3": {
          "data_id": "verina_basic_3",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- A number is divisible by 11 iff its remainder modulo 11 is 0\n  n % 11 == 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_3",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true ↔ ∃ k : Int, n = 11 * k",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_4": {
          "data_id": "verina_advanced_4",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Binary search: find the first index i in arr such that arr[i] >= x.\n-- If all elements are < x, return arr.size.\nprivate def lowerBound (arr : Array Int) (x : Int) : Nat :=\n  let rec go (lo hi : Nat) : Nat :=\n    if lo < hi then\n      let mid := lo + (hi - lo) / 2\n      if arr[mid]! < x then\n        go (mid + 1) hi\n      else\n        go lo mid\n    else\n      lo\n  go 0 arr.size",
                "code": "-- Patience sorting approach (O(n log n)) using tails array:\n  -- tails[k] stores the minimum possible tail value of an increasing subsequence of length k+1.\n  let tails :=\n    a.foldl (init := (#[] : Array Int)) fun tails x =>\n      let idx := lowerBound tails x\n      if idx == tails.size then\n        tails.push x\n      else\n        tails.set! idx x\n  Int.ofNat tails.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef AdjacentAll (n : Nat) (P : Nat → Prop) : Prop :=\n  ∀ i : Nat, i + 1 < n → P i\n\n-- Indices in the subsequence must be strictly increasing (by adjacency).\n@[reducible, simp]\ndef StrictlyIncreasingIndices {a : Array Int} (idxs : Array (Fin a.size)) : Prop :=\n  AdjacentAll idxs.size (fun i => (idxs[i]!.val) < (idxs[i + 1]!.val))\n\n-- The values at those indices must be strictly increasing (by adjacency).\n@[reducible, simp]\ndef StrictlyIncreasingValues (a : Array Int) (idxs : Array (Fin a.size)) : Prop :=\n  AdjacentAll idxs.size (fun i => a[idxs[i]!.val]! < a[idxs[i + 1]!.val]!)\n\n-- A valid increasing subsequence of `a` captured by an array of indices into `a`.\n@[reducible, simp]\ndef IsIncreasingSubseq (a : Array Int) (idxs : Array (Fin a.size)) : Prop :=\n  StrictlyIncreasingIndices idxs ∧ StrictlyIncreasingValues a idxs",
                "postcond": "∃ k : Nat,\n    result = Int.ofNat k ∧\n    (∃ idxs : Array (Fin a.size), idxs.size = k ∧ IsIncreasingSubseq a idxs) ∧\n    (∀ idxs' : Array (Fin a.size), IsIncreasingSubseq a idxs' → idxs'.size ≤ k)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_4": {
          "data_id": "verina_basic_4",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Convert 1-based index k to 0-based and access the element\n  arr[(k - 1)]!",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_4",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- k uses 1-based indexing and must be within bounds\n  1 ≤ k ∧ k ≤ arr.size",
                "postcond_aux": "",
                "postcond": "-- With 1-based indexing, the kth element corresponds to zero-based index k - 1\n  result = arr[k - 1]!",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_5": {
          "data_id": "verina_basic_5",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Simply return the product of the two integers\n  a * b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = a * b",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_5": {
          "data_id": "verina_advanced_5",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper function that performs digit-wise addition with a carry.\n-- The parameter `n` is a fuel (upper bound) ensuring termination:\n-- it starts as l1.length + l2.length and decreases by 1 at each recursive step.\ndef addTwoNumbers_go (n : Nat) (l1 l2 : List Nat) (carry : Nat) : List Nat :=\n  match n with\n  | 0 =>\n    -- Fuel exhausted: only possible leftover is a final carry\n    if carry = 0 then [] else [carry]\n  | n' + 1 =>\n    match l1, l2 with\n    | [], [] =>\n      -- No more digits in either list: possibly return the final carry\n      if carry = 0 then [] else [carry]\n    | x :: xs, [] =>\n      let s := x + carry\n      let digit := s % 10\n      let newCarry := s / 10\n      digit :: addTwoNumbers_go n' xs [] newCarry\n    | [], y :: ys =>\n      let s := y + carry\n      let digit := s % 10\n      let newCarry := s / 10\n      digit :: addTwoNumbers_go n' [] ys newCarry\n    | x :: xs, y :: ys =>\n      let s := x + y + carry\n      let digit := s % 10\n      let newCarry := s / 10\n      digit :: addTwoNumbers_go n' xs ys newCarry",
                "code": "-- We add the numbers digit-by-digit from least significant to most significant.\n  -- The result is naturally produced in reverse order as required.\n  addTwoNumbers_go (l1.length + l2.length) l1 l2 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_5",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef AllDigits (l : List Nat) : Prop :=\n  -- All elements are decimal digits (0..9)\n  ∀ d, d ∈ l → d ≤ 9",
                "precond": "-- Inputs are non-empty lists of digits (each digit between 0 and 9)\n  l1 ≠ [] ∧ l2 ≠ [] ∧ AllDigits l1 ∧ AllDigits l2",
                "postcond_aux": "@[reducible, simp]\ndef evalRevDigits : List Nat → Nat\n  -- Interpret a list of digits in reverse order (least-significant first)\n  | [] => 0\n  | d :: ds => d + 10 * evalRevDigits ds",
                "postcond": "-- The result is a list of digits (0..9) whose interpreted value equals the sum.\n  AllDigits result ∧ evalRevDigits result = evalRevDigits l1 + evalRevDigits l2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_6": {
          "data_id": "verina_basic_6",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute the minimum of three integers using nested comparisons.\n  -- This ensures the result is one of a, b, or c and is ≤ each of them.\n  if a ≤ b then\n    if a ≤ c then a else c\n  else\n    if b ≤ c then b else c",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result ≤ a ∧ result ≤ b ∧ result ≤ c) ∧ (result = a ∨ result = b ∨ result = c)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_6": {
          "data_id": "verina_advanced_6",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper that scans the characters and records whether each vowel was seen.\ndef allVowels_go (cs : List Char) (fa fe fi fo fu : Bool) : Bool :=\n  match cs with\n  | [] => fa && fe && fi && fo && fu\n  | c :: cs' =>\n    let fa' := fa || (c == 'a' || c == 'A')\n    let fe' := fe || (c == 'e' || c == 'E')\n    let fi' := fi || (c == 'i' || c == 'I')\n    let fo' := fo || (c == 'o' || c == 'O')\n    let fu' := fu || (c == 'u' || c == 'U')\n    let allFound := fa' && fe' && fi' && fo' && fu'\n    if allFound then true else allVowels_go cs' fa' fe' fi' fo' fu'",
                "code": "-- Scan the string (case-insensitive) and check that all five vowels appear.\n  allVowels_go s.data false false false false false",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_6",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef hasVowelCI (s : String) (v : Char) : Prop :=\n  ∃ c, c ∈ s.toList ∧ c.toLower = v\n\n@[reducible, simp]\ndef containsAllVowelsCI (s : String) : Prop :=\n  hasVowelCI s 'a' ∧ hasVowelCI s 'e' ∧ hasVowelCI s 'i' ∧ hasVowelCI s 'o' ∧ hasVowelCI s 'u'",
                "postcond": "result ↔ containsAllVowelsCI s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_7": {
          "data_id": "verina_advanced_7",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Convert a big-endian binary digit list to its decimal value using a tail-recursive loop.\n  let rec loop (acc : Nat) (ds : List Nat) : Nat :=\n    match ds with\n    | [] => acc\n    | d :: tl =>\n      -- Accumulate by shifting left (multiply by 2) and adding the current digit.\n      loop (acc * 2 + d) tl\n  loop 0 digits",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef binEvalBE (digits : List Nat) : Nat :=\n  -- Evaluate a big-endian list of base-2 digits to its natural number value\n  digits.foldl (fun acc d => acc * 2 + d) 0",
                "postcond": "result = binEvalBE digits",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_7": {
          "data_id": "verina_basic_7",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute the sum using the closed-form formula:\n  -- sum_{k=0}^{n-1} ( (2k+1)^2 ) = n * (2n - 1) * (2n + 1) / 3\n  let twoN := 2 * n\n  let numerator := n * (twoN - 1) * (twoN + 1)\n  numerator / 3",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_7",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef sumOddSquares : Nat → Nat\n| 0 => 0\n| Nat.succ k => sumOddSquares k + (2 * k + 1) * (2 * k + 1)",
                "postcond": "result = sumOddSquares n ∧ result = (n * (2 * n - 1) * (2 * n + 1)) / 3",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_8": {
          "data_id": "verina_basic_8",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Return the smaller of the two integers\n  if a ≤ b then\n    a\n  else\n    b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = a ∧ a ≤ b) ∨ (result = b ∧ b ≤ a)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_8": {
          "data_id": "verina_advanced_8",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Greedy single-pass helper:\n-- Traverses both lists in lockstep, tracking:\n-- - i: current index\n-- - start: current candidate start index\n-- - tank: current tank relative to 'start'\n-- - total: total net gas over entire traversal\n-- Returns (total, startCandidate)\ndef canCompleteCircuit_go (gs cs : List Int) (i start : Nat) (tank total : Int) : Int × Nat :=\n  match gs, cs with\n  | [], [] => (total, start)\n  | g :: gs', c :: cs' =>\n    let diff   := g - c\n    let total' := total + diff\n    let tank'  := tank + diff\n    if tank' < 0 then\n      -- Cannot start from any station up to i; reset start to i+1 and tank to 0\n      canCompleteCircuit_go gs' cs' (i + 1) (i + 1) 0 total'\n    else\n      canCompleteCircuit_go gs' cs' (i + 1) start tank' total'",
                "code": "-- Perform a single traversal computing total net gas and greedy start candidate.\n  let (total, start) := canCompleteCircuit_go gas cost 0 0 0 0\n  if total < 0 then\n    (-1)\n  else\n    Int.ofNat start",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_8",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "gas.length = cost.length ∧ gas.length ≠ 0",
                "postcond_aux": "@[reducible, simp]\ndef zipDiff (gas cost : List Int) : List Int :=\n  match gas, cost with\n  | [], _ => []\n  | _, [] => []\n  | g :: gs, c :: cs => (g - c) :: zipDiff gs cs\n\n@[reducible, simp]\ndef rotateLeftBy {α} (l : List α) (k : Nat) : List α :=\n  match l with\n  | [] => []\n  | _ =>\n    let n := l.length\n    let m := k % n\n    l.drop m ++ l.take m\n\n@[reducible, simp]\ndef sumInt (l : List Int) : Int :=\n  l.foldl (fun acc x => acc + x) 0\n\n@[reducible, simp]\ndef prefixesNonneg (v : List Int) : Prop :=\n  ∀ t, t ≤ v.length → 0 ≤ sumInt (v.take t)\n\n@[reducible, simp]\ndef canStartAt (gas cost : List Int) (s : Nat) : Prop :=\n  s < gas.length ∧\n  let v := zipDiff gas cost\n  let r := rotateLeftBy v s\n  prefixesNonneg r",
                "postcond": "let hasStart := ∃ s : Nat, canStartAt gas cost s\n  ((result = (-1)) ↔ ¬ hasStart) ∧\n  (hasStart → ∃ m : Nat,\n      result = Int.ofNat m ∧\n      canStartAt gas cost m ∧\n      (∀ t : Nat, canStartAt gas cost t → m ≤ t))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_9": {
          "data_id": "verina_basic_9",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper: check if a value x appears in array b using a simple fold\ndef elemInArray (x : Int) (b : Array Int) : Bool :=\n  b.foldl (init := false) (fun acc y => acc || (y == x))",
                "code": "-- Fold over a, short-circuiting via Bool or: true once a common element is found\n  a.foldl (init := false) (fun acc x => acc || elemInArray x b)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true ↔ (∃ i, i < a.size ∧ ∃ j, j < b.size ∧ a[i]! = b[j]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_9": {
          "data_id": "verina_advanced_9",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Sum of base-10 digits of a natural number.\n-- Implemented via a bounded tail-recursive loop using a fuel parameter (n + 1),\n-- which is certainly enough steps to reduce n to 0 by repeated division by 10.\ndef sumDigits (n : Nat) : Nat :=\n  let rec go (m acc fuel : Nat) : Nat :=\n    match fuel with\n    | 0 => acc\n    | fuel + 1 =>\n      if m == 0 then\n        acc\n      else\n        -- Add the last digit (m % 10) and continue with the remaining prefix (m / 10)\n        go (m / 10) (acc + m % 10) fuel\n  go n 0 (n + 1)\n\n-- Count how many k < n have sumDigits k divisible by d.\ndef countUpTo (n d : Nat) : Nat :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let prev := countUpTo n d\n    let s := sumDigits n\n    if s % d == 0 then prev + 1 else prev",
                "code": "-- The precondition h_precond may, for example, assert d > 0; we do not need to use it operationally.\n  -- Just delegate to the structurally recursive helper.\n  countUpTo n d",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_9",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "d > 0",
                "postcond_aux": "@[reducible, simp]\ndef digitSum (n : Nat) : Nat :=\n  -- Sum of base-10 digits of n\n  (Nat.digits 10 n).sum\n\n@[reducible, simp]\ndef countSatisfying (n d : Nat) : Nat :=\n  -- Count numbers i < n whose digit sum is divisible by d\n  ((Finset.range n).filter (fun i => digitSum i % d = 0)).card",
                "postcond": "result = countSatisfying n d",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_10": {
          "data_id": "verina_advanced_10",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Count how many times p divides n, returning (exponent, remaining n).\n-- If p ≤ 1, we return exponent 0 and leave n unchanged to avoid invalid division.\npartial def countFactorAux (m p e : Nat) : Nat × Nat :=\n  -- Here we assume p ≥ 2 (checked by the wrapper) so division/mod by p are safe.\n  if hdiv : m % p = 0 then\n    countFactorAux (m / p) p (e + 1)\n  else\n    (e, m)\n\ndef countFactor (n p : Nat) : Nat × Nat :=\n  if hp : p ≤ 1 then\n    (0, n)\n  else\n    countFactorAux n p 0",
                "code": "-- Traverse the provided primes and extract the exponent for each,\n  -- successively dividing n by the found prime powers.\n  let rec go (m : Nat) (ps : List Nat) (acc : List (Nat × Nat)) : List (Nat × Nat) :=\n    match ps with\n    | [] => acc.reverse\n    | p :: ps' =>\n      let (e, m') := countFactor m p\n      go m' ps' ((p, e) :: acc)\n  go n primes []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef prodPow (xs : List (Nat × Nat)) : Nat :=\n  xs.foldr (fun pe acc => pe.fst ^ pe.snd * acc) 1\n\n@[reducible, simp]\ndef zipProdPow (ps es : List Nat) : Nat :=\n  prodPow (ps.zip es)",
                "precond": "n > 0 ∧\n  primes ≠ [] ∧\n  List.Nodup primes ∧\n  (∀ p ∈ primes, Nat.Prime p) ∧\n  ∃ es : List Nat, es.length = primes.length ∧ n = zipProdPow primes es",
                "postcond_aux": "",
                "postcond": "-- The result must pair each input prime with its exponent,\n  -- and their product equals n.\n  List.Perm (result.map Prod.fst) primes ∧\n  (∀ pe ∈ result, Nat.Prime pe.fst) ∧\n  prodPow result = n",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_10": {
          "data_id": "verina_basic_10",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Fold over the array, ensuring every element is strictly less than n\n  a.foldl (fun acc x => if x < n then acc else false) true",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_10",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result ↔ (∀ i, i < a.size → n > a[i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_11": {
          "data_id": "verina_advanced_11",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Count how many times a value appears in a list\ndef countOccurrences (lst : List Int) (v : Int) : Nat :=\n  lst.foldl (fun c x => if x == v then c + 1 else c) 0\n\n-- Boyer–Moore majority vote algorithm to get a candidate\ndef majorityCandidate (lst : List Int) : Int :=\n  let (cand, _) :=\n    lst.foldl\n      (fun acc x =>\n        let (cand, cnt) := acc\n        if cnt = 0 then (x, 1)\n        else if x == cand then (cand, cnt + 1)\n        else (cand, cnt - 1)\n      )\n      (0, 0)\n  cand",
                "code": "-- Find a candidate using Boyer–Moore, then verify it occurs strictly more than half the time.\n  let cand := majorityCandidate lst\n  let cnt  := countOccurrences lst cand\n  if h : cnt * 2 > lst.length then\n    cand\n  else\n    -1",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef occ (x : Int) (lst : List Int) : Nat :=\n  -- Count occurrences of x in lst\n  match lst with\n  | [] => 0\n  | y :: ys => (if x = y then 1 else 0) + occ x ys\n\n@[reducible, simp]\ndef isMajority (lst : List Int) (x : Int) : Prop :=\n  -- x is a majority element of lst iff it occurs strictly more than half of lst.length\n  occ x lst > lst.length / 2",
                "postcond": "-- Soundness and completeness:\n  -- - result = -1 iff no majority element exists\n  -- - if result ≠ -1 then result is (the unique) majority element\n  (result = -1 ↔ ¬ ∃ x : Int, isMajority lst x)\n  ∧ (result ≠ -1 → isMajority lst result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_11": {
          "data_id": "verina_basic_11",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- The last digit of a non-negative integer is the remainder modulo 10\n  n % 10",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_11",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = n % 10 ∧ result < 10",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_12": {
          "data_id": "verina_advanced_12",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Simple membership check for lists of Int using boolean equality\ndef memList (x : Int) (l : List Int) : Bool :=\n  match l with\n  | [] => false\n  | y :: ys => if x == y then true else memList x ys",
                "code": "-- Helper function that scans the list left-to-right, tracking seen elements\n  let rec go (seen : List Int) (l : List Int) : Option Int :=\n    match l with\n    | [] => none\n    | x :: xs =>\n      if memList x seen then\n        some x\n      else\n        go (x :: seen) xs\n  go [] lst",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef dupAt (lst : List Int) (j : Nat) (x : Int) : Prop :=\n  -- At position j we see x, and x has appeared at some earlier index i < j\n  lst.get? j = some x ∧ ∃ i : Nat, i < j ∧ lst.get? i = some x\n\n@[reducible, simp]\ndef firstDupVal (lst : List Int) (x : Int) : Prop :=\n  -- x is the value of the earliest (leftmost) index j that is a duplicate occurrence\n  ∃ j : Nat, dupAt lst j x ∧ ∀ k : Nat, k < j → ∀ y : Int, ¬ dupAt lst k y",
                "postcond": "match result with\n  | some x => firstDupVal lst x\n  | none   => ¬ ∃ j : Nat, ∃ x : Int, dupAt lst j x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_12": {
          "data_id": "verina_basic_12",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Surface area of a cube with edge length `size` is 6 * size^2\n  size * size * 6",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_12",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 6 * (size * size)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_13": {
          "data_id": "verina_advanced_13",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Normalize the input list of chords into a list of endpoint pairs (u, v) with u ≤ v.\ndef normalizePairs (chs : List (List Nat)) : List (Nat × Nat) :=\n  let rec go (cs : List (List Nat)) (acc : List (Nat × Nat)) : List (Nat × Nat) :=\n    match cs with\n    | [] => acc.reverse\n    | l :: rest =>\n      match l with\n      | [u, v] =>\n        let p := if u ≤ v then (u, v) else (v, u)\n        go rest (p :: acc)\n      | _ =>\n        -- By precondition, each chord has exactly two distinct endpoints.\n        -- We skip malformed entries defensively.\n        go rest acc\n  go chs []\n\n-- Build an array mapping each position 1..2N to its chord id (0..N-1).\n-- Positions with no endpoint are mapped to none.\ndef buildEndpointMap (total : Nat) (pairs : List (Nat × Nat)) : Array (Option Nat) :=\n  let initial : Array (Option Nat) := Array.mkArray (total + 1) (Option.none : Option Nat)\n  let rec fill (ps : List (Nat × Nat)) (id : Nat) (emap : Array (Option Nat)) : Array (Option Nat) :=\n    match ps with\n    | [] => emap\n    | (u, v) :: rest =>\n      let em1 := emap.set! u (some id)\n      let em2 := em1.set! v (some id)\n      fill rest (id + 1) em2\n  fill pairs 0 initial",
                "code": "-- Normalize chords to ordered endpoint pairs\n  let pairs := normalizePairs chords\n  let total := 2 * N\n\n  -- Map each position to its chord id\n  let endpointMap := buildEndpointMap total pairs\n\n  -- Visited array to mark whether we've seen the first endpoint of a chord\n  let visited0 : Array Bool := Array.mkArray N false\n\n  -- Sweep through positions 1..2N, using a stack of \"open\" chords.\n  let rec sweep (pos : Nat) (visited : Array Bool) (stack : List Nat) : Bool :=\n    if pos > total then\n      false\n    else\n      let idOpt := endpointMap.get! pos\n      match idOpt with\n      | none =>\n        sweep (pos + 1) visited stack\n      | some cid =>\n        if visited.get! cid then\n          -- This is the closing endpoint for chord cid.\n          match stack with\n          | [] => true -- Should not happen for well-formed input; treat as intersection\n          | top :: rest =>\n            if top == cid then\n              sweep (pos + 1) visited rest\n            else\n              -- Closing a chord that is not on top implies an intersection.\n              true\n        else\n          -- First time we see this chord: open it.\n          let visited' := visited.set! cid true\n          sweep (pos + 1) visited' (cid :: stack)\n\n  sweep 1 visited0 []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef asPair? (xs : List Nat) : Option (Nat × Nat) :=\n  match xs with\n  | a :: b :: [] => some (a, b)\n  | _ => none\n\n@[reducible, simp]\ndef sortPair (p : Nat × Nat) : Nat × Nat :=\n  if p.fst ≤ p.snd then p else (p.snd, p.fst)\n\n@[reducible, simp]\ndef chordsIntersect (p q : Nat × Nat) : Prop :=\n  let a := (sortPair p).fst\n  let b := (sortPair p).snd\n  let c := (sortPair q).fst\n  let d := (sortPair q).snd\n  -- Two chords (a,b) and (c,d) (with a<b and c<d) intersect\n  -- iff a < c < b < d or c < a < d < b.\n  (a < c ∧ c < b ∧ b < d) ∨ (c < a ∧ a < d ∧ d < b)\n\n@[reducible, simp]\ndef anyChordIntersection (chords : List (List Nat)) : Prop :=\n  ∃ c1 ∈ chords, ∃ c2 ∈ chords, c1 ≠ c2 ∧\n    ∃ p q,\n      asPair? c1 = some p ∧\n      asPair? c2 = some q ∧\n      chordsIntersect p q",
                "postcond": "result ↔ anyChordIntersection chords",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_13": {
          "data_id": "verina_basic_13",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "a.map (fun x => x * x * x)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_13",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.size = a.size ∧ ∀ i, i < a.size → result[i]! = (a[i]!) * (a[i]!) * (a[i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_14": {
          "data_id": "verina_basic_14",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "-- Return true if any character is 'z' or 'Z'\n  s.any (fun c => c == 'z' || c == 'Z')",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef HasChar (s : String) (c : Char) : Prop :=\n  ∃ i : Fin s.length, s.get i = c",
                "postcond": "result ↔ (HasChar s 'z' ∨ HasChar s 'Z')",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_14": {
          "data_id": "verina_advanced_14",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We iterate powers of 4 starting from 1, with a fuel counter to ensure termination.\n  -- If we reach n exactly, return true. If we exceed n, return false.\n  let rec loop (p : Nat) (fuel : Nat) : Bool :=\n    if p == n then\n      true\n    else\n      if h : p > n then\n        false\n      else\n        match fuel with\n        | 0 => false\n        | fuel' + 1 => loop (p * 4) fuel'\n  -- Using fuel = n + 1 guarantees termination and is sufficient to either hit or exceed n.\n  loop 1 (n + 1)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_14",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result ↔ ∃ x : Nat, n = Nat.pow 4 x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_15": {
          "data_id": "verina_advanced_15",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_15",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper that scans the list once while maintaining two candidates:\n-- m1 = smallest value seen so far\n-- m2 = smallest value greater than m1 seen so far\n-- If we ever find an element greater than m2, we found an increasing triplet.\ndef increasingTripletAux : Option Int → Option Int → List Int → Bool\n| m1, m2, [] => false\n| m1, m2, x :: xs =>\n  match m1 with\n  | none =>\n    -- First candidate not set yet; set it to current x.\n    increasingTripletAux (some x) m2 xs\n  | some first =>\n    if x ≤ first then\n      -- Found a new smaller first candidate.\n      increasingTripletAux (some x) m2 xs\n    else\n      -- x > first; try to place/update the second candidate.\n      match m2 with\n      | none =>\n        -- No second candidate yet; x becomes the second.\n        increasingTripletAux m1 (some x) xs\n      | some second =>\n        if x ≤ second then\n          -- Tighten the second candidate.\n          increasingTripletAux m1 (some x) xs\n        else\n          -- x > second > first with increasing indices ⇒ triplet found.\n          true",
                "code": "-- Run the linear scan with two candidates; start with none for both.\n  increasingTripletAux none none nums",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_15",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result ↔ ∃ (i j k : Fin nums.length), i < j ∧ j < k ∧ nums.get i < nums.get j ∧ nums.get j < nums.get k",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_16": {
          "data_id": "verina_basic_16",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Iterate through the string by character index and build the result incrementally.\n  let rec go (i : Nat) (acc : String) : String :=\n    if h : i < s.length then\n      -- Safe access to the i-th character using Fin witness h\n      let c := s.get ⟨i, h⟩\n      let c' := if c == oldChar then newChar else c\n      go (i + 1) (acc.push c')\n    else\n      acc\n  go 0 \"\"",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result must have the same length and be a pointwise character replacement:\n  result.length = s.length ∧\n  ∀ i : Nat,\n    result.get? i = (s.get? i).map (fun c => if c = oldChar then newChar else c)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_16": {
          "data_id": "verina_advanced_16",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Insert an element into a sorted (ascending) list, preserving order.\ndef insertIntoSorted (x : Int) : List Int → List Int\n| [] => [x]\n| y :: ys =>\n  -- If x ≤ y, place x before y; otherwise, keep y and continue.\n  if x ≤ y then\n    x :: y :: ys\n  else\n    y :: insertIntoSorted x ys\n\n-- Standard insertion sort using the above insertion procedure.\ndef insertionSortList : List Int → List Int\n| [] => []\n| x :: xs => insertIntoSorted x (insertionSortList xs)",
                "code": "-- Perform insertion sort using a standard fold over the list.\n  insertionSortList xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_16",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef sortedAsc : List Int → Prop\n| [] => True\n| _ :: [] => True\n| x :: y :: xs => x ≤ y ∧ sortedAsc (y :: xs)",
                "postcond": "sortedAsc result ∧ List.Perm result xs",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_17": {
          "data_id": "verina_advanced_17",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Insert an element into a sorted list (non-decreasing order)\ndef insertSorted (x : Int) : List Int → List Int\n  | [] => [x]\n  | y :: ys =>\n    if x ≤ y then\n      x :: y :: ys\n    else\n      y :: insertSorted x ys\n\n-- Recursive insertion sort implementation using insertSorted\ndef insertionSortImpl : List Int → List Int\n  | [] => []\n  | x :: xs => insertSorted x (insertionSortImpl xs)",
                "code": "-- Use the helper implementation that does not require any preconditions\n  insertionSortImpl l",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef SortedNondecreasing : List Int → Prop\n| [] => True\n| [_] => True\n| x :: y :: xs => x ≤ y ∧ SortedNondecreasing (y :: xs)",
                "postcond": "SortedNondecreasing result ∧ List.Perm result l",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_17": {
          "data_id": "verina_basic_17",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Convert a single ASCII uppercase character to lowercase; keep all others unchanged.\ndef asciiToLower (c : Char) : Char :=\n  if 'A' ≤ c ∧ c ≤ 'Z' then\n    -- ASCII distance between uppercase and lowercase letters is 32\n    Char.ofNat (c.toNat + 32)\n  else\n    c",
                "code": "-- Map each character using asciiToLower. This preserves the string length.\n  s.map asciiToLower",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_17",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef asciiLowerOffset : Nat :=\n  'a'.toNat - 'A'.toNat\n\n@[reducible, simp]\ndef toAsciiLower (c : Char) : Char :=\n  -- Map ASCII 'A'..'Z' to 'a'..'z', leave everything else unchanged\n  if h : 'A' ≤ c ∧ c ≤ 'Z' then\n    Char.ofNat (c.toNat + asciiLowerOffset)\n  else\n    c",
                "postcond": "-- Same length and pointwise lowercasing of ASCII uppercase characters\n  ∃ Hlen : result.length = s.length,\n    ∀ (i : Nat), i < s.length →\n      result.get ⟨i, by simpa [Hlen] using ‹i < s.length›⟩\n        = toAsciiLower (s.get ⟨i, ‹i < s.length›⟩)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_18": {
          "data_id": "verina_advanced_18",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Compute the base-10 digits of n in most-significant-first order.\ndef digits (n : Nat) : List Nat :=\n  let rec go (m fuel : Nat) (acc : List Nat) : List Nat :=\n    match fuel with\n    | 0 => acc\n    | fuel' + 1 =>\n      if m < 10 then\n        m :: acc\n      else\n        let d := m % 10\n        go (m / 10) fuel' (d :: acc)\n  -- Using fuel = n + 1 guarantees termination since each step reduces m by a factor of 10.\n  go n (n + 1) []\n\n-- Sum of each digit raised to the power of the number of digits.\ndef powSumDigits (n : Nat) : Nat :=\n  let ds := digits n\n  let k := ds.length\n  ds.foldl (fun acc d => acc + d ^ k) 0",
                "code": "let s := powSumDigits n\n  s == n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef armstrongPowerLen (n : Nat) : Nat :=\n  -- Number of digits in base 10; by convention 0 has 1 digit\n  if n = 0 then 1 else (Nat.digits 10 n).length\n\n@[reducible, simp]\ndef armstrongSum (n : Nat) : Nat :=\n  -- Sum of each base-10 digit raised to the power of the number of digits\n  let ds := Nat.digits 10 n\n  let k := armstrongPowerLen n\n  (ds.map (fun d => d ^ k)).foldl (· + ·) 0",
                "postcond": "-- The result must exactly reflect the Armstrong property\n  result = decide (n = armstrongSum n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_18": {
          "data_id": "verina_basic_18",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-- Tail-recursive helper that accumulates the sum of digits of `m`.\n    It uses a fuel parameter to ensure structural recursion. The loop stops\n    early if `m = 0`, or when the fuel runs out (which is set large enough). -/\ndef sumDigitsLoop (m acc fuel : Nat) : Nat :=\n  match fuel with\n  | 0 => acc\n  | fuel' + 1 =>\n    if m = 0 then\n      acc\n    else\n      -- Add the last digit (m % 10) and continue with m / 10\n      sumDigitsLoop (m / 10) (acc + m % 10) fuel'",
                "code": "-- Use a fuel of n + 1, which is more than sufficient since each step reduces `m`\n  -- (for m > 0) and we also stop early when m becomes 0.\n  sumDigitsLoop n 0 (n + 1)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_18",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef base10Value : List Nat → Nat\n  | [] => 0\n  | d :: ds => d + 10 * base10Value ds\n\n@[reducible, simp]\ndef sumList : List Nat → Nat\n  | [] => 0\n  | d :: ds => d + sumList ds\n\n@[reducible, simp]\ndef AllBase10Digits (ds : List Nat) : Prop :=\n  ∀ d, d ∈ ds → d < 10",
                "postcond": "∃ ds : List Nat,\n    AllBase10Digits ds ∧\n    base10Value ds = n ∧\n    result = sumList ds",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_19": {
          "data_id": "verina_basic_19",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We iterate through adjacent pairs and check a[i] ≤ a[i+1].\n  -- The number of adjacent pairs is (a.size - 1), with subtraction saturating at 0.\n  let n := a.size\n  let rec go (i remaining : Nat) : Bool :=\n    match remaining with\n    | 0 => true\n    | Nat.succ r =>\n      let x := a[i]!\n      let y := a[i+1]!\n      if x <= y then\n        go (i + 1) r\n      else\n        false\n  go 0 (n - 1)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- Soundness and completeness:\n  -- 1) result = true iff every adjacent pair is non-decreasing.\n  -- 2) result = false iff there exists a decreasing adjacent pair.\n  (result = true ↔ (∀ i : Nat, i + 1 < a.size → a[i]! ≤ a[i + 1]!)) ∧\n  (result = false ↔ (∃ i : Nat, i + 1 < a.size ∧ a[i]! > a[i + 1]!))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_19": {
          "data_id": "verina_advanced_19",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper: check if a character is an ASCII alphabetic letter (A-Z or a-z)\ndef isAsciiLetter (c : Char) : Bool :=\n  decide (('A' ≤ c ∧ c ≤ 'Z') ∨ ('a' ≤ c ∧ c ≤ 'z'))\n\n-- Helper: convert an ASCII uppercase letter to lowercase; leaves other chars unchanged\ndef toLowerAscii (c : Char) : Char :=\n  if decide ('A' ≤ c ∧ c ≤ 'Z') then\n    Char.ofNat (c.toNat + 32)  -- 'A'..'Z' to 'a'..'z'\n  else\n    c",
                "code": "-- Normalize the string: keep only letters and lowercase them\n  let letters := s.foldl (init := (#[] : Array Char)) (fun acc c =>\n    if isAsciiLetter c then\n      acc.push (toLowerAscii c)\n    else\n      acc)\n\n  -- Two-pointer palindrome check on the normalized character array\n  let mut l := 0\n  let mut r := letters.size  -- r is exclusive\n  let mut ok := true\n  while ok && l < r do\n    if letters[l]! == letters[r - 1]! then\n      l := l + 1\n      r := r - 1\n    else\n      ok := false\n  ok",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_19",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef isAsciiLetter (c : Char) : Bool :=\n  -- Keep only ASCII alphabetic characters\n  decide (('a' ≤ c ∧ c ≤ 'z') ∨ ('A' ≤ c ∧ c ≤ 'Z'))\n\n@[reducible, simp]\ndef asciiLowerOffset : Nat :=\n  -- Distance between 'A' and 'a' in ASCII\n  Char.toNat 'a' - Char.toNat 'A'\n\n@[reducible, simp]\ndef toLowerAscii (c : Char) : Char :=\n  -- Lowercase only ASCII uppercase letters; leave others unchanged\n  if _h : ('A' ≤ c ∧ c ≤ 'Z') then\n    Char.ofNat (c.toNat + asciiLowerOffset)\n  else\n    c\n\n@[reducible, simp]\ndef cleanChars (s : String) : List Char :=\n  -- Remove non-letters and normalize case to lowercase (ASCII)\n  (s.data.filter isAsciiLetter).map toLowerAscii\n\n@[reducible, simp]\ndef isPalindromeChars (xs : List Char) : Prop :=\n  xs = xs.reverse\n\n@[reducible, simp]\ndef isCleanPalindromeProp (s : String) : Prop :=\n  isPalindromeChars (cleanChars s)",
                "postcond": "result ↔ isCleanPalindromeProp s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_20": {
          "data_id": "verina_basic_20",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/--\n  Linearly checks whether an Array Int contains a given value.\n  Uses a while loop with safe indexing via `a[i]!`.\n-/\ndef arrayContainsInt (a : Array Int) (x : Int) : Bool :=\n  Id.run do\n    let mut i := 0\n    let mut found := false\n    while i < a.size && !found do\n      if a[i]! == x then\n        found := true\n      i := i + 1\n    return found",
                "code": "-- Accumulate unique elements and multiply them once\n  Id.run do\n    let mut seen : Array Int := #[]\n    let mut prod : Int := 1\n    for x in arr do\n      if !(arrayContainsInt seen x) then\n        seen := seen.push x\n        prod := prod * x\n    return prod",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "∃ l : List Int,\n    l.Nodup ∧\n    -- l contains exactly the distinct integers appearing in arr\n    (∀ v : Int, v ∈ l ↔ ∃ i : Nat, i < arr.size ∧ arr[i]! = v) ∧\n    -- result is the product of those distinct integers; empty product is 1\n    result = l.foldl (fun acc x => acc * x) (1 : Int)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_20": {
          "data_id": "verina_advanced_20",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-\n  Check if a natural number contains the digit 8 in its base-10 representation.\n  We implement a fuelled recursion to avoid a nontrivial termination proof.\n-/\nprivate def hasDigitEightNatLoop (fuel m : Nat) : Bool :=\n  match fuel, m with\n  | 0, _ => false\n  | _+1, 0 => false\n  | f+1, m =>\n    if m % 10 == 8 then\n      true\n    else\n      hasDigitEightNatLoop f (m / 10)\n\n/-- Public wrapper that sets sufficient fuel (m.succ is always enough). -/\ndef hasDigitEightNat (m : Nat) : Bool :=\n  hasDigitEightNatLoop (m.succ) m\n\n/-- Check divisibility of an integer by 8 using Euclidean modulus. -/\ndef divisibleByEight (n : Int) : Bool :=\n  n.emod 8 == 0",
                "code": "let div8 := divisibleByEight n\n  let has8 := hasDigitEightNat n.natAbs\n  div8 || has8",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_20",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef hasDigitEight (n : Int) : Prop :=\n  -- Check if the base-10 representation of |n| contains the digit 8.\n  -- Using natAbs to ignore the sign; digit condition: there exists k such that\n  -- the k-th decimal digit equals 8, i.e., (|n| / 10^k) % 10 = 8.\n  let m := n.natAbs\n  ∃ k : Nat, ((m / (10 ^ k)) % 10) = 8",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result = true) ↔ ((8 ∣ n) ∨ hasDigitEight n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_21": {
          "data_id": "verina_advanced_21",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to reverse a String by reversing its list of characters\ndef reverseString (s : String) : String :=\n  String.mk s.data.reverse",
                "code": "let rev := reverseString s\n  s == rev",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef Palindrome (s : String) : Prop :=\n  -- A string is a palindrome if its character list equals its reverse.\n  s.data = s.data.reverse",
                "postcond": "-- The boolean result must exactly reflect whether s is a palindrome.\n  result ↔ Palindrome s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_21": {
          "data_id": "verina_basic_21",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Check whether the first list is a prefix of the second list\ndef startsWith (sub : List Int) (main : List Int) : Bool :=\n  match sub with\n  | [] => true\n  | x :: xs =>\n    match main with\n    | [] => false\n    | y :: ys => x == y && startsWith xs ys\n\n-- Scan the main list to see if `sub` occurs as a contiguous segment\ndef scanSublist (sub : List Int) (main : List Int) : Bool :=\n  match main with\n  | [] => false\n  | _ :: ms =>\n    if startsWith sub main then\n      true\n    else\n      scanSublist sub ms",
                "code": "match sub with\n  | [] => true\n  | _ => scanSublist sub main",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_21",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result ↔ ∃ (pre : List Int) (post : List Int), main = pre ++ sub ++ post",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_22": {
          "data_id": "verina_basic_22",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Check if an element is in an Array\ndef memArray (x : Int) (arr : Array Int) : Bool :=\n  arr.foldl (init := false) (fun acc y => acc || (y == x))\n\n-- Push an element to the Array only if it is not already present\ndef pushIfUnique (arr : Array Int) (x : Int) : Array Int :=\n  if memArray x arr then arr else arr.push x\n\n-- Insert an integer into a sorted list (ascending), preserving order\ndef insertSorted (x : Int) : List Int → List Int\n  | [] => [x]\n  | y :: ys => if x ≤ y then x :: y :: ys else y :: insertSorted x ys\n\n-- Insertion sort for a list of integers (ascending)\ndef insertionSortList (l : List Int) : List Int :=\n  l.foldl (init := []) (fun acc x => insertSorted x acc)\n\n-- Convert a list of integers to an array\ndef listToArrayInt (l : List Int) : Array Int :=\n  l.foldl (init := (#[] : Array Int)) (fun acc x => acc.push x)",
                "code": "-- Build the symmetric difference without duplicates\n  let resFromA :=\n    a.foldl (init := (#[] : Array Int)) (fun acc x =>\n      if memArray x b then acc else pushIfUnique acc x)\n  let res :=\n    b.foldl (init := resFromA) (fun acc y =>\n      if memArray y a then acc else pushIfUnique acc y)\n\n  -- Sort the result in ascending order\n  let sortedList := insertionSortList res.toList\n  listToArrayInt sortedList",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef memArrayInt (arr : Array Int) (x : Int) : Prop :=\n  ∃ i : Nat, i < arr.size ∧ arr[i]! = x\n\n@[reducible, simp]\ndef xorProp (p q : Prop) : Prop :=\n  (p ∧ ¬ q) ∨ (¬ p ∧ q)\n\n@[reducible, simp]\ndef NoDupArray (arr : Array Int) : Prop :=\n  ∀ {i j : Nat}, i < j → j < arr.size → arr[i]! ≠ arr[j]!\n\n@[reducible, simp]\ndef SortedNondecArray (arr : Array Int) : Prop :=\n  ∀ {i j : Nat}, i < j → j < arr.size → arr[i]! ≤ arr[j]!",
                "postcond": "NoDupArray result ∧\n  SortedNondecArray result ∧\n  (∀ x : Int, memArrayInt result x ↔ xorProp (memArrayInt a x) (memArrayInt b x))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_22": {
          "data_id": "verina_advanced_22",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We require at least three elements to form a non-empty increasing part followed by a non-empty decreasing part.\n  let rec loop (increasing : Bool) (sawInc : Bool) (sawDec : Bool) (prev : Int) (rest : List Int) : Bool :=\n    match rest with\n    | [] => sawInc && sawDec\n    | nxt :: tail =>\n      if increasing then\n        -- Still in the strictly increasing phase\n        if hlt : prev < nxt then\n          loop true true sawDec nxt tail\n        else\n          -- Not strictly increasing; either equal (invalid) or start decreasing\n          if heq : prev = nxt then\n            false\n          else\n            -- prev > nxt: switch to decreasing only if we already had an increase\n            if sawInc then\n              loop false sawInc true nxt tail\n            else\n              false\n      else\n        -- In the strictly decreasing phase: must keep decreasing strictly\n        if hlt : nxt < prev then\n          loop false sawInc true nxt tail\n        else\n          false\n\n  match lst with\n  | [] => false\n  | [_] => false\n  | x :: y :: xs =>\n    -- The sequence must start with a strict increase\n    if hxy : x < y then\n      loop true true false y xs\n    else if heq : x = y then\n      false\n    else\n      -- x > y: starts decreasing immediately, which violates the requirement\n      false",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_22",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictUp : List Int → Prop\n  | [] => True\n  | [_] => True\n  | x :: y :: t => x < y ∧ StrictUp (y :: t)\n\n@[reducible, simp]\ndef StrictDown : List Int → Prop\n  | [] => True\n  | [_] => True\n  | x :: y :: t => x > y ∧ StrictDown (y :: t)",
                "postcond": "-- result is true iff there exists a split point p (the peak index) such that:\n  -- - there is at least one increasing step before p (1 ≤ p),\n  -- - there is at least one decreasing step after p (p + 1 < lst.length),\n  -- - the prefix up to p is strictly increasing,\n  -- - the suffix starting at p is strictly decreasing.\n  result ↔\n    ∃ p : Nat,\n      1 ≤ p ∧\n      p + 1 < lst.length ∧\n      StrictUp (lst.take (p + 1)) ∧\n      StrictDown (lst.drop p)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_23": {
          "data_id": "verina_advanced_23",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-\n  Helper to check whether a natural number is a power of two.\n  - 0 is not a power of two.\n  - 1 is 2^0, hence a power of two.\n  - For m > 1, m must be even and m/2 must be a power of two.\n  We implement a total recursive function using a fuel parameter to ensure termination.\n-/\ndef isPowerOfTwoNat (k : Nat) : Bool :=\n  if k == 0 then\n    false\n  else\n    -- Tail-recursive worker with fuel ≤ k; each step halves m, so fuel is sufficient.\n    let rec go (m fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false\n      | fuel'+1 =>\n        if m == 1 then\n          true\n        else\n          -- If m is odd and > 1, it cannot be a power of two.\n          if m % 2 == 1 then\n            false\n          else\n            -- m is even, keep checking m/2 with reduced fuel.\n            go (m / 2) fuel'\n    go k k",
                "code": "-- Negative numbers and zero are not powers of two\n  if h : n ≤ 0 then\n    false\n  else\n    -- n > 0 here; convert to Nat and use the natural-number checker\n    let k : Nat := n.toNat\n    isPowerOfTwoNat k",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result ↔ (n > 0 ∧ ∃ k : Nat, n = (2 : Int) ^ k)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_23": {
          "data_id": "verina_basic_23",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Since the array is assumed non-empty, we take the first element as initial min and max.\n  -- For safety, if the array were empty, we return 0 (this branch should be unreachable by precondition).\n  let n := a.size\n  if h0 : n = 0 then\n    0\n  else\n    let init := a[0]!\n    -- Tail-recursive loop to scan remaining elements and track current min and max.\n    let rec loop (i : Nat) (mn mx : Int) : Int :=\n      if h : i < n then\n        let x := a[i]!\n        let mn' := if x < mn then x else mn\n        let mx' := if mx < x then x else mx\n        loop (i + 1) mn' mx'\n      else\n        mx - mn\n    loop 1 init init",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_23",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The array must be non-empty to have a defined min and max\n  0 < a.size",
                "postcond_aux": "",
                "postcond": "-- There exist indices iMin and iMax within bounds such that:\n  -- - a[iMin]! is a global minimum of the array\n  -- - a[iMax]! is a global maximum of the array\n  -- - result is the difference max - min\n  ∃ iMin iMax,\n    iMin < a.size ∧ iMax < a.size ∧\n    (∀ j, j < a.size → a[iMin]! ≤ a[j]!) ∧\n    (∀ j, j < a.size → a[j]! ≤ a[iMax]!) ∧\n    result = a[iMax]! - a[iMin]!",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_24": {
          "data_id": "verina_advanced_24",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Replace the first element in the list that is >= x with x.\n-- Returns the new list and a flag indicating whether a replacement happened.\ndef replaceFirstGE (xs : List Int) (x : Int) : List Int × Bool :=\n  match xs with\n  | [] => ([], false)\n  | y :: ys =>\n    if x ≤ y then\n      (x :: ys, true)\n    else\n      let (ys', b) := replaceFirstGE ys x\n      (y :: ys', b)\n\n-- Process one element for the patience sorting tails list:\n-- if we can replace the first element >= x, do so; otherwise append x.\ndef processTails (tails : List Int) (x : Int) : List Int :=\n  let (r, replaced) := replaceFirstGE tails x\n  if replaced then r else r ++ [x]",
                "code": "-- Patience sorting approach:\n  -- Maintain a list \"tails\" where tails[k] is the smallest tail of an increasing subsequence of length k+1.\n  let tails := nums.foldl processTails []\n  Int.ofNat tails.length",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictlyIncreasingInt : List Int → Prop\n  | [] => True\n  | [_] => True\n  | x :: y :: zs => x < y ∧ StrictlyIncreasingInt (y :: zs)\n\n@[reducible, simp]\ndef SubseqInt : List Int → List Int → Prop\n  | [], _ => True\n  | _ :: _, [] => False\n  | x :: xs, y :: ys => (x = y ∧ SubseqInt xs ys) ∨ SubseqInt (x :: xs) ys",
                "postcond": "∃ s : List Int,\n    SubseqInt s nums ∧\n    StrictlyIncreasingInt s ∧\n    result = Int.ofNat s.length ∧\n    ∀ t : List Int, SubseqInt t nums ∧ StrictlyIncreasingInt t → t.length ≤ s.length",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_24": {
          "data_id": "verina_basic_24",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We scan the array once, recording the first even and the first odd values.\n  -- As soon as both are found, we return their difference (even - odd).\n  let rec go (i fuel : Nat) (firstEven? firstOdd? : Option Int) : Int :=\n    match firstEven?, firstOdd? with\n    | some e, some o => e - o\n    | _, _ =>\n      if fuel = 0 then\n        -- Should be unreachable given the preconditions; provide a safe fallback.\n        match firstEven?, firstOdd? with\n        | some e, some o => e - o\n        | _, _ => 0\n      else\n        if h : i < a.size then\n          let x := a[i]!\n          -- Update first even if not set and current x is even\n          let firstEven?' :=\n            match firstEven? with\n            | some _ => firstEven?\n            | none   => if x % 2 == 0 then some x else none\n          -- Update first odd if not set and current x is odd\n          let firstOdd?' :=\n            match firstOdd? with\n            | some _ => firstOdd?\n            | none   => if x % 2 != 0 then some x else none\n          go (i + 1) (fuel - 1) firstEven?' firstOdd?'\n        else\n          -- End of array; return if both found, else a safe fallback (precondition guarantees both exist).\n          match firstEven?, firstOdd? with\n          | some e, some o => e - o\n          | _, _ => 0\n  go 0 a.size none none",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_24",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef isEvenInt (n : Int) : Prop :=\n  ∃ k : Int, n = 2 * k\n\n@[reducible, simp]\ndef isOddInt (n : Int) : Prop :=\n  ∃ k : Int, n = 2 * k + 1",
                "precond": "-- The array contains at least one even and at least one odd element.\n  (∃ i : Nat, i < a.size ∧ isEvenInt (a[i]!)) ∧\n  (∃ j : Nat, j < a.size ∧ isOddInt (a[j]!))",
                "postcond_aux": "",
                "postcond": "-- result equals (first even) - (first odd), where \"first\" means minimal index.\n  ∃ (i j : Nat),\n    i < a.size ∧ j < a.size ∧\n    isEvenInt (a[i]!) ∧ isOddInt (a[j]!) ∧\n    (∀ k : Nat, k < i → ¬ isEvenInt (a[k]!)) ∧\n    (∀ k : Nat, k < j → ¬ isOddInt (a[k]!)) ∧\n    result = a[i]! - a[j]!",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_25": {
          "data_id": "verina_basic_25",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Gauss' formula: 0 + 1 + ... + n = n * (n + 1) / 2\n  -- Compute the sum as an Int\n  let sumNat : Nat := (n * (n + 1)) / 2\n  let sumInt : Int := Int.ofNat sumNat\n\n  -- Compute the average as a Float; guard against n = 0 for totality,\n  -- although the precondition specifies n > 0.\n  let avg : Float :=\n    if n = 0 then\n      0.0\n    else\n      Float.ofInt sumInt / Float.ofNat n\n\n  (sumInt, avg)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- n must be positive and reasonably bounded to ensure precise Float averaging\n  0 < n ∧ n < 2 ^ 53",
                "postcond_aux": "",
                "postcond": "-- sumN is the sum of the first n natural numbers (1 through n), which equals n*(n+1)/2\n  -- The average is defined as sumN divided by n in Float\n  let sumN : Nat := (n * (n + 1)) / 2\n  result.fst = Int.ofNat sumN ∧\n  result.snd = (Float.ofNat sumN) / (Float.ofNat n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_25": {
          "data_id": "verina_advanced_25",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Replace the n-th element of a list with x (no-op if n ≥ l.length)\ndef replaceNth {α} : List α → Nat → α → List α\n  | [], _, _ => []\n  | _ :: ys, 0, x => x :: ys\n  | y :: ys, Nat.succ n, x => y :: replaceNth ys n x\n\n-- Find the first position i in l where l[i] ≥ x; if none, return l.length\ndef lowerPos (l : List Int) (x : Int) : Nat :=\n  let rec go (i : Nat) (l : List Int) : Nat :=\n    match l with\n    | [] => i\n    | y :: ys => if x ≤ y then i else go (i + 1) ys\n  go 0 l\n\n-- Update l at position pos with x if pos < l.length; otherwise append x\ndef updateOrAppend (l : List Int) (pos : Nat) (x : Int) : List Int :=\n  if pos < l.length then\n    replaceNth l pos x\n  else\n    l ++ [x]",
                "code": "-- Patience sorting approach with a list of tails (linear search version)\n  let tails :=\n    nums.foldl (init := ([] : List Int)) (fun acc x =>\n      let pos := lowerPos acc x\n      updateOrAppend acc pos x\n    )\n  tails.length",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_25",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictlyIncreasing : List Int → Prop\n  | [] => True\n  | [_] => True\n  | x :: y :: t => x < y ∧ StrictlyIncreasing (y :: t)\n\n@[reducible, simp]\ndef IsSubseq : List Int → List Int → Prop\n  | [], _ => True\n  | _ :: _, [] => False\n  | x :: xs, y :: ys => (x = y ∧ IsSubseq xs ys) ∨ IsSubseq (x :: xs) ys",
                "postcond": "-- Soundness: result is the length of some strictly increasing subsequence of nums\n  (∃ s : List Int, IsSubseq s nums ∧ StrictlyIncreasing s ∧ result = s.length)\n  ∧\n  -- Maximality: no strictly increasing subsequence of nums is longer than result\n  (∀ t : List Int, IsSubseq t nums → StrictlyIncreasing t → t.length ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_26": {
          "data_id": "verina_basic_26",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- An integer is even iff its remainder modulo 2 is zero\n  n % 2 == (0 : Int)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = decide (n % 2 = 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_26": {
          "data_id": "verina_advanced_26",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Map a keypad digit character to its corresponding list of letters.\n-- Digits outside '2'..'9' are invalid and return none.\ndef lettersForDigit (c : Char) : Option (List Char) :=\n  match c with\n  | '2' => some ['a', 'b', 'c']\n  | '3' => some ['d', 'e', 'f']\n  | '4' => some ['g', 'h', 'i']\n  | '5' => some ['j', 'k', 'l']\n  | '6' => some ['m', 'n', 'o']\n  | '7' => some ['p', 'q', 'r', 's']\n  | '8' => some ['t', 'u', 'v']\n  | '9' => some ['w', 'x', 'y', 'z']\n  | _   => none\n\n-- Given current accumulated combinations and a list of letters for the next digit,\n-- extend all combinations by appending each possible letter.\ndef extendCombinations (acc : List String) (letters : List Char) : List String :=\n  acc.bind (fun s => letters.map (fun ch => s.push ch))\n\n-- Build combinations from the input string using a left fold.\n-- Returns none if any character is invalid (not in '2'..'9').\ndef buildFromString (digits : String) : Option (List String) :=\n  digits.foldl\n    (init := some ([\"\"] : List String))\n    (fun oacc c =>\n      match oacc, lettersForDigit c with\n      | none, _ => none\n      | _, none => none\n      | some acc, some letters => some (extendCombinations acc letters)\n    )",
                "code": "-- If the input is empty, per the specification return an empty list\n  if digits.isEmpty then\n    []\n  else\n    -- Otherwise, attempt to build combinations; return [] on any invalid digit\n    match buildFromString digits with\n    | some res => res\n    | none => []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_26",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef lettersOfDigit (c : Char) : List Char :=\n  -- Mapping from digit characters to their corresponding letters\n  if c = '2' then ['a', 'b', 'c']\n  else if c = '3' then ['d', 'e', 'f']\n  else if c = '4' then ['g', 'h', 'i']\n  else if c = '5' then ['j', 'k', 'l']\n  else if c = '6' then ['m', 'n', 'o']\n  else if c = '7' then ['p', 'q', 'r', 's']\n  else if c = '8' then ['t', 'u', 'v']\n  else if c = '9' then ['w', 'x', 'y', 'z']\n  else []\n\n@[reducible, simp]\ndef combineAcc (acc : List String) (cs : List Char) : List String :=\n  -- Extend each string in acc with every character in cs\n  acc.bind (fun s => cs.map (fun c => s.push c))\n\n@[reducible, simp]\ndef expectedCombinations (digits : String) : List String :=\n  -- By specification: if input is empty, the output must be [].\n  if digits.isEmpty then []\n  else\n    let chars := digits.data\n    let acc0 : List String := [\"\"]\n    let acc := List.foldl\n      (fun acc c =>\n        let letters := lettersOfDigit c\n        if letters = [] then [] -- any invalid digit forces empty result\n        else combineAcc acc letters\n      ) acc0 chars\n    acc",
                "postcond": "result = expectedCombinations digits",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_27": {
          "data_id": "verina_basic_27",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper: check if a character is in a list of characters (Bool result)\ndef memChar (c : Char) (l : List Char) : Bool :=\n  match l with\n  | [] => false\n  | d :: ds => if c == d then true else memChar c ds\n\n-- Recursive helper to find the first repeated character by scanning left-to-right\ndef findFirstRepeatedCharAux (cs : List Char) (seen : List Char) : Option Char :=\n  match cs with\n  | [] => none\n  | c :: rest =>\n    if memChar c seen then\n      some c\n    else\n      findFirstRepeatedCharAux rest (c :: seen)",
                "code": "-- Convert the string to a list of characters and scan for the first duplicate\n  findFirstRepeatedCharAux s.data []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef repeatsAt (l : List Char) (j : Nat) : Prop :=\n  -- There is a character c at position j that has appeared before at some index i < j\n  ∃ c i, i < j ∧ l.get? j = some c ∧ l.get? i = some c\n\n@[reducible, simp]\ndef firstRepeatChar (l : List Char) (c : Char) : Prop :=\n  -- c is the character at the earliest index j where a repetition occurs\n  ∃ j, repeatsAt l j ∧ l.get? j = some c ∧ (∀ j', j' < j → ¬ repeatsAt l j')",
                "postcond": "let l := s.data\n  (result = none ↔ ¬ ∃ j, repeatsAt l j)\n  ∧\n  (∀ c, result = some c ↔ firstRepeatChar l c)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_27": {
          "data_id": "verina_advanced_27",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-\n  Build the DP table for LCS lengths.\n  dp[i][j] = length of LCS between prefixes a1[0..i-1] and a2[0..j-1]\n  Dimensions: (m+1) x (n+1), initialized with zeros.\n-/\ndef buildDP (a1 a2 : Array Char) : Array (Array Nat) :=\n  let m := a1.size\n  let n := a2.size\n  Id.run do\n    let zeroRow := Array.mkArray (n + 1) (0 : Nat)\n    let mut dp := Array.mkArray (m + 1) zeroRow\n    -- Fill rows 1..m\n    for i in [1 : m + 1] do\n      let prev := dp[i - 1]!\n      let mut row := dp[i]!\n      -- Fill columns 1..n\n      for j in [1 : n + 1] do\n        let val :=\n          if a1[i - 1]! == a2[j - 1]! then\n            prev[j - 1]! + 1\n          else\n            let up := prev[j]!\n            let left := row[j - 1]!\n            if up ≥ left then up else left\n        row := row.set! j val\n      dp := dp.set! i row\n    pure dp\n\n/-\n  Reconstruct one longest common subsequence using the DP table by backtracking\n  from (m, n) to (0, 0).\n  We accumulate characters in reverse order and reverse at the end.\n-/\ndef reconstructLCS (dp : Array (Array Nat)) (a1 a2 : Array Char) (m n : Nat) : List Char :=\n  Id.run do\n    let mut i := m\n    let mut j := n\n    let mut acc : List Char := []\n    -- Walk back while both indices are positive\n    while decide (i > 0 ∧ j > 0) do\n      let iIdx := i - 1\n      let jIdx := j - 1\n      let c1 := a1[iIdx]!\n      let c2 := a2[jIdx]!\n      if c1 == c2 then\n        acc := c1 :: acc\n        i := i - 1\n        j := j - 1\n      else\n        let up := dp[i - 1]![j]!\n        let left := dp[i]![j - 1]!\n        if up ≥ left then\n          i := i - 1\n        else\n          j := j - 1\n    pure acc",
                "code": "-- Convert strings to arrays of characters for efficient indexing\n  let a1 : Array Char := Array.mk s1.data\n  let a2 : Array Char := Array.mk s2.data\n\n  -- Build DP table\n  let dp := buildDP a1 a2\n\n  -- Reconstruct one LCS and convert to String\n  let lcsRev : List Char := reconstructLCS dp a1 a2 a1.size a2.size\n  String.mk lcsRev.reverse",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_27",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "-- A simple, generic subsequence relation on lists.\n@[reducible, simp]\ninductive ListSubseq {α : Type} : List α → List α → Prop where\n  -- The empty list is a subsequence of any list.\n  | nil {ys} : ListSubseq [] ys\n  -- We can skip elements in the supersequence.\n  | skip {x xs ys} : ListSubseq xs ys → ListSubseq xs (x :: ys)\n  -- Or match equal heads and continue.\n  | keep {x xs ys} : ListSubseq xs ys → ListSubseq (x :: xs) (x :: ys)\n\n-- Helper shorthands for working with strings as lists of characters and their lengths.\n@[reducible, simp]\ndef chars (s : String) : List Char := s.toList\n\n@[reducible, simp]\ndef clen (s : String) : Nat := (chars s).length",
                "postcond": "-- result is a common subsequence of s1 and s2 and is of maximum possible length.\n  (ListSubseq (chars result) (chars s1)) ∧\n  (ListSubseq (chars result) (chars s2)) ∧\n  (∀ t : String,\n    ListSubseq (chars t) (chars s1) →\n    ListSubseq (chars t) (chars s2) →\n    clen t ≤ clen result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_28": {
          "data_id": "verina_advanced_28",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Check whether a list of Int contains a given value (Boolean result)\ndef listContainsInt (l : List Int) (x : Int) : Bool :=\n  match l with\n  | [] => false\n  | y :: ys => if x == y then true else listContainsInt ys x\n\n-- Compute the length of the consecutive streak starting from `start`\n-- by checking presence of start, start+1, start+2, ...\ndef streakLenFrom (l : List Int) (start : Int) : Nat :=\n  let rec go (n : Int) (acc : Nat) : Nat :=\n    if listContainsInt l n then\n      go (n + 1) (acc + 1)\n    else\n      acc\n  go start 0",
                "code": "-- We only start counting from numbers that have no predecessor (x - 1) in the list.\n  let rec fold (xs : List Int) (best : Nat) : Nat :=\n    match xs with\n    | [] => best\n    | x :: xt =>\n      let best :=\n        if !listContainsInt nums (x - 1) then\n          let len := streakLenFrom nums x\n          if best < len then len else best\n        else\n          best\n      fold xt best\n  fold nums 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef chainLen (nums : List Int) (s : Int) (n : Nat) : Prop :=\n  ∀ t, t < n → s + Int.ofNat t ∈ nums",
                "postcond": "(∃ s, chainLen nums s result) ∧\n  (∀ s n, chainLen nums s n → n ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_28": {
          "data_id": "verina_basic_28",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Simple primality check:\n  -- For n < 2, return false. Otherwise, check divisibility by any k in [2, n-1].\n  if n < 2 then\n    false\n  else\n    let rec loop (k : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => true\n      | fuel' + 1 =>\n        if n % k == 0 then\n          false\n        else\n          loop (k + 1) fuel'\n    -- We need to test divisors from 2 up to n-1 inclusive.\n    -- Using fuel = n - 2 ensures exactly that many checks.\n    loop 2 (n - 2)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_28",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "2 ≤ n",
                "postcond_aux": "@[reducible, simp]\ndef divides (k n : Nat) : Prop :=\n  ∃ m, n = k * m",
                "postcond": "-- result is true iff there is no proper divisor k with 1 < k < n that divides n\n  (result = true) ↔ ¬ ∃ k, 1 < k ∧ k < n ∧ divides k n",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_29": {
          "data_id": "verina_advanced_29",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Association-list-based frequency map utilities\n\n-- Get the count of key x in map m\ndef getCount (m : List (Nat × Nat)) (x : Nat) : Nat :=\n  match m with\n  | [] => 0\n  | (k, v) :: t => if k = x then v else getCount t x\n\n-- Set the count of key x to c in map m (remove the key if c = 0)\ndef setCount (m : List (Nat × Nat)) (x : Nat) (c : Nat) : List (Nat × Nat) :=\n  match m with\n  | [] =>\n    if c = 0 then [] else [(x, c)]\n  | (k, v) :: t =>\n    if k = x then\n      if c = 0 then t else (x, c) :: t\n    else\n      (k, v) :: setCount t x c\n\n-- Increment the count of key x\ndef incCount (m : List (Nat × Nat)) (x : Nat) : List (Nat × Nat) :=\n  let c := getCount m x\n  setCount m x (c + 1)\n\n-- Decrement the count of key x (saturates at 0 and removes the key if it reaches 0)\ndef decCount (m : List (Nat × Nat)) (x : Nat) : List (Nat × Nat) :=\n  let c := getCount m x\n  if c = 0 then m else setCount m x (Nat.pred c)\n\n-- Shrink the window from the left while the count of x exceeds k.\n-- Returns updated (counts, window, windowLength).\ndef shrinkWhile (counts : List (Nat × Nat)) (w : List Nat) (wlen : Nat) (x k : Nat)\n    : (List (Nat × Nat)) × (List Nat) × Nat :=\n  if getCount counts x ≤ k then\n    (counts, w, wlen)\n  else\n    match w with\n    | [] => (counts, [], 0) -- Should not happen, but safe fallback\n    | y :: ys =>\n      let counts1 := decCount counts y\n      let wlen1 := Nat.pred wlen\n      shrinkWhile counts1 ys wlen1 x k",
                "code": "-- Sliding window with an association-list frequency map.\n  -- Maintain:\n  -- - window: current subarray (as a List)\n  -- - wlen: its cached length\n  -- - counts: frequencies within the window\n  -- - best: best length found so far\n  let rec go (rest : List Nat) (window : List Nat) (wlen : Nat)\n             (counts : List (Nat × Nat)) (best : Nat) : Nat :=\n    match rest with\n    | [] => best\n    | x :: xs =>\n      -- Extend window to the right with x\n      let counts1 := incCount counts x\n      let window1 := window ++ [x]\n      let wlen1 := wlen + 1\n      -- Shrink from the left while x's frequency exceeds k\n      let (counts2, window2, wlen2) := shrinkWhile counts1 window1 wlen1 x k\n      -- Update best and continue\n      let best1 := Nat.max best wlen2\n      go xs window2 wlen2 counts2 best1\n  go nums [] 0 [] 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef isSubarray (a s : List Nat) : Prop :=\n  ∃ l r, a = l ++ s ++ r\n\n@[reducible, simp]\ndef freq (s : List Nat) (x : Nat) : Nat :=\n  (s.filter (fun y => y = x)).length\n\n@[reducible, simp]\ndef Good (s : List Nat) (k : Nat) : Prop :=\n  ∀ x, freq s x ≤ k",
                "postcond": "let P : List Nat → Prop := fun s => isSubarray nums s ∧ s ≠ [] ∧ Good s k\n  in\n  ((result = 0) ∧ (¬ ∃ s, P s))\n  ∨\n  (∃ s, P s ∧ s.length = result ∧ ∀ t, P t → t.length ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_29": {
          "data_id": "verina_basic_29",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Append two arrays of Int while preserving order\ndef appendIntArrays (a b : Array Int) : Array Int :=\n  b.foldl (fun acc x => acc.push x) a",
                "code": "-- Split the array into the prefix before k and the suffix after k\n  let prefix := s.extract 0 k\n  let suffix := s.extract (k + 1) s.size\n  -- Concatenate prefix and suffix to remove the element at index k\n  appendIntArrays prefix suffix",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_29",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- k must be a valid index into s\n  k < s.size",
                "postcond_aux": "",
                "postcond": "-- Size decreases by exactly one\n  result.size = s.size - 1\n  ∧\n  -- Elements before k remain unchanged\n  (∀ i, i < k → result[i]! = s[i]!)\n  ∧\n  -- Elements at and after k are shifted left by one\n  (∀ i, k ≤ i → i < result.size → result[i]! = s[i + 1]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_30": {
          "data_id": "verina_basic_30",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute element-wise modulo using the same indices.\n  -- Precondition guarantees: a.size = b.size and all b[i] ≠ 0.\n  a.mapIdx (fun i x => x % b[i]!)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- Arrays are values in Lean (non-null by construction).\n  -- Require equal lengths and no zero divisors in b.\n  a.size = b.size ∧ (∀ i : Nat, i < b.size → b[i]! ≠ 0)",
                "postcond_aux": "",
                "postcond": "-- The result has the same length as inputs,\n  -- and each entry is the element-wise modulo of a and b.\n  result.size = a.size ∧\n  (∀ i : Nat, i < result.size → result[i]! = a[i]! % b[i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_30": {
          "data_id": "verina_advanced_30",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to compute the maximum of two natural numbers without relying on extra imports\ndef maxNat (a b : Nat) : Nat :=\n  if a < b then b else a\n\n-- Tail-recursive helper that traverses the list, keeping track of:\n-- prev: previous integer in the current streak\n-- curr: current increasing streak length\n-- maxSoFar: maximum streak length seen so far\n-- rest: remaining list to process\ndef longestIncreasingStreak_go (prev : Int) (curr maxSoFar : Nat) (rest : List Int) : Nat :=\n  match rest with\n  | [] => maxNat maxSoFar curr\n  | y :: ys =>\n    let curr' := if prev < y then curr + 1 else 1\n    let max'  := maxNat maxSoFar curr'\n    longestIncreasingStreak_go y curr' max' ys",
                "code": "match nums with\n  | [] => 0\n  | x :: xs =>\n    -- Start with a streak of length 1 at the first element.\n    longestIncreasingStreak_go x 1 1 xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_30",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictInc : List Int → Prop\n| [] => True\n| [_] => True\n| x :: y :: xs => x < y ∧ StrictInc (y :: xs)",
                "postcond": "-- result is the maximum length among all strictly-increasing contiguous sublists\n  (∀ pre mid suf, nums = pre ++ mid ++ suf → StrictInc mid → mid.length ≤ result)\n  ∧ (∃ pre mid suf, nums = pre ++ mid ++ suf ∧ StrictInc mid ∧ result = mid.length)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_31": {
          "data_id": "verina_advanced_31",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "/--\nreplaceFirstGE x ts:\n  Given a sorted (increasing) list ts of \"tails\" values, replace the first element\n  greater than or equal to x with x. If no such element exists, append x at the end.\n  This is the standard step in the patience sorting algorithm for LIS (strictly increasing).\n-/\ndef replaceFirstGE (x : Int) : List Int → List Int\n  | [] => [x]\n  | y :: ys =>\n    if x ≤ y then\n      x :: ys\n    else\n      y :: replaceFirstGE x ys",
                "code": "let tails := xs.foldl (fun ts x => replaceFirstGE x ts) []\n  tails.length",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictlyIncreasing (ys : List Int) : Prop :=\n  -- Adjacent strictly increasing across the list\n  match ys with\n  | [] => True\n  | [_] => True\n  | x :: y :: zs => x < y ∧ StrictlyIncreasing (y :: zs)\n\n@[reducible, simp]\ndef IsSubseq (ys xs : List Int) : Prop :=\n  -- ys is a subsequence of xs (obtained by deleting zero or more elements without reordering)\n  match ys, xs with\n  | [], _ => True\n  | _ :: _, [] => False\n  | y :: ys', x :: xs' =>\n      (y = x ∧ IsSubseq ys' xs') ∨ IsSubseq (y :: ys') xs'",
                "postcond": "-- result is exactly the maximum length of a strictly increasing subsequence of xs\n  (∃ ys : List Int, IsSubseq ys xs ∧ StrictlyIncreasing ys ∧ ys.length = result) ∧\n  (∀ ys : List Int, IsSubseq ys xs ∧ StrictlyIncreasing ys → ys.length ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_31": {
          "data_id": "verina_basic_31",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Convert a single ASCII lowercase letter to uppercase; leave all other chars unchanged.\ndef toUpperAscii (c : Char) : Char :=\n  let n := c.toNat\n  let a := 'a'.toNat\n  let z := 'z'.toNat\n  let A := 'A'.toNat\n  if (Nat.ble a n) && (Nat.ble n z) then\n    -- In the range 'a'..'z': shift by the ASCII delta to reach 'A'..'Z'\n    Char.ofNat (n - (a - A))\n  else\n    c",
                "code": "-- Map each character using our ASCII uppercasing and rebuild the string.\n  String.mk (s.data.map toUpperAscii)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_31",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef toUpperASCII (c : Char) : Char :=\n  if 'a' ≤ c ∧ c ≤ 'z' then\n    Char.ofNat (c.toNat - 32)\n  else\n    c",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.data = s.data.map toUpperASCII ∧ result.length = s.length",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_32": {
          "data_id": "verina_advanced_32",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Dynamic programming in O(n^2):\n  -- For each element x, compute the length of the longest increasing subsequence\n  -- that ends at x using previously computed lengths, then take the maximum.\n  let rec maxLenLess (state : List (Int × Nat)) (x : Int) : Nat :=\n    match state with\n    | [] => 0\n    | (y, l) :: ys =>\n      let tailMax := maxLenLess ys x\n      if y < x then\n        if l > tailMax then l else tailMax\n      else\n        tailMax\n\n  let rec process (nums : List Int) (state : List (Int × Nat)) (best : Nat) : Nat :=\n    match nums with\n    | [] => best\n    | x :: xs =>\n      let bestEndHere := maxLenLess state x + 1\n      let best' := if bestEndHere > best then bestEndHere else best\n      process xs ((x, bestEndHere) :: state) best'\n\n  process numbers [] 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictlyIncreasing : List Int → Prop\n| [] => True\n| _ :: [] => True\n| x :: y :: zs => x < y ∧ StrictlyIncreasing (y :: zs)\n\n@[reducible, simp]\ninductive Subseq : List Int → List Int → Prop where\n| nil (s : List Int) : Subseq [] s\n| cons {l s} (a : Int) (h : Subseq l s) : Subseq l (a :: s)\n| cons₂ {l s} (a : Int) (h : Subseq l s) : Subseq (a :: l) (a :: s)",
                "postcond": "(∃ s : List Int, Subseq s numbers ∧ StrictlyIncreasing s ∧ s.length = result)\n  ∧ (∀ t : List Int, Subseq t numbers → StrictlyIncreasing t → t.length ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_32": {
          "data_id": "verina_basic_32",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Handle arrays of size 0 or 1: swapping has no effect\n  let n := a.size\n  if n ≤ 1 then\n    a\n  else\n    -- Fetch first and last elements safely using indexing with \"!\"\n    let first := a[0]!\n    let last := a[n - 1]!\n    -- Create a new array by swapping the first and last elements\n    let b := a.set! 0 last\n    b.set! (n - 1) first",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_32",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The array must be non-empty to swap first and last elements.\n  0 < a.size",
                "postcond_aux": "",
                "postcond": "-- Same length as input\n  result.size = a.size ∧\n  -- Element-wise relationship: first and last are swapped, others unchanged\n  (∀ i, i < a.size →\n    result[i]! =\n      if i = 0 then\n        a[a.size - 1]!\n      else if i = a.size - 1 then\n        a[0]!\n      else\n        a[i]!\n  )",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_33": {
          "data_id": "verina_advanced_33",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Returns the index of the first element in l that is >= x.\n-- If no such element exists, returns l.length.\ndef lowerBound (l : List Int) (x : Int) : Nat :=\n  let rec go (l : List Int) (i : Nat) : Nat :=\n    match l with\n    | [] => i\n    | y :: ys =>\n      if x ≤ y then\n        i\n      else\n        go ys (i + 1)\n  go l 0\n\n-- Replace the element at index n with x (if it exists).\n-- If n >= l.length, the list is returned unchanged.\ndef replaceNth {α} (l : List α) (n : Nat) (x : α) : List α :=\n  match l, n with\n  | [], _ => []\n  | _ :: xs, 0 => x :: xs\n  | y :: xs, Nat.succ k => y :: replaceNth xs k x\n\n-- One step of the patience sorting approach:\n-- Maintain a list \"tails\" where tails[k] is the minimum possible tail\n-- of an increasing subsequence of length k+1.\ndef lisStep (tails : List Int) (x : Int) : List Int :=\n  let idx := lowerBound tails x\n  let len := tails.length\n  if idx == len then\n    -- x extends the longest subsequence so far\n    tails ++ [x]\n  else\n    -- x improves the tail for length idx+1\n    replaceNth tails idx x",
                "code": "let tails := nums.foldl lisStep []\n  tails.length",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "-- Strictly increasing predicate for lists of Int:\n@[reducible, simp]\ndef StrictInc : List Int → Prop\n  | [] => True\n  | [_] => True\n  | x :: y :: xs => x < y ∧ StrictInc (y :: xs)\n\n-- Subsequence relation specialized to List Int.\ninductive SubseqInt : List Int → List Int → Prop\n  | nil (l : List Int) : SubseqInt [] l\n  | cons_left {s l a} : SubseqInt s l → SubseqInt s (a :: l)\n  | cons_both {s l a} : SubseqInt s l → SubseqInt (a :: s) (a :: l)\n\n-- Convenient reducible alias with simp attribute.\n@[reducible, simp]\ndef isSubseq (s t : List Int) : Prop :=\n  SubseqInt s t",
                "postcond": "-- result is exactly the maximum length of a strictly increasing subsequence of nums\n  (∃ s : List Int, isSubseq s nums ∧ StrictInc s ∧ s.length = result) ∧\n  (∀ s : List Int, isSubseq s nums ∧ StrictInc s → s.length ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_33": {
          "data_id": "verina_basic_33",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper that walks the sorted list while tracking the current expected number.\n-- - expect is the smallest number we are still looking for.\n-- - If the head equals expect, we increment expect and continue.\n-- - If the head is greater than expect, expect is missing and we return it.\n-- - If the head is less than expect (possible due to duplicates), we skip it.\ndef smallestMissingNumberAux (s : List Nat) (expect : Nat) : Nat :=\n  match s with\n  | [] => expect\n  | x :: xs =>\n    if hEq : x = expect then\n      smallestMissingNumberAux xs (expect + 1)\n    else\n      -- Not equal to expect; decide the order to know whether expect is missing\n      if hLt : expect < x then\n        expect\n      else\n        -- Here we have x ≤ expect and x ≠ expect, hence x < expect; skip x\n        smallestMissingNumberAux xs expect",
                "code": "-- Start searching from 0 as the first candidate\n  smallestMissingNumberAux s 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_33",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- result is the smallest natural number not appearing in s:\n  --   1) result is not in s\n  --   2) every natural number smaller than result is in s\n  result ∉ s ∧ ∀ m : Nat, m < result → m ∈ s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_34": {
          "data_id": "verina_basic_34",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to check evenness for Int\ndef isEven (n : Int) : Bool :=\n  n % 2 == 0",
                "code": "-- Build a new array by collecting only even numbers, preserving order\n  Id.run do\n    let mut res : Array Int := Array.mkEmpty arr.size\n    for x in arr do\n      if isEven x then\n        res := res.push x\n    pure res",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef EvenInt (n : Int) : Prop :=\n  n % 2 = 0",
                "postcond": "∃ f : Nat → Nat,\n    -- f maps each index of the result to an index in the input\n    (∀ k, k < result.size → f k < arr.size) ∧\n    -- f is strictly increasing on the valid index range, preserving order and preventing duplicates\n    (∀ k₁ k₂, k₁ < k₂ → k₂ < result.size → f k₁ < f k₂) ∧\n    -- result elements are exactly the input elements at the mapped indices\n    (∀ k, k < result.size → result[k]! = arr[f k]!) ∧\n    -- exact correspondence: an input index is even iff it is hit by some result index\n    (∀ j, j < arr.size → (EvenInt (arr[j]!)) ↔ (∃ k, k < result.size ∧ f k = j))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_34": {
          "data_id": "verina_advanced_34",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-\n  Helper that scans the list of previously processed (value, lisLengthEndingHere)\n  pairs and returns the maximum lisLengthEndingHere among those with value < curr.\n-/\ndef maxLenLessThan (curr : Int) (processed : List (Int × Nat)) : Nat :=\n  let rec go (ps : List (Int × Nat)) (acc : Nat) : Nat :=\n    match ps with\n    | [] => acc\n    | (v, l) :: rest =>\n      let acc' := if v < curr then Nat.max acc l else acc\n      go rest acc'\n  go processed 0\n\n/-\n  O(n^2) dynamic programming for LIS length.\n  processed stores all previous elements paired with the LIS length ending at that element.\n  best stores the best LIS length found so far.\n-/\ndef lisAux (nums : List Int) (processed : List (Int × Nat)) (best : Nat) : Nat :=\n  match nums with\n  | [] => best\n  | x :: xs =>\n    let prevMax := maxLenLessThan x processed\n    let dp := prevMax + 1\n    let best' := Nat.max best dp\n    lisAux xs ((x, dp) :: processed) best'",
                "code": "let best := lisAux nums [] 0\n  Int.ofNat best",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_34",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef StrictIncListNat : List Nat → Prop\n| [] => True\n| _ :: [] => True\n| x :: y :: zs => x < y ∧ StrictIncListNat (y :: zs)\n\n@[reducible, simp]\ndef StrictIncListInt : List Int → Prop\n| [] => True\n| _ :: [] => True\n| x :: y :: zs => x < y ∧ StrictIncListInt (y :: zs)\n\n@[reducible, simp]\ndef Picks (nums : List Int) : List Nat → List Int → Prop\n| [], [] => True\n| i :: is, x :: xs => nums.get? i = some x ∧ Picks nums is xs\n| _, _ => False",
                "postcond": "∃ r : Nat,\n    result = Int.ofNat r ∧\n    (∃ idxs vals,\n      StrictIncListNat idxs ∧\n      Picks nums idxs vals ∧\n      StrictIncListInt vals ∧\n      vals.length = r) ∧\n    (∀ idxs vals,\n      StrictIncListNat idxs ∧\n      Picks nums idxs vals ∧\n      StrictIncListInt vals →\n      vals.length ≤ r)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_35": {
          "data_id": "verina_advanced_35",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Boyer-Moore Majority Vote algorithm\n  let step := fun (state : Int × Nat) (x : Int) =>\n    let cand := state.fst\n    let cnt := state.snd\n    if cnt == 0 then\n      (x, 1)\n    else if x == cand then\n      (cand, cnt + 1)\n    else\n      (cand, cnt - 1)\n  let (cand, _) := nums.foldl step (0, 0)\n  cand",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef countOcc (x : Int) : List Int → Nat\n  -- Count occurrences of x in the list\n  | []       => 0\n  | y :: ys  => (if y = x then 1 else 0) + countOcc x ys",
                "precond": "-- The input is assumed to contain a majority element\n  ∃ x : Int, countOcc x nums > nums.length / 2",
                "postcond_aux": "",
                "postcond": "-- The result must be a majority element: it appears more than ⌊n/2⌋ times.\n  countOcc result nums > nums.length / 2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_35": {
          "data_id": "verina_basic_35",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Stable partition: collect nonzero elements and count zeros\n  let acc : Array Int × Nat :=\n    arr.foldl\n      (fun (p : Array Int × Nat) (x : Int) =>\n        if x == (0 : Int) then\n          (p.fst, p.snd + 1)\n        else\n          (p.fst.push x, p.snd))\n      (#[], 0)\n\n  let nonzeros := acc.fst\n  let zeroCount := acc.snd\n\n  -- Create an array of zeros with the same count as in the input\n  let zeros := Array.mkArray zeroCount (0 : Int)\n\n  -- Append zeros at the end, preserving the relative order of nonzeros\n  nonzeros.append zeros",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_35",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef nonzeros (a : Array Int) : List Int :=\n  a.toList.filter (fun x => x ≠ 0)",
                "postcond": "let nz := nonzeros arr\n  result.size = arr.size ∧\n  result.toList = nz ++ List.replicate (arr.size - nz.length) 0",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_36": {
          "data_id": "verina_basic_36",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to decide whether a character should be replaced by a colon\ndef shouldReplace (c : Char) : Bool :=\n  (c == ' ') || (c == ',') || (c == '.')",
                "code": "-- Map over characters in the string, replacing spaces, commas, and dots with colons\n  s.map (fun c => if shouldReplace c then ':' else c)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef replaceMap (c : Char) : Char :=\n  -- Map spaces, commas, and dots to colon; leave all other characters unchanged.\n  if c = ' ' ∨ c = ',' ∨ c = '.' then ':' else c",
                "postcond": "-- Same length and pointwise character mapping via get? over all indices.\n  result.length = s.length ∧ (∀ i, result.get? i = Option.map replaceMap (s.get? i))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_36": {
          "data_id": "verina_advanced_36",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Boyer-Moore majority vote algorithm\n  let rec go (ys : List Nat) (cand : Nat) (cnt : Nat) : Nat :=\n    match ys with\n    | [] => cand\n    | y :: ys' =>\n      if cnt == 0 then\n        go ys' y 1\n      else if y == cand then\n        go ys' cand (cnt + 1)\n      else\n        go ys' cand (cnt - 1)\n  match xs with\n  | [] => 0  -- Unreachable given the precondition (majority exists), but a total definition is required.\n  | x :: xs' => go xs' x 1",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_36",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef countOcc (xs : List Nat) (x : Nat) : Nat :=\n  -- Number of occurrences of x in xs\n  match xs with\n  | [] => 0\n  | y :: ys => (if y = x then 1 else 0) + countOcc ys x",
                "precond": "∃ x, countOcc xs x > xs.length / 2",
                "postcond_aux": "",
                "postcond": "(countOcc xs result > xs.length / 2) ∧ (∀ y, countOcc xs y > xs.length / 2 → y = result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_37": {
          "data_id": "verina_advanced_37",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Boyer–Moore majority vote algorithm using a single pass (fold)\n  -- We maintain an optional candidate and a nonnegative count (Nat).\n  -- Since a majority element is guaranteed to exist, the final candidate is the answer.\n  let (cand?, _) :=\n    nums.foldl\n      (fun (state : Option Int × Nat) (x : Int) =>\n        let (cand?, cnt) := state\n        match cand? with\n        | none =>\n          -- No current candidate: choose x as candidate with count 1\n          (some x, 1)\n        | some c =>\n          if x == c then\n            -- Same as candidate: increase count\n            (some c, cnt + 1)\n          else\n            -- Different from candidate: decrease or reset if count hits zero\n            if cnt == 0 then\n              (some x, 1)\n            else\n              (some c, cnt - 1))\n      (none, 0)\n  -- By precondition, a majority element exists, so cand? is some value.\n  -- We still provide a fallback (0) to satisfy totality.\n  match cand? with\n  | some c => c\n  | none => 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef countEq (x : Int) : List Int → Nat\n| [] => 0\n| y :: ys => if y = x then countEq x ys + 1 else countEq x ys\n\n@[reducible, simp]\ndef isMajority (nums : List Int) (x : Int) : Prop :=\n  countEq x nums > nums.length / 2",
                "postcond": "-- result must be the unique element that appears more than ⌊n/2⌋ times\n  isMajority nums result ∧ ∀ y : Int, isMajority nums y → y = result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_37": {
          "data_id": "verina_basic_37",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "/-\n    We perform a simple linear scan from left to right and return the index\n    (as an Int) of the first occurrence of `target`. If not found, return -1.\n    This does not modify the input array.\n  -/\n  partial def loop (i : Nat) : Int :=\n    if h : i < arr.size then\n      if arr[i]! == target then\n        Int.ofNat i\n      else\n        loop (i + 1)\n    else\n      -1\n  loop 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_37",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The array must be sorted in non-decreasing order.\n  ∀ i, i < arr.size - 1 → arr[i]! ≤ arr[i + 1]!",
                "postcond_aux": "",
                "postcond": "-- Either:\n  -- 1) result = -1 and the target does not occur in the array, or\n  -- 2) result is the first index (as an Int) where target occurs.\n  (result = -1 ∧ ∀ i, i < arr.size → arr[i]! ≠ target)\n  ∨\n  (∃ i : Nat,\n      i < arr.size ∧\n      arr[i]! = target ∧\n      (∀ j : Nat, j < i → arr[j]! ≠ target) ∧\n      result = Int.ofNat i)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_38": {
          "data_id": "verina_advanced_38",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Compute the minimum start among intervals, if any\ndef minStartOpt (xs : List (Prod Nat Nat)) : Option Nat :=\n  match xs with\n  | [] => none\n  | (l, _) :: t =>\n      some <| List.foldl (fun acc p => Nat.min acc p.fst) l t\n\n-- Compute the maximum end among intervals, if any\ndef maxEndOpt (xs : List (Prod Nat Nat)) : Option Nat :=\n  match xs with\n  | [] => none\n  | (_, r) :: t =>\n      some <| List.foldl (fun acc p => Nat.max acc p.snd) r t\n\n-- Span of a list of intervals defined as (maxEnd - minStart), or 0 if empty\ndef coverageSpan (xs : List (Prod Nat Nat)) : Nat :=\n  match minStartOpt xs, maxEndOpt xs with\n  | some mn, some mx =>\n      if mn ≤ mx then\n        mx - mn\n      else\n        0\n  | _, _ => 0\n\n-- Remove the element at index i (0-based). If i ≥ length, return the original list.\ndef removeAtIdx {α} : List α -> Nat -> List α\n  | [], _ => []\n  | _ :: xs, 0 => xs\n  | x :: xs, Nat.succ i => x :: removeAtIdx xs i",
                "code": "-- We iterate over all indices, remove that interval, and compute the span of the rest,\n  -- keeping the maximum over all choices.\n  let n := intervals.length\n  let rec loop (idx remaining best : Nat) : Nat :=\n    match remaining with\n    | 0 => best\n    | Nat.succ r =>\n        let rest := removeAtIdx intervals idx\n        let val := coverageSpan rest\n        loop (idx + 1) r (Nat.max best val)\n  loop 0 n 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- We assume there is at least one interval to remove.\n  intervals ≠ []",
                "postcond_aux": "@[reducible, simp]\ndef halfOpen (p : Prod Nat Nat) : Finset Nat :=\n  -- Points covered by the half-open interval [l, r)\n  let l := p.fst\n  let r := p.snd\n  (Finset.range (r - l)).image (fun k => l + k)\n\n@[reducible, simp]\ndef coveredPoints (intervals : List (Prod Nat Nat)) : Finset Nat :=\n  -- Union of points covered by all half-open intervals in the list\n  intervals.foldl (fun acc p => acc ∪ halfOpen p) (∅ : Finset Nat)\n\n@[reducible, simp]\ndef coverage (intervals : List (Prod Nat Nat)) : Nat :=\n  -- Total span (cardinality) of the union of all covered points\n  (coveredPoints intervals).card",
                "postcond": "-- The result equals the maximum possible coverage after removing exactly one interval.\n  -- Achievability: result is achieved by removing some interval.\n  -- Maximality: no single-interval removal yields coverage larger than result.\n  (∃ p s x, intervals = p ++ x :: s ∧ result = coverage (p ++ s)) ∧\n  (∀ p s x, intervals = p ++ x :: s → coverage (p ++ s) ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_38": {
          "data_id": "verina_basic_38",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper that checks whether every element of the list equals the given character.\ndef allCharsEqFrom (c : Char) : List Char → Bool\n| [] => true\n| d :: ds => (d == c) && allCharsEqFrom c ds",
                "code": "-- Convert the string to a list of characters and compare all with the first one.\n  let chars := s.toList\n  match chars with\n  | [] => true                   -- Empty string: trivially all identical\n  | c :: cs => allCharsEqFrom c cs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_38",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- result is true iff all characters in the string are identical.\n  result = true ↔\n    match s.toList with\n    | [] => True                    -- empty string: vacuously all identical\n    | c :: cs => ∀ d ∈ cs, d = c    -- all remaining chars equal the first one",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_39": {
          "data_id": "verina_basic_39",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/--\nSplit a list at a given index `n`, returning a pair `(prefix, suffix)` such that\n`prefix.length = min n l.length` and `prefix ++ suffix = l`.\nIf `n` exceeds the list length, the suffix will be `[]`.\n-/\ndef splitAtN {α} : Nat → List α → (List α × List α)\n| 0, xs => ([], xs)\n| Nat.succ n, [] => ([], [])\n| Nat.succ n, x :: xs =>\n  let (pre, suf) := splitAtN n xs\n  (x :: pre, suf)",
                "code": "-- Handle the empty list early: rotating an empty list yields an empty list.\n  match l with\n  | [] => []\n  | _ =>\n    let len := l.length\n    -- Compute effective rotation steps modulo length to avoid unnecessary cycles.\n    let k := n % len\n    if k = 0 then\n      -- No rotation needed if k is 0.\n      l\n    else\n      -- Rotate right by k is equivalent to moving the last k elements to the front.\n      let m := len - k\n      let (pre, suf) := splitAtN m l\n      suf ++ pre",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef rightRotate (l : List Int) (n : Nat) : List Int :=\n  -- Rotate right by r = n % l.length\n  -- For empty lists, this reduces to l.drop 0 ++ l.take 0 = l\n  let len := l.length\n  let r := n % len\n  let k := len - r\n  l.drop k ++ l.take k",
                "postcond": "result = rightRotate l n ∧ result.length = l.length",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_39": {
          "data_id": "verina_advanced_39",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Since the list is non-empty by precondition, we can safely take the head as the initial maximum.\n  -- The empty case is unreachable but included for totality.\n  match lst with\n  | [] => 0\n  | x :: xs => xs.foldl Nat.max x",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_39",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "lst ≠ []",
                "postcond_aux": "@[reducible, simp]\ndef InList (x : Nat) : List Nat → Prop\n  | [] => False\n  | y :: ys => x = y ∨ InList x ys",
                "postcond": "InList result lst ∧ (∀ y, InList y lst → y ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_40": {
          "data_id": "verina_basic_40",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We scan the array once, keeping track of the smallest (m1)\n  -- and the second-smallest (m2?) distinct values seen so far.\n  -- Precondition guarantees: size ≥ 2 and at least two distinct values exist.\n  let result := Id.run do\n    let mut i := 1\n    let mut m1 := s[0]!\n    let mut m2? : Option Int := none\n    while i < s.size do\n      let x := s[i]!\n      if x == m1 then\n        pure ()\n      else\n        match m2? with\n        | none =>\n          -- First value distinct from m1 encountered initializes m2?\n          if x < m1 then\n            m2? := some m1\n            m1 := x\n          else\n            m2? := some x\n        | some m2 =>\n          -- Update minima if needed\n          if x < m1 then\n            m2? := some m1\n            m1 := x\n          else if x < m2 then\n            m2? := some x\n          else\n            pure ()\n      i := i + 1\n    -- By precondition, m2? is some; fallback is theoretically unreachable.\n    match m2? with\n    | some m2 => pure m2\n    | none => pure m1\n  result",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- At least two elements and at least two distinct values exist in the array.\n  s.size ≥ 2 ∧ ∃ i j, i < s.size ∧ j < s.size ∧ i ≠ j ∧ s[i]! ≠ s[j]!",
                "postcond_aux": "",
                "postcond": "-- There is a minimum element at index iMin,\n  -- and result is the smallest element strictly larger than that minimum.\n  ∃ iMin, iMin < s.size ∧\n    (∀ j, j < s.size → s[iMin]! ≤ s[j]!) ∧\n    ∃ iRes, iRes < s.size ∧\n      s[iRes]! = result ∧\n      s[iMin]! < result ∧\n      (∀ j, j < s.size → s[iMin]! < s[j]! → result ≤ s[j]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_40": {
          "data_id": "verina_advanced_40",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Tail-recursive helper: carries the current maximum as an accumulator\ndef maxListAux (m : Nat) (xs : List Nat) : Nat :=\n  match xs with\n  | []      => m\n  | y :: ys => maxListAux (Nat.max m y) ys",
                "code": "-- Since the list is non-empty by precondition, we can safely start with its head.\n  -- We still pattern match defensively; the empty case returns 0 as a fallback.\n  match lst with\n  | []      => 0\n  | x :: xs => maxListAux x xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_40",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The list must be non-empty to have a maximum\n  lst ≠ []",
                "postcond_aux": "",
                "postcond": "-- result is a maximum element of the list:\n  -- - it appears in the list\n  -- - it is an upper bound for all elements of the list\n  result ∈ lst ∧ ∀ x, x ∈ lst → x ≤ result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_41": {
          "data_id": "verina_basic_41",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Return true if the array is empty or all elements are identical\n  if a.isEmpty then\n    true\n  else\n    let first := a[0]!\n    -- Check all elements against the first one using a simple structurally recursive loop\n    let rec go (i : Nat) (n : Nat) : Bool :=\n      match n with\n      | 0 => true\n      | Nat.succ n' =>\n        if a[i]! == first then\n          go (i + 1) n'\n        else\n          false\n    -- Start from index 0 and cover exactly `a.size` elements\n    go 0 a.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- True exactly when the array is empty or all its elements are identical.\n  -- This pairwise-equality characterization works uniformly for empty and non-empty arrays.\n  result ↔ (∀ i j, i < a.size → j < a.size → a[i]! = a[j]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_41": {
          "data_id": "verina_advanced_41",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute the maximum of the three integers using conditional comparisons\n  let m1 := if h1 : a >= b then a else b\n  let m2 := if h2 : m1 >= c then m1 else c\n  m2",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_41",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result must be one of the inputs and at least as large as each input.\n  (result = a ∨ result = b ∨ result = c) ∧ a ≤ result ∧ b ≤ result ∧ c ≤ result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_42": {
          "data_id": "verina_advanced_42",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Handle empty list: no transaction possible, profit is 0\n  match prices with\n  | [] => 0\n  | p :: ps =>\n    -- Fold through the remaining prices, tracking:\n    -- - mn: the minimum price seen so far (before the current day)\n    -- - best: the best profit found so far\n    let (_, best) :=\n      ps.foldl\n        (fun (acc : Nat × Nat) (price : Nat) =>\n          let (mn, best) := acc\n          -- Profit if we sell today having bought at the minimum prior price\n          let profit := price - mn\n          -- Update best profit\n          let best' := if profit > best then profit else best\n          -- Update minimum price seen so far\n          let mn' := if price < mn then price else mn\n          (mn', best'))\n        (p, 0)\n    best",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef profit (prices : List Nat) (i j : Fin prices.length) : Nat :=\n  -- Profit when buying at index i and selling later at index j\n  prices.get j - prices.get i\n\n@[reducible, simp]\ndef achievableProfit (prices : List Nat) (p : Nat) : Prop :=\n  -- p is achievable if there exists a valid pair of indices i < j\n  -- such that p equals the corresponding profit.\n  ∃ (i j : Fin prices.length), i < j ∧ p = profit prices i j",
                "postcond": "-- result is the maximum achievable profit if any pair exists,\n  -- otherwise it is 0 when no valid (i < j) pair exists.\n  (∀ p, achievableProfit prices p → p ≤ result)\n  ∧\n  ((∃ p, achievableProfit prices p) →\n     ∃ (i j : Fin prices.length), i < j ∧ result = profit prices i j)\n  ∧\n  ((¬ ∃ p, achievableProfit prices p) → result = 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_42": {
          "data_id": "verina_basic_42",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to check if a character is an ASCII digit '0'..'9'\ndef isAsciiDigit (c : Char) : Bool :=\n  if '0' ≤ c ∧ c ≤ '9' then true else false",
                "code": "-- Fold over the characters of the string and count ASCII digits\n  s.data.foldl (fun acc c => if isAsciiDigit c then acc + 1 else acc) 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_42",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef isDigitChar (c : Char) : Prop :=\n  ('0' ≤ c) ∧ (c ≤ '9')\n\n@[reducible, simp]\ndef countDigitsSpec (s : String) : Nat :=\n  s.foldl (fun acc c => acc + (if isDigitChar c then 1 else 0)) 0",
                "postcond": "result = countDigitsSpec s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_43": {
          "data_id": "verina_basic_43",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Compute the 4th power of a natural number without relying on ^ notation\n@[inline] def fourthPower (t : Nat) : Nat :=\n  t * t * t * t\n\n-- The k-th odd number is 2k + 1; take its 4th power\n@[inline] def oddFourth (k : Nat) : Nat :=\n  fourthPower (2 * k + 1)",
                "code": "-- Sum over k = 0 .. n-1 of (2k + 1)^4 using primitive recursion on n\n  Nat.rec\n    (motive := fun _ => Nat)\n    0\n    (fun k acc => acc + oddFourth k)\n    n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef oddFourthSum : Nat → Nat\n| 0 => 0\n| (n+1) => oddFourthSum n + (2 * n + 1) ^ 4",
                "postcond": "-- The result is exactly the sum of the fourth powers of the first n odd numbers,\n  -- and it satisfies the known closed-form identity (avoiding division by 15 by cross-multiplying).\n  result = oddFourthSum n ∧\n  15 * result = n * (2 * n - 1) * (2 * n + 1) * (12 * n * n - 7)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_43": {
          "data_id": "verina_advanced_43",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper: maximum of two Ints\ndef maxInt (a b : Int) : Int :=\n  if h : a < b then b else a\n\n-- Helper: maximum element of a (possibly empty) list\ndef listMax (xs : List Int) : Option Int :=\n  match xs with\n  | []      => none\n  | x :: xs =>\n    let rec go (m : Int) (ys : List Int) : Int :=\n      match ys with\n      | []      => m\n      | y :: ys => go (maxInt m y) ys\n    some (go x xs)\n\n-- Helper: drop the first occurrence of a given element\ndef dropFirstEq (xs : List Int) (y : Int) : List Int :=\n  match xs with\n  | [] => []\n  | x :: xs' => if x == y then xs' else x :: dropFirstEq xs' y\n\n-- Helper: product of a list (empty product is 1)\ndef prodList (xs : List Int) : Int :=\n  xs.foldl (fun acc x => acc * x) 1\n\n-- Split numbers into positives, negatives, and count zeros\ndef splitSign (xs : List Int) : (List Int × List Int × Nat) :=\n  match xs with\n  | [] => ([], [], 0)\n  | x :: xs' =>\n    let (ps, ns, zc) := splitSign xs'\n    if x == 0 then\n      (ps, ns, zc + 1)\n    else if h : x > 0 then\n      (x :: ps, ns, zc)\n    else\n      (ps, x :: ns, zc)\n\n-- Remove the largest (closest to zero) negative from the list of negatives\ndef removeLargestNeg (ns : List Int) : List Int :=\n  match listMax ns with\n  | none   => []\n  | some m => dropFirstEq ns m",
                "code": "-- Partition the list into positives, negatives, and count zeros\n  let (pos, neg, zc) := splitSign nums\n\n  -- If the number of negatives is odd, drop the largest (closest to zero) negative\n  let neg' :=\n    if (neg.length % 2) == 1 then\n      removeLargestNeg neg\n    else\n      neg\n\n  -- Elements we choose to multiply: all positives and the adjusted negatives\n  let chosen := pos ++ neg'\n\n  -- If nothing chosen:\n  -- - return 0 if there is a zero present\n  -- - otherwise return the maximum element (the list is non-empty by precondition)\n  match chosen with\n  | [] =>\n    if zc == 0 then\n      match listMax nums with\n      | some m => m\n      | none   => 0\n    else\n      0\n  | _  =>\n    prodList chosen",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_43",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "nums ≠ []",
                "postcond_aux": "/--\nIsSubseq s xs means s can be obtained from xs by deleting zero or more elements without reordering.\n-/\ninductive IsSubseq : List Int → List Int → Prop\n| nil (ys : List Int) : IsSubseq [] ys\n| cons_left {x : Int} {xs ys : List Int} :\n    IsSubseq xs ys → IsSubseq xs (x :: ys)\n| cons_both {x : Int} {xs ys : List Int} :\n    IsSubseq xs ys → IsSubseq (x :: xs) (x :: ys)\n\n@[reducible, simp]\ndef listProd : List Int → Int\n| []      => 1\n| x :: xs => x * listProd xs",
                "postcond": "∃ s : List Int,\n    IsSubseq s nums ∧ s ≠ [] ∧\n    result = listProd s ∧\n    (∀ t : List Int, IsSubseq t nums ∧ t ≠ [] → listProd t ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_44": {
          "data_id": "verina_advanced_44",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_44",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- If k is not a positive integer, or effectively 0 when cast to Nat, return 0 by default\n  let K := Int.toNat k\n  if K = 0 then\n    0\n  else\n    -- Imperative-style loop to avoid recursion/termination proofs\n    Id.run do\n      -- Track, for each residue r in [0, K), the minimal prefix sum seen with index ≡ r (mod k)\n      -- Using Option to avoid arbitrary large sentinels; initialize residue 0 with 0 (prefix sum at index 0).\n      let mut minPref : Array (Option Int) := Array.mkArray K (none : Option Int)\n      minPref := minPref.set! 0 (some 0)\n\n      -- Best answer found so far (we clamp to be non-negative by starting at 0)\n      let mut best : Int := 0\n      -- Current prefix sum\n      let mut ps : Int := 0\n\n      -- Handle j = 0 step explicitly (prefix sum before any elements)\n      let r0Nat := Int.toNat ((Int.ofNat 0) % k)\n      let mp0 := minPref[r0Nat]!\n      best := match mp0 with\n              | some minp =>\n                let cand := ps - minp\n                if cand > best then cand else best\n              | none => best\n      -- Update minimal prefix for residue at j = 0\n      minPref :=\n        match mp0 with\n        | some minp => if ps < minp then minPref.set! r0Nat (some ps) else minPref\n        | none      => minPref.set! r0Nat (some ps)\n\n      -- Iterate through array indices i = 0 .. arr.size-1\n      let mut i := 0\n      while i < arr.size do\n        -- Move to next prefix sum (j = i + 1)\n        ps := ps + arr[i]!\n        i := i + 1\n        let rNat := Int.toNat ((Int.ofNat i) % k)\n\n        -- Use the minimal prefix sum for this residue, if available, to update best\n        let mpi := minPref[rNat]!\n        best :=\n          match mpi with\n          | some minp =>\n            let cand := ps - minp\n            if cand > best then cand else best\n          | none => best\n\n        -- Update minimal prefix for this residue with current prefix sum\n        minPref :=\n          match mpi with\n          | some minp => if ps < minp then minPref.set! rNat (some ps) else minPref\n          | none      => minPref.set! rNat (some ps)\n\n      pure best",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_44",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "1 < k",
                "postcond_aux": "@[reducible, simp]\ndef kNat (k : Int) : Nat :=\n  Int.toNat k\n\n@[reducible, simp]\ndef segSum (arr : Array Int) (i len : Nat) : Int :=\n  match len with\n  | 0 => 0\n  | Nat.succ l => arr[i + l]! + segSum arr i l\n\n@[reducible, simp]\ndef GoodSubarray (arr : Array Int) (k : Int) (i len : Nat) : Prop :=\n  i + len ≤ arr.size ∧ 0 < len ∧ (kNat k ∣ len)",
                "postcond": "-- Nonnegativity of the returned maximum\n  0 ≤ result ∧\n  -- Upper bound: result is at least every eligible subarray sum\n  (∀ i len, GoodSubarray arr k i len → segSum arr i len ≤ result) ∧\n  -- If there exists a positive eligible sum, result is achieved by some eligible subarray\n  ((∃ i len, GoodSubarray arr k i len ∧ 0 < segSum arr i len) →\n    ∃ i len, GoodSubarray arr k i len ∧ segSum arr i len = result) ∧\n  -- If all eligible sums are non-positive (including the case of none), default to 0\n  ((∀ i len, GoodSubarray arr k i len → segSum arr i len ≤ 0) → result = 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_45": {
          "data_id": "verina_advanced_45",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to compute the maximum of two Ints without relying on external libraries\ndef maxInt (a b : Int) : Int :=\n  if a ≤ b then b else a\n\n-- Kadane's algorithm helper: traverse the list, keeping current and best sums\ndef kadaneAux (curr best : Int) (ys : List Int) : Int :=\n  match ys with\n  | [] => best\n  | y :: ys' =>\n      let curr' := maxInt y (curr + y)\n      let best' := maxInt best curr'\n      kadaneAux curr' best' ys'",
                "code": "match xs with\n  | [] => 0\n  | x :: xs' =>\n      -- Initialize with the first element to handle all-negative lists correctly\n      kadaneAux x x xs'",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef subarrayAt (xs : List Int) (i k : Nat) : List Int :=\n  -- The contiguous slice of length k starting at index i\n  (xs.drop i).take k\n\n@[reducible, simp]\ndef sumList (xs : List Int) : Int :=\n  -- Sum of a list of integers\n  xs.foldl (fun acc x => acc + x) 0\n\n@[reducible, simp]\ndef isSubarraySum (xs : List Int) (t : Int) : Prop :=\n  -- t is the sum of some non-empty contiguous subarray of xs\n  ∃ i k, i + k ≤ xs.length ∧ 0 < k ∧ t = sumList (subarrayAt xs i k)",
                "postcond": "-- If the list is empty, the result must be 0.\n  -- Otherwise, result is a maximum among all sums of non-empty contiguous subarrays.\n  (xs = [] ∧ result = 0) ∨\n  (xs ≠ [] ∧\n    isSubarraySum xs result ∧\n    ∀ t, isSubarraySum xs t → t ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_45": {
          "data_id": "verina_basic_45",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-\n  Helper predicates for parity.\n  We use Int % 2, which yields 0 or 1 for any integer when the divisor is positive.\n-/\ndef isEven (n : Int) : Bool :=\n  n % 2 == 0\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 == 1\n\n/-\n  Generic finder: returns the first element in the list satisfying predicate p,\n  or none if no such element exists.\n-/\ndef findFirst (p : Int → Bool) : List Int → Option Int\n  | []      => none\n  | x :: xs => if p x then some x else findFirst p xs",
                "code": "-- Find the first even and the first odd numbers in the list\n  let firstEven? := findFirst isEven lst\n  let firstOdd?  := findFirst isOdd lst\n  -- By the precondition, both are guaranteed to exist; we nevertheless handle the fallback.\n  match firstEven?, firstOdd? with\n  | some e, some o => e * o\n  | _, _           => 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_45",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef isEvenInt (n : Int) : Prop :=\n  n % 2 = 0\n\n@[reducible, simp]\ndef isOddInt (n : Int) : Prop :=\n  n % 2 = 1\n\n@[reducible, simp]\ndef FirstIndex (lst : List Int) (P : Int → Prop) (i : Nat) : Prop :=\n  i < lst.length ∧ P (lst[i]!) ∧ (∀ j, j < i → j < lst.length → ¬ P (lst[j]!))",
                "precond": "-- The list contains at least one even number and at least one odd number.\n  (∃ i, i < lst.length ∧ isEvenInt (lst[i]!)) ∧\n  (∃ j, j < lst.length ∧ isOddInt (lst[j]!))",
                "postcond_aux": "",
                "postcond": "-- result is the product of the first even and the first odd elements encountered in the list.\n  ∃ iE iO,\n    FirstIndex lst isEvenInt iE ∧\n    FirstIndex lst isOddInt iO ∧\n    result = (lst[iE]!) * (lst[iO]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_46": {
          "data_id": "verina_basic_46",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Binary search for the last position of `elem` in the sorted array `arr`.\n  -- We find the first index `ub` such that arr[ub] > elem (upper bound),\n  -- then check `ub - 1` for equality.\n  let n := arr.size\n  let mut lo : Nat := 0\n  let mut hi : Nat := n\n  while lo < hi do\n    let mid := lo + (hi - lo) / 2\n    -- Use the Prop-based if with a proof binder to compare Ints.\n    if h : arr[mid]! ≤ elem then\n      lo := mid + 1\n    else\n      hi := mid\n  -- Now `lo` is the upper bound index (first index with value > elem).\n  if lo == 0 then\n    -1\n  else\n    let idx := lo - 1\n    if arr[idx]! == elem then\n      Int.ofNat idx\n    else\n      -1",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef SortedNondecreasing (a : Array Int) : Prop :=\n  -- Adjacent non-decreasing order (implies global non-decreasing)\n  ∀ i : Nat, i + 1 < a.size → a[i]! ≤ a[i + 1]!",
                "precond": "SortedNondecreasing arr",
                "postcond_aux": "@[reducible, simp]\ndef LastIndexOf (a : Array Int) (x : Int) (r : Nat) : Prop :=\n  -- r is a valid index, a[r] = x, and no later index holds x\n  r < a.size ∧ a[r]! = x ∧ ∀ j : Nat, r < j ∧ j < a.size → a[j]! ≠ x",
                "postcond": "-- The result is -1 iff elem does not occur in arr.\n  -- Otherwise, result is the (Int) image of the last (Nat) index r where arr[r] = elem.\n  (result = (-1) ↔ (∀ i : Nat, i < arr.size → arr[i]! ≠ elem))\n  ∧\n  (result ≠ (-1) ↔ ∃ r : Nat, Int.ofNat r = result ∧ LastIndexOf arr elem r)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_46": {
          "data_id": "verina_advanced_46",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper functions to avoid relying on library max\ndef maxInt (a b : Int) : Int :=\n  if a < b then b else a\n\ndef clampNonNeg (x : Int) : Int :=\n  if x < 0 then 0 else x",
                "code": "-- Kadane's algorithm variant that returns 0 if all numbers are negative or list is empty.\n  let step := fun (acc : Int × Int) (x : Int) =>\n    let curr := acc.fst\n    let best := acc.snd\n    let curr' := clampNonNeg (curr + x)\n    let best' := maxInt best curr'\n    (curr', best')\n  let (_, best) := List.foldl step (0, 0) numbers\n  best",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_46",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef listSum (xs : List Int) : Int :=\n  xs.foldl (fun acc x => acc + x) 0\n\n@[reducible, simp]\ndef isContiguousSublist (numbers s : List Int) : Prop :=\n  ∃ l₁ l₂, numbers = l₁ ++ s ++ l₂",
                "postcond": "∃ s, isContiguousSublist numbers s\n    ∧ result = listSum s\n    ∧ (∀ t, isContiguousSublist numbers t → listSum t ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_47": {
          "data_id": "verina_basic_47",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Use a left fold over the array to accumulate the sum of its elements\n  a.foldl (fun acc x => acc + x) 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result must be exactly the sum of all elements in the array.\n  result = a.toList.foldl (· + ·) 0",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_47": {
          "data_id": "verina_advanced_47",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "-- Compare intervals by start, breaking ties by end\ndef leByStart (a b : Int × Int) : Bool :=\n  if a.fst < b.fst then\n    true\n  else if a.fst = b.fst then\n    a.snd ≤ b.snd\n  else\n    false\n\n-- Insert an interval into a list that is already sorted by start\ndef insertByStart (x : Int × Int) (l : List (Int × Int)) : List (Int × Int) :=\n  match l with\n  | [] => [x]\n  | y :: ys =>\n    if leByStart x y then\n      x :: y :: ys\n    else\n      y :: insertByStart x ys\n\n-- Insertion-sort the intervals by start (and then by end)\ndef sortByStart (l : List (Int × Int)) : List (Int × Int) :=\n  l.foldl (fun acc x => insertByStart x acc) []\n\n-- Merge a list of intervals that is already sorted by start\ndef mergeSortedIntervals (l : List (Int × Int)) : List (Int × Int) :=\n  let rec go (curr : Option (Int × Int)) (rest : List (Int × Int)) (acc : List (Int × Int)) : List (Int × Int) :=\n    match rest with\n    | [] =>\n      match curr with\n      | none      => acc.reverse\n      | some cInt => (cInt :: acc).reverse\n    | (s, e) :: rs =>\n      match curr with\n      | none =>\n        go (some (s, e)) rs acc\n      | some (cs, ce) =>\n        if s ≤ ce then\n          -- Overlapping (or touching) intervals: extend the current end\n          let newEnd := if ce ≥ e then ce else e\n          go (some (cs, newEnd)) rs acc\n        else\n          -- Disjoint: push current and start a new one\n          go (some (s, e)) rs ((cs, ce) :: acc)\n  go none l []",
                "code": "-- Sort intervals by their start (and end as tiebreaker), then merge\n  let sorted := sortByStart intervals\n  mergeSortedIntervals sorted",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_47",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef start (p : Prod Int Int) : Int := p.fst\n\n@[reducible, simp]\ndef stop (p : Prod Int Int) : Int := p.snd\n\n-- Coverage of an integer point x by a list of closed intervals\n@[reducible, simp]\ndef covers (L : List (Prod Int Int)) (x : Int) : Prop :=\n  ∃ iv, iv ∈ L ∧ iv.fst ≤ x ∧ x ≤ iv.snd\n\n-- Result list is sorted by nondecreasing start times\n@[reducible, simp]\ndef sortedByStart : List (Prod Int Int) → Prop\n| [] => True\n| [_] => True\n| x :: y :: xs => x.fst ≤ y.fst ∧ sortedByStart (y :: xs)\n\n-- Result list has strictly non-overlapping consecutive intervals\n@[reducible, simp]\ndef nonOverlappingStrict : List (Prod Int Int) → Prop\n| [] => True\n| [_] => True\n| x :: y :: xs => x.snd < y.fst ∧ nonOverlappingStrict (y :: xs)\n\n-- All intervals are well-formed: start ≤ end\n@[reducible, simp]\ndef allWellFormed (L : List (Prod Int Int)) : Prop :=\n  ∀ iv, iv ∈ L → iv.fst ≤ iv.snd\n\n-- Every input interval is contained in some output interval\n@[reducible, simp]\ndef eachInputContained (ins outs : List (Prod Int Int)) : Prop :=\n  ∀ iv, iv ∈ ins → ∃ r, r ∈ outs ∧ r.fst ≤ iv.fst ∧ iv.snd ≤ r.snd\n\n-- The output covers exactly the same set of integer points as the input\n@[reducible, simp]\ndef coverageEq (ins outs : List (Prod Int Int)) : Prop :=\n  ∀ x : Int, covers outs x ↔ covers ins x",
                "postcond": "sortedByStart result\n  ∧ nonOverlappingStrict result\n  ∧ allWellFormed result\n  ∧ coverageEq intervals result\n  ∧ eachInputContained intervals result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_48": {
          "data_id": "verina_basic_48",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Tail-recursive bounded search for a perfect square.\n-- We iterate i from 0 upwards, stopping early when i*i > n,\n-- and using `fuel` to guarantee termination.\nprivate def isPerfectSquareAux (n : Nat) (i fuel : Nat) : Bool :=\n  match fuel with\n  | 0 => false\n  | fuel + 1 =>\n    let sq := i * i\n    if sq = n then\n      true\n    else if n < sq then\n      false\n    else\n      isPerfectSquareAux n (i + 1) fuel",
                "code": "-- Linear search with early stopping: check i^2 for i = 0,1,2,... until i^2 > n.\n  -- The fuel n+1 ensures at most n+1 iterations, which is sufficient because (n+1)^2 > n.\n  isPerfectSquareAux n 0 (n + 1)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result should be exactly the Boolean decision of whether n is a perfect square.\n  result = decide (∃ m : Nat, m * m = n)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_48": {
          "data_id": "verina_advanced_48",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Merge two sorted lists into one sorted list (ascending order).\ndef merge (xs ys : List Int) : List Int :=\n  match xs, ys with\n  | [], _ => ys\n  | _, [] => xs\n  | x :: xs', y :: ys' =>\n    if h : x ≤ y then\n      x :: merge xs' (y :: ys')\n    else\n      y :: merge (x :: xs') ys'\n\n-- Split a list into two lists by alternating elements between them.\n-- This yields two parts whose sizes differ by at most one.\ndef splitHalves (xs : List Int) : List Int × List Int :=\n  match xs with\n  | [] => ([], [])\n  | [x] => ([x], [])\n  | x :: y :: rest =>\n    let (l, r) := splitHalves rest\n    (x :: l, y :: r)\n\n-- A partial merge sort using the above split and merge.\n-- Although marked partial, it is structurally well-founded in practice\n-- because each recursive call works on strictly smaller lists.\npartial def msort (xs : List Int) : List Int :=\n  match xs with\n  | [] => []\n  | [x] => [x]\n  | _ =>\n    let (l, r) := splitHalves xs\n    merge (msort l) (msort r)",
                "code": "-- Delegate to the helper merge sort implementation\n  msort list",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_48",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "/-!\n  SortedNondecreasing: a simple structural definition of nondecreasing sorting for lists of Int.\n  It requires that every head is less than or equal to all elements in the tail,\n  and the tail itself is sorted.\n-/\n@[reducible, simp]\ndef SortedNondecreasing : List Int → Prop\n| [] => True\n| x :: xs => (∀ y ∈ xs, x ≤ y) ∧ SortedNondecreasing xs\n\n/-!\n  PermInt: a permutation relation specialized to lists of Int.\n  It captures that `ys` can be obtained from `xs` by reordering elements.\n-/\ninductive PermInt : List Int → List Int → Prop\n| nil : PermInt [] []\n| skip (x : Int) {xs ys : List Int} :\n    PermInt xs ys → PermInt (x :: xs) (x :: ys)\n| swap (x y : Int) (xs : List Int) :\n    PermInt (x :: y :: xs) (y :: x :: xs)\n| trans {xs ys zs : List Int} :\n    PermInt xs ys → PermInt ys zs → PermInt xs zs\n\n/-!\n  IsPerm: definitional alias for the permutation relation, provided with simp/reducible attributes.\n-/\n@[reducible, simp]\ndef IsPerm (xs ys : List Int) : Prop := PermInt xs ys",
                "postcond": "SortedNondecreasing result ∧ IsPerm result list",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_49": {
          "data_id": "verina_basic_49",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to test if an Int is odd.\n-- Using natAbs of the remainder handles negative integers correctly:\n-- For example, (-3 % 2) = -1, and (-1).natAbs = 1.\ndef isOddInt (n : Int) : Bool :=\n  (n % 2).natAbs == 1",
                "code": "-- Tail-recursive search for the first odd element.\n  let rec go (i fuel : Nat) : Option Nat :=\n    match fuel with\n    | 0 => none\n    | fuel' + 1 =>\n      match a.get? i with\n      | some x =>\n        if isOddInt x then\n          some i\n        else\n          go (i + 1) fuel'\n      | none => none\n  termination_by go i fuel => fuel\n  go 0 a.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef isOddInt (z : Int) : Prop :=\n  ∃ k : Int, z = 2 * k + 1",
                "postcond": "-- result = none precisely when there is no odd element in the array\n  (result = none ↔ ∀ j : Nat, j < a.size → ¬ isOddInt (a[j]!))\n  ∧\n  -- result = some i precisely when i is the smallest index with an odd element\n  (∀ i : Nat,\n    result = some i\n      ↔\n    i < a.size\n      ∧ isOddInt (a[i]!)\n      ∧ (∀ j : Nat, j < i → ¬ isOddInt (a[j]!)))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_49": {
          "data_id": "verina_advanced_49",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper function:\n-- Merges two sorted lists using an accumulator and a fuel parameter\n-- to ensure structural recursion on `fuel`.\ndef mergeCore (l1 l2 acc : List Int) (fuel : Nat) : List Int :=\n  match fuel with\n  | 0 =>\n    -- Fuel exhausted; append the remaining parts (shouldn't happen if fuel is sufficient)\n    acc.reverse ++ l1 ++ l2\n  | Nat.succ fuel' =>\n    match l1, l2 with\n    | [], _ => acc.reverse ++ l2\n    | _, [] => acc.reverse ++ l1\n    | x :: xs, y :: ys =>\n      -- Use the proof-binding `if h : x ≤ y then ... else ...` to avoid Bool conversions\n      if h : x ≤ y then\n        mergeCore xs (y :: ys) (x :: acc) fuel'\n      else\n        mergeCore (x :: xs) ys (y :: acc) fuel'",
                "code": "-- We merge using an accumulator and a fuel to guarantee termination.\n  -- Fuel starts as the total length; each step consumes one element.\n  mergeCore arr1 arr2 [] (arr1.length + arr2.length)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_49",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef sortedAsc : List Int → Prop\n| [] => True\n| [_] => True\n| x :: y :: xs => x ≤ y ∧ sortedAsc (y :: xs)",
                "precond": "-- Inputs must be individually sorted in nondecreasing (ascending) order\n  sortedAsc arr1 ∧ sortedAsc arr2",
                "postcond_aux": "@[reducible, simp]\ndef occ (x : Int) : List Int → Nat\n| [] => 0\n| y :: ys => (if x = y then 1 else 0) + occ x ys",
                "postcond": "-- The result is ascendingly sorted\n  sortedAsc result\n  ∧\n  -- And it contains exactly all elements of arr1 ++ arr2 (with multiplicities)\n  (∀ x : Int, occ x result = occ x (arr1 ++ arr2))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_50": {
          "data_id": "verina_basic_50",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Return the non-negative value of x\n  if h : x < 0 then\n    -x\n  else\n    x",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (if 0 ≤ x then x else -x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_50": {
          "data_id": "verina_advanced_50",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Merge two sorted arrays of Nat into a sorted array without duplicates.\n  let n1 := a1.size\n  let n2 := a2.size\n  let fuel := n1 + n2 + 1\n  let rec loop (fuel i j : Nat) (acc : Array Nat) (prev? : Option Nat) : Array Nat :=\n    match fuel with\n    | 0 => acc\n    | fuel' + 1 =>\n      if decide (i < n1) then\n        if decide (j < n2) then\n          let x := a1[i]!\n          let y := a2[j]!\n          if decide (x ≤ y) then\n            -- take from a1\n            match prev? with\n            | some p =>\n              if p == x then\n                loop fuel' (i + 1) j acc prev?\n              else\n                loop fuel' (i + 1) j (acc.push x) (some x)\n            | none =>\n              loop fuel' (i + 1) j (acc.push x) (some x)\n          else\n            -- take from a2 (y < x)\n            match prev? with\n            | some p =>\n              if p == y then\n                loop fuel' i (j + 1) acc prev?\n              else\n                loop fuel' i (j + 1) (acc.push y) (some y)\n            | none =>\n              loop fuel' i (j + 1) (acc.push y) (some y)\n        else\n          -- a2 is exhausted; take from a1\n          let x := a1[i]!\n          match prev? with\n          | some p =>\n            if p == x then\n              loop fuel' (i + 1) j acc prev?\n            else\n              loop fuel' (i + 1) j (acc.push x) (some x)\n          | none =>\n            loop fuel' (i + 1) j (acc.push x) (some x)\n      else\n        if decide (j < n2) then\n          -- a1 is exhausted; take from a2\n          let y := a2[j]!\n          match prev? with\n          | some p =>\n            if p == y then\n              loop fuel' i (j + 1) acc prev?\n            else\n              loop fuel' i (j + 1) (acc.push y) (some y)\n          | none =>\n            loop fuel' i (j + 1) (acc.push y) (some y)\n        else\n          -- both arrays exhausted\n          acc\n  loop fuel 0 0 (#[] : Array Nat) none",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_50",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- Inputs must be sorted in nondecreasing order; otherwise the task is ill-defined.\n  a1.toList.Sorted (· ≤ ·) ∧ a2.toList.Sorted (· ≤ ·)",
                "postcond_aux": "",
                "postcond": "-- The result is sorted, contains no duplicates, and its elements are exactly\n  -- the union of the elements from the two input arrays (ignoring multiplicity).\n  result.toList.Sorted (· ≤ ·)\n  ∧ result.toList.Nodup\n  ∧ result.toList.toFinset = a1.toList.toFinset ∪ a2.toList.toFinset",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_51": {
          "data_id": "verina_advanced_51",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Merge two sorted lists using a tail-recursive helper with a fuel argument\n  -- to guarantee termination without complex termination proofs.\n  let rec go (fuel : Nat) (a b acc : List Int) : List Int :=\n    match fuel with\n    | 0 =>\n      -- Unreachable when called with fuel = a.length + b.length,\n      -- but provide a sensible fallback.\n      List.reverse acc ++ a ++ b\n    | Nat.succ fuel' =>\n      match a, b with\n      | [], _ => List.reverse acc ++ b\n      | _, [] => List.reverse acc ++ a\n      | ha :: ta, hb :: tb =>\n        if ha ≤ hb then\n          go fuel' ta (hb :: tb) (ha :: acc)\n        else\n          go fuel' (ha :: ta) tb (hb :: acc)\n  go (a.length + b.length) a b []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef Nondecreasing : List Int → Prop\n| [] => True\n| x :: xs => (∀ y, y ∈ xs → x ≤ y) ∧ Nondecreasing xs\n\n@[reducible, simp]\ndef count (x : Int) : List Int → Nat\n| [] => 0\n| y :: ys => (if x = y then 1 else 0) + count x ys",
                "precond": "Nondecreasing a ∧ Nondecreasing b",
                "postcond_aux": "",
                "postcond": "Nondecreasing result ∧ (∀ x : Int, count x result = count x a + count x b)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_51": {
          "data_id": "verina_basic_51",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Binary search to find the first index where a[i] >= key (lower bound).\n  -- We iterate with a fuel counter to ensure termination without complex proofs.\n  let n := a.size\n  let rec loop (fuel lo hi : Nat) : Nat :=\n    match fuel with\n    | 0 => lo\n    | Nat.succ fuel' =>\n      if lo < hi then\n        let mid := lo + (hi - lo) / 2\n        let x := a[mid]!\n        if x < key then\n          -- Key must be to the right of mid\n          loop fuel' (mid + 1) hi\n        else\n          -- x >= key, so the first valid position is in [lo, mid]\n          loop fuel' lo mid\n      else\n        -- Invariant reached: lo = hi is the insertion point\n        lo\n  -- At most n iterations are needed since hi - lo decreases each step.\n  loop (n + 1) 0 n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_51",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The array is sorted in non-decreasing order\n  ∀ (i j : Nat), i < j ∧ j < a.size → a[i]! ≤ a[j]!",
                "postcond_aux": "",
                "postcond": "-- result is a valid insertion index such that:\n  -- 1) 0 ≤ result ≤ a.size (Nat ensures 0 ≤ result; we assert result ≤ a.size)\n  -- 2) All elements before result are strictly less than key\n  -- 3) All elements from result onward are greater than or equal to key\n  -- 4) If result = a.size, then all elements are less than key\n  -- 5) Minimality: result is the first index where an element ≥ key could appear\n  result ≤ a.size\n  ∧ (∀ (i : Nat), i < result → a[i]! < key)\n  ∧ (∀ (j : Nat), result ≤ j ∧ j < a.size → key ≤ a[j]!)\n  ∧ (result = a.size → ∀ (i : Nat), i < a.size → a[i]! < key)\n  ∧ (∀ (k : Nat), k < a.size → key ≤ a[k]! → result ≤ k)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_52": {
          "data_id": "verina_advanced_52",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We scan the list from the end (i.e., scan nums.reverse from the front),\n  -- removing one element per step (counting operations) and tracking which\n  -- numbers in [1..k] have been collected. Once we've seen all numbers 1..k,\n  -- we return the number of removals performed so far.\n  let rev := nums.reverse\n  -- seen[i] indicates whether i has been collected (we only use indices 1..k)\n  let seen0 : Array Bool := mkArray (k + 1) false\n  let rec go (seen : Array Bool) (missing ops : Nat) (l : List Nat) : Nat :=\n    if missing == 0 then\n      ops\n    else\n      match l with\n      | [] =>\n        -- By the problem's assumption (nums contains all 1..k), we should have finished earlier.\n        -- As a fallback, return the operations performed so far.\n        ops\n      | x :: xs =>\n        let ops' := ops + 1\n        -- Only care about values ≤ k (values are positive by assumption).\n        if h : x ≤ k then\n          -- Use a[i]! notation as suggested for array indexing.\n          if seen[x]! then\n            go seen missing ops' xs\n          else\n            let seen' := seen.set! x true\n            go seen' (missing - 1) ops' xs\n        else\n          go seen missing ops' xs\n  go seen0 k 0 rev",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef collectedAllUpTo (nums : List Nat) (k r : Nat) : Prop :=\n  -- After r removals (i.e., considering the suffix of length r),\n  -- every integer m with 1 ≤ m ≤ k appears in that suffix.\n  ∀ m : Nat, (1 ≤ m ∧ m ≤ k) → m ∈ List.drop (nums.length - r) nums",
                "precond": "-- Assume the input list contains all integers from 1 to k.\n  collectedAllUpTo nums k nums.length",
                "postcond_aux": "",
                "postcond": "-- result is the minimal number of removals from the end such that\n  -- the collected elements (≤ k) contain all integers 1..k.\n  result ≤ nums.length\n  ∧ collectedAllUpTo nums k result\n  ∧ ∀ r : Nat, r < result → ¬ collectedAllUpTo nums k r",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_52": {
          "data_id": "verina_basic_52",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Swap elements at positions i and j when both indices are valid; otherwise, return the array unchanged.\ndef swapAt (arr : Array Int) (i j : Nat) : Array Int :=\n  match arr.get? i, arr.get? j with\n  | some xi, some xj => (arr.set! i xj).set! j xi\n  | _, _ => arr\n\n-- If the element at i is greater than the element at i+1, swap them; otherwise, keep the array as is.\ndef swapIfGt (arr : Array Int) (i : Nat) : Array Int :=\n  match arr.get? i, arr.get? (i+1) with\n  | some x, some y =>\n      if x > y then\n        (arr.set! i y).set! (i+1) x\n      else\n        arr\n  | _, _ => arr\n\n-- Perform one bubble pass up to the given limit:\n-- It compares indices 0..limit-1 with their successors and bubbles a larger element forward.\ndef bubblePass (arr : Array Int) (limit : Nat) : Array Int :=\n  let rec go (fuel : Nat) (arr : Array Int) : Array Int :=\n    match fuel with\n    | 0 => arr\n    | fuel' + 1 =>\n      -- Current comparison index i runs from 0 to limit-1\n      let i := limit - (fuel' + 1)\n      let arr := swapIfGt arr i\n      go fuel' arr\n  go limit arr\n\n-- Repeatedly apply bubblePass with decreasing limits from size-1 down to 0.\ndef bubbleSortImpl (a : Array Int) : Array Int :=\n  let n := a.size\n  let rec outer (fuel : Nat) (arr : Array Int) : Array Int :=\n    match fuel with\n    | 0 => arr\n    | fuel' + 1 =>\n      -- On pass k (counting from 0), the effective limit is (n-1-k).\n      -- Using fuel' as the limit yields the correct decreasing sequence: n-1, n-2, ..., 0.\n      let arr := bubblePass arr fuel'\n      outer fuel' arr\n  outer n a",
                "code": "bubbleSortImpl a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_52",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef SortedNondecreasing (b : Array Int) : Prop :=\n  -- Non-decreasing: for any indices i < j within bounds, b[i]! ≤ b[j]!\n  ∀ i j, i < j → j < b.size → b[i]! ≤ b[j]!\n\n@[reducible, simp]\ndef SameElementsByIndex (a b : Array Int) : Prop :=\n  -- b is a rearrangement of a via a bijection between indices\n  ∃ f : Fin b.size → Fin a.size,\n    -- injective\n    (∀ i j, f i = f j → i = j) ∧\n    -- surjective\n    (∀ j, ∃ i, f i = j) ∧\n    -- element correspondence under the index mapping\n    ∀ i, b[i.val]! = a[(f i).val]!",
                "postcond": "result.size = a.size ∧\n  SortedNondecreasing result ∧\n  SameElementsByIndex a result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_53": {
          "data_id": "verina_advanced_53",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Check if a list is strictly increasing (each next element is greater than the previous one)\ndef isStrictlyIncreasing (xs : List Int) : Bool :=\n  match xs with\n  | [] => true\n  | _ :: [] => true\n  | x :: y :: zs =>\n      if x < y then\n        isStrictlyIncreasing (y :: zs)\n      else\n        false\n\n-- Find the index of the minimum element in a nonempty list.\n-- For an empty list, we return 0 by convention.\ndef findMinIndex (xs : List Int) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs =>\n    -- Auxiliary recursive function that scans the remaining list,\n    -- keeping track of the current minimum value and its index.\n    let rec aux (curMin : Int) (curIdx : Nat) (i : Nat) (rest : List Int) : Nat :=\n      match rest with\n      | [] => curIdx\n      | y :: ys =>\n        if y < curMin then\n          aux y i (i + 1) ys\n        else\n          aux curMin curIdx (i + 1) ys\n    aux x 0 1 xs\n\n-- Rotate a list to the left by k positions: drop k ++ take k\ndef rotateLeft (xs : List Int) (k : Nat) : List Int :=\n  xs.drop k ++ xs.take k",
                "code": "let n := nums.length\n  -- Trivial cases: empty or singleton list is already sorted\n  if n ≤ 1 then\n    0\n  else\n    let s := findMinIndex nums\n    let rotated := rotateLeft nums s\n    if isStrictlyIncreasing rotated then\n      -- Minimal right shifts needed to bring index s to the front is (n - s) % n\n      Int.ofNat ((n - s) % n)\n    else\n      -1",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef rotIdx (n k i : Nat) : Nat :=\n  -- Index in the original list that appears at position i after k right shifts\n  -- (i - k) mod n, written with Nat operations\n  (i + n - (k % n)) % n\n\n@[reducible, simp]\ndef isSortedAfterRightShifts (nums : List Int) (k : Nat) : Prop :=\n  -- The list obtained by applying k right shifts to nums is nondecreasing\n  let n := nums.length\n  ∀ i, i + 1 < n →\n    nums[rotIdx n k i]! ≤ nums[rotIdx n k (i + 1)]!\n\n@[reducible, simp]\ndef kBound (nums : List Int) (k : Nat) : Prop :=\n  -- We restrict k to a canonical range to avoid redundant rotations.\n  -- Using max n 1 ensures that for empty lists (n = 0) we still allow k = 0.\n  k < Nat.max nums.length 1",
                "postcond": "-- Either there exists a minimal number of right shifts k making the list sorted,\n  -- in which case result = k (as an Int), or no such k exists and result = -1.\n  (∃ k : Nat,\n      kBound nums k ∧\n      isSortedAfterRightShifts nums k ∧\n      result = Int.ofNat k ∧\n      ∀ k', kBound nums k' → isSortedAfterRightShifts nums k' → k ≤ k')\n  ∨\n  ((∀ k, kBound nums k → ¬ isSortedAfterRightShifts nums k) ∧ result = -1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_53": {
          "data_id": "verina_basic_53",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Recursive helper to compute the sum of the first n natural numbers\n  let rec go (n : Nat) : Nat :=\n    match n with\n    | 0 => 0\n    | n+1 => (n+1) + go n\n  -- Use the helper on the input N\n  go N",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_53",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (N * (N + 1)) / 2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_54": {
          "data_id": "verina_advanced_54",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Simple helper to sum a list of natural numbers\ndef sumNatList (xs : List Nat) : Nat :=\n  xs.foldl (fun acc x => acc + x) 0",
                "code": "-- Let n be the length of the list; numbers are drawn from 0..n with one missing\n  let n := nums.length\n  -- Expected sum of 0 + 1 + ... + n\n  let expected := (n * (n + 1)) / 2\n  -- Actual sum of the given list\n  let actual := sumNatList nums\n  -- The missing number is the difference\n  expected - actual",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- Elements are distinct and all lie in the range [0, nums.length]\n  nums.Nodup ∧ (∀ x ∈ nums, x ≤ nums.length)",
                "postcond_aux": "",
                "postcond": "-- Let n be the upper bound of the range; exactly one number in [0, n] is missing\n  let n := nums.length\n  (result ≤ n) ∧\n  (result ∉ nums) ∧\n  (∀ y, y ≤ n → y ∉ nums → y = result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_54": {
          "data_id": "verina_basic_54",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "-- Two-pointer linear scan with structural recursion on a fuel counter.\n  let sa := a.size\n  let sb := b.size\n  -- Handle degenerate cases defensively (though precondition states non-empty).\n  if a.isEmpty || b.isEmpty then\n    0\n  else\n    let initBest : Nat := (a[0]! - b[0]!).natAbs\n    let fuel := sa + sb\n    let rec go (i j best fuel : Nat) : Nat :=\n      match fuel with\n      | 0 => best\n      | fuel' + 1 =>\n        if h : i < sa ∧ j < sb then\n          let ai := a[i]!\n          let bj := b[j]!\n          let diff : Nat := (ai - bj).natAbs\n          let best' := if _ : diff < best then diff else best\n          -- If elements are equal, minimum possible difference is 0.\n          if _ : ai = bj then\n            0\n          else if _ : ai < bj then\n            go (i + 1) j best' fuel'\n          else\n            go i (j + 1) best' fuel'\n        else\n          best\n    go 0 0 initBest fuel",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_54",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "0 < a.size ∧ 0 < b.size ∧\n  (∀ i, i + 1 < a.size → a[i]! ≤ a[i + 1]!) ∧\n  (∀ j, j + 1 < b.size → b[j]! ≤ b[j + 1]!)",
                "postcond_aux": "@[reducible, simp]\ndef absDiffNat (x y : Int) : Nat :=\n  Int.natAbs (x - y)",
                "postcond": "-- result is the minimum absolute difference between any a[i] and b[j]\n  (∃ i j, i < a.size ∧ j < b.size ∧ result = absDiffNat (a[i]!) (b[j]!)) ∧\n  (∀ i j, i < a.size → j < b.size → result ≤ absDiffNat (a[i]!) (b[j]!))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_55": {
          "data_id": "verina_advanced_55",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Update the frequency count for a given integer in an association list\ndef updateCount (counts : List (Int × Nat)) (x : Int) : List (Int × Nat) :=\n  match counts with\n  | [] => [(x, 1)]\n  | (y, c) :: ys =>\n      if x = y then\n        (y, c + 1) :: ys\n      else\n        (y, c) :: updateCount ys x\n\n-- Build frequency counts using a left fold over the list\ndef buildCounts (xs : List Int) : List (Int × Nat) :=\n  xs.foldl (fun acc x => updateCount acc x) []\n\n-- Retrieve the frequency count for a specific integer\ndef getCount (counts : List (Int × Nat)) (x : Int) : Nat :=\n  match counts with\n  | [] => 0\n  | (y, c) :: ys =>\n      if x = y then c else getCount ys x\n\n-- Compute the maximum frequency from the association list\ndef maxCount (counts : List (Int × Nat)) : Nat :=\n  counts.foldl (fun acc (_, c) => if c > acc then c else acc) 0\n\n-- Find the first element in the original list that has the target frequency\ndef firstWithCount (xs : List Int) (counts : List (Int × Nat)) (target : Nat) : Int :=\n  match xs with\n  | [] => 0  -- Fallback; by precondition, xs is non-empty\n  | x :: xs' =>\n      if getCount counts x = target then x\n      else firstWithCount xs' counts target",
                "code": "let counts := buildCounts xs\n  let m := maxCount counts\n  firstWithCount xs counts m",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "xs ≠ []",
                "postcond_aux": "@[reducible, simp]\ndef occ (x : Int) : List Int → Nat\n| [] => 0\n| y :: ys => occ x ys + (if x = y then 1 else 0)",
                "postcond": "∃ as bs,\n    xs = as ++ result :: bs\n    ∧ (∀ y, y ∈ xs → occ y xs ≤ occ result xs)\n    ∧ (∀ z, z ∈ as → occ z xs < occ result xs)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_55": {
          "data_id": "verina_basic_55",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "a == b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_55",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = decide (a = b)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_56": {
          "data_id": "verina_advanced_56",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Build a list of n zeros (as Ints)\ndef makeZeros : Nat → List Int\n| 0     => []\n| n+1   => 0 :: makeZeros n\n\n-- Partition the list into (non-zero elements in reverse order, count of zeros)\ndef partitionNonZeros (xs : List Int) (nonRev : List Int) (z : Nat) : List Int × Nat :=\n  match xs with\n  | []      => (nonRev, z)\n  | y :: ys =>\n    if y == 0 then\n      partitionNonZeros ys nonRev (z + 1)\n    else\n      partitionNonZeros ys (y :: nonRev) z",
                "code": "-- Separate non-zero elements (collected in reverse order) and count zeros\n  let (nonRev, z) := partitionNonZeros xs [] 0\n  -- Restore original order of non-zero elements and append all zeros at the end\n  nonRev.reverse ++ makeZeros z",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result must be the concatenation of all non-zero elements (in order)\n  -- followed by all zero elements (in order) from the original list.\n  result = xs.filter (fun x => decide (x ≠ 0)) ++ xs.filter (fun x => decide (x = 0))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_56": {
          "data_id": "verina_basic_56",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We first snapshot the source segment into a temporary buffer to avoid any aliasing issues\n  -- (e.g., when src and dest might be the same array).\n  let rec buildBuf (k : Nat) (buf : Array Int) : Array Int :=\n    match k with\n    | 0 => buf\n    | Nat.succ k' =>\n      let buf' := buildBuf k' buf\n      let idx := k'\n      let v := src[sStart + idx]!\n      buf'.push v\n\n  let buf := buildBuf len #[]\n\n  -- Now write the buffered values into the destination at the appropriate positions.\n  let rec writeSeg (k : Nat) (acc : Array Int) : Array Int :=\n    match k with\n    | 0 => acc\n    | Nat.succ k' =>\n      let acc' := writeSeg k' acc\n      let idx := k'\n      acc'.set! (dStart + idx) (buf[idx]!)\n\n  writeSeg len dest",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_56",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "sStart + len ≤ src.size ∧ dStart + len ≤ dest.size",
                "postcond_aux": "",
                "postcond": "result.size = dest.size ∧\n  (∀ j, j < dStart → result[j]! = dest[j]!) ∧\n  (∀ j, dStart + len ≤ j ∧ j < dest.size → result[j]! = dest[j]!) ∧\n  (∀ i, i < len → result[dStart + i]! = src[sStart + i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_57": {
          "data_id": "verina_advanced_57",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Lookup a value in an association list (key-value pairs). Returns none if absent.\ndef assocLookup (m : List (Int × Int)) (k : Int) : Option Int :=\n  let rec loop : List (Int × Int) → Option Int\n    | [] => none\n    | (a, b) :: t =>\n      if h : a = k then\n        some b\n      else\n        loop t\n  loop m\n\n-- Build a mapping from each number in nums2 to its next greater element using a monotonic stack.\n-- If a number has no next greater element, it maps to -1.\ndef buildNextGreaterMap (ns : List Int) : List (Int × Int) :=\n  let rec go (stack : List Int) (rest : List Int) (acc : List (Int × Int)) : List (Int × Int) :=\n    match rest with\n    | [] =>\n      -- No more elements to process; remaining stack elements have no next greater element.\n      stack.foldl (fun a x => (x, -1) :: a) acc\n    | x :: xs =>\n      -- Pop all smaller elements; their next greater is x.\n      let rec pop (st : List Int) (accPairs : List (Int × Int)) : (List Int) × (List (Int × Int)) :=\n        match st with\n        | [] => ([], accPairs)\n        | y :: ys =>\n          if y < x then\n            pop ys ((y, x) :: accPairs)\n          else\n            (st, accPairs)\n      let (st', acc') := pop stack acc\n      -- Push current element onto the stack and continue.\n      go (x :: st') xs acc'\n  go [] ns []",
                "code": "-- Precompute next-greater mapping from nums2 using a monotonic stack.\n  let m := buildNextGreaterMap nums2\n  -- For each element in nums1, look up its next greater value (or -1 if none).\n  nums1.map (fun x =>\n    match assocLookup m x with\n    | some v => v\n    | none   => -1)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "∀ x, x ∈ nums1 → x ∈ nums2",
                "postcond_aux": "@[reducible, simp]\ndef valAt (l : List Int) (i : Nat) (hi : i < l.length) : Int :=\n  l.get ⟨i, hi⟩\n\n@[reducible, simp]\ndef NextGreaterInNums2 (l : List Int) (x y : Int) : Prop :=\n  let pos := l.indexOf x\n  pos < l.length ∧\n  (\n    -- Case: there exists a first greater element to the right of x's first occurrence\n    (∃ j (hj1 : pos < j) (hj2 : j < l.length),\n      x < valAt l j hj2 ∧\n      (∀ k (hk1 : pos < k) (hk2 : k < j), valAt l k (Nat.lt_trans hk2 hj2) ≤ x) ∧\n      y = valAt l j hj2)\n    ∨\n    -- Case: there is no greater element to the right; return -1\n    (y = -1 ∧ ∀ j (hj1 : pos < j) (hj2 : j < l.length), valAt l j hj2 ≤ x)\n  )",
                "postcond": "result.length = nums1.length ∧\n  (∀ i (hi₁ : i < nums1.length) (hi₂ : i < result.length),\n     NextGreaterInNums2 nums2 (valAt nums1 i hi₁) (valAt result i hi₂))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_57": {
          "data_id": "verina_basic_57",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "-- Count the number of elements in the array strictly less than the given threshold\n  numbers.foldl (init := 0) (fun acc x => if x < threshold then acc + 1 else acc)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_57",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (numbers.toList.filter (fun x => decide (x < threshold))).length",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_58": {
          "data_id": "verina_basic_58",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Recursive helper that iterates through the array using an index and a fuel counter.\n-- It updates each element in place by doubling it.\ndef doubleAux (arr : Array Int) (i : Nat) (fuel : Nat) : Array Int :=\n  match fuel with\n  | 0 => arr\n  | fuel' + 1 =>\n    if h : i < arr.size then\n      let arr := arr.set! i ((2 : Int) * arr[i]!)\n      doubleAux arr (i + 1) fuel'\n    else\n      -- If index is out of bounds (should not happen when fuel = arr.size - i),\n      -- just return the current array.\n      arr",
                "code": "-- Start doubling from index 0 with fuel equal to the array size.\n  doubleAux s 0 s.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- Sizes match and every element is exactly double the corresponding input element\n  result.size = s.size ∧\n  (∀ i, i < s.size → result[i]! = (2 : Int) * s[i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_58": {
          "data_id": "verina_advanced_58",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Small helpers for minima\ndef min2 (a b : Nat) : Nat :=\n  if a ≤ b then a else b\n\ndef min3 (a b c : Nat) : Nat :=\n  min2 (min2 a b) c",
                "code": "-- Handle trivial cases: by convention, the 1st ugly number is 1\n  if n ≤ 1 then\n    1\n  else\n    -- Tail-recursive generator using the classic 3-pointer DP method.\n    -- rem: how many more numbers to generate (beyond the initial 1)\n    -- i2, i3, i5: indices for multiples of 2, 3, and 5 respectively\n    -- arr: array of already generated ugly numbers in ascending order\n    -- next2, next3, next5: next candidate multiples from the respective pointers\n    let rec go (rem : Nat) (i2 i3 i5 : Nat)\n               (arr : Array Nat) (next2 next3 next5 : Nat) : Nat :=\n      match rem with\n      | 0 =>\n        -- Return the last generated ugly number\n        arr[arr.size - 1]!\n      | Nat.succ r =>\n        let next := min3 next2 next3 next5\n        let arr' := arr.push next\n\n        -- Advance each pointer whose candidate equals the chosen next value\n        let i2' := if h2 : next = next2 then i2 + 1 else i2\n        let next2' := if h2 : next = next2 then arr'[i2']! * 2 else next2\n\n        let i3' := if h3 : next = next3 then i3 + 1 else i3\n        let next3' := if h3 : next = next3 then arr'[i3']! * 3 else next3\n\n        let i5' := if h5 : next = next5 then i5 + 1 else i5\n        let next5' := if h5 : next = next5 then arr'[i5']! * 5 else next5\n\n        go r i2' i3' i5' arr' next2' next3' next5'\n\n    -- Initialize with the first ugly number\n    let arr0 : Array Nat := #[1]\n    let rem := n - 1\n    go rem 0 0 0 arr0 2 3 5",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_58",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "open Classical\n\n@[reducible, simp]\ndef isUgly (k : Nat) : Prop :=\n  k ≠ 0 ∧ ∃ a b c : Nat, k = Nat.pow 2 a * Nat.pow 3 b * Nat.pow 5 c\n\n@[reducible, simp]\ndef countUglyLe (m : Nat) : Nat :=\n  ((Finset.range (m + 1)).filter (fun k => isUgly k)).card",
                "postcond": "-- 1-based indexing: the first ugly number is 1.\n  -- We keep the precondition fully permissive; for n = 0 we specify a benign result = 0.\n  if h0 : n = 0 then\n    result = 0\n  else\n    countUglyLe result = n ∧\n    (∀ m, m < result → countUglyLe m < n) ∧\n    isUgly result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_59": {
          "data_id": "verina_basic_59",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute a = 2 * x and b = 4 * x and return as a pair\n  let a := 2 * x\n  let b := 4 * x\n  (a, b)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (2 * x, 4 * x)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_59": {
          "data_id": "verina_advanced_59",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Normalize: keep only alphanumeric characters and lowercase them\n  let filtered := (s.data.filter (fun c => c.isAlphanum)).map (fun c => c.toLower)\n  let norm := String.mk filtered\n  let rev := String.mk filtered.reverse\n  -- A string is a palindrome if it equals its reverse\n  norm == rev",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_59",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef leq (a b : Nat) : Bool :=\n  decide (a ≤ b)\n\n/-- ASCII range check on Nat codepoints: lo ≤ n ≤ hi -/\n@[reducible, simp]\ndef between (lo n hi : Nat) : Bool :=\n  leq lo n && leq n hi\n\n/-- Predicate: is the character an ASCII alphanumeric? (0-9, A-Z, a-z) -/\n@[reducible, simp]\ndef isAsciiAlnum (c : Char) : Bool :=\n  let n := c.toNat\n  let digit := between '0'.toNat n '9'.toNat\n  let upper := between 'A'.toNat n 'Z'.toNat\n  let lower := between 'a'.toNat n 'z'.toNat\n  digit || upper || lower\n\n/-- Lower-case conversion for ASCII letters; leaves other chars unchanged -/\n@[reducible, simp]\ndef toLowerAscii (c : Char) : Char :=\n  if between 'A'.toNat c.toNat 'Z'.toNat then\n    Char.ofNat (c.toNat + 32)\n  else\n    c\n\n/-- Keep only ASCII alphanumerics from the string and normalize case to lowercase -/\n@[reducible, simp]\ndef cleaned (s : String) : List Char :=\n  (s.data.filter (fun c => isAsciiAlnum c)).map toLowerAscii\n\n/-- Palindrome predicate on a list of characters -/\n@[reducible, simp]\ndef isPalindromeList (xs : List Char) : Prop :=\n  xs = xs.reverse",
                "postcond": "result = decide (isPalindromeList (cleaned s))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_60": {
          "data_id": "verina_basic_60",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Fold through the array, pushing only even numbers to the accumulator.\n  arr.foldl\n    (init := (#[] : Array Int))\n    (fun acc x => if x % 2 == 0 then acc.push x else acc)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef isEvenInt (n : Int) : Prop :=\n  n % 2 = 0",
                "postcond": "-- There exists an order-preserving selection function g that picks exactly\n  -- the even elements of arr, in order, to form result.\n  ∃ g : Nat → Nat,\n    -- Every element of result comes from arr at index g i, and is even.\n    (∀ i, i < result.size →\n      g i < arr.size ∧\n      result[i]! = arr[g i]! ∧\n      isEvenInt (arr[g i]!)) ∧\n    -- The mapping preserves order (strictly increasing indices).\n    (∀ {i j}, i < j ∧ j < result.size → g i < g j) ∧\n    -- Completeness: every even element of arr appears in result.\n    (∀ j, j < arr.size →\n      isEvenInt (arr[j]!) →\n      ∃ i, i < result.size ∧ g i = j ∧ result[i]! = arr[j]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_60": {
          "data_id": "verina_advanced_60",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Return true iff n is even\ndef isEven (n : Nat) : Bool :=\n  n % 2 == 0\n\n-- Tail-recursive helper that builds the even and odd lists in reverse,\n-- then reverses them once at the end to preserve the original order.\ndef partitionAux (xs : List Nat) (evAcc odAcc : List Nat) : (List Nat × List Nat) :=\n  match xs with\n  | [] => (evAcc.reverse, odAcc.reverse)\n  | x :: xs' =>\n    if isEven x then\n      partitionAux xs' (x :: evAcc) odAcc\n    else\n      partitionAux xs' evAcc (x :: odAcc)",
                "code": "-- Use the helper with empty accumulators; reverse is handled inside\n  partitionAux nums [] []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_60",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef isEvenNat (n : Nat) : Bool := n % 2 == 0\n\n@[reducible, simp]\ndef isOddNat (n : Nat) : Bool := n % 2 == 1",
                "postcond": "-- The output lists are precisely the even and odd elements of the input, in their original order.\n  result.fst = List.filter isEvenNat nums ∧\n  result.snd = List.filter isOddNat nums",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_61": {
          "data_id": "verina_advanced_61",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Build the list of prefix products: for each index i, store the product of all elements before i.\ndef buildPref (l : List Int) (p : Int) (acc : List Int) : List Int :=\n  match l with\n  | [] => acc.reverse\n  | x :: xs => buildPref xs (p * x) (p :: acc)\n\n-- Zip two lists with a function, stopping at the end of the shorter list.\ndef zipWith {α β γ} (f : α → β → γ) : List α → List β → List γ\n  | a :: as, b :: bs => f a b :: zipWith f as bs\n  | _, _ => []",
                "code": "-- Prefix products excluding self\n  let pref := buildPref nums (1 : Int) []\n  -- Suffix products excluding self (computed via prefix on the reversed list, then reversed back)\n  let rpref := buildPref nums.reverse (1 : Int) []\n  let suff := rpref.reverse\n  -- Combine prefix and suffix to get the product of all elements except self\n  zipWith (fun x y => x * y) pref suff",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef lprod (xs : List Int) : Int :=\n  -- Left fold with multiplication, neutral element 1\n  xs.foldl (fun acc x => acc * x) 1\n\n@[reducible, simp]\ndef prodExceptAtIndex (xs : List Int) (i : Nat) : Int :=\n  -- Product of all elements except the one at index i\n  lprod (xs.take i) * lprod (xs.drop (i + 1))",
                "postcond": "-- The result must have the same length, and each position i equals\n  -- the product of all input elements except nums[i]\n  result.length = nums.length ∧\n  (∀ i, i < nums.length → result[i]! = prodExceptAtIndex nums i)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_61": {
          "data_id": "verina_basic_61",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-- Returns true iff the given character is an ASCII digit ('0'..'9'). -/\ndef isAsciiDigit (c : Char) : Bool :=\n  let n  := c.toNat\n  let z0 := '0'.toNat\n  let z9 := '9'.toNat\n  decide (z0 ≤ n) && decide (n ≤ z9)\n\n/-- Checks that all characters in the given list are ASCII digits. -/\ndef allDigitsList (cs : List Char) : Bool :=\n  match cs with\n  | [] => true\n  | c :: cs' => isAsciiDigit c && allDigitsList cs'",
                "code": "-- Iterate through all characters of the string (empty string yields true)\n  allDigitsList s.data",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_61",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef isAsciiDigit (c : Char) : Prop :=\n  ('0' ≤ c) ∧ (c ≤ '9')",
                "postcond": "result = true ↔ (∀ c, c ∈ s.data → isAsciiDigit c)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_62": {
          "data_id": "verina_advanced_62",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Compute prefix maxima for a list: at each position, the maximum from the start up to that position.\ndef listPrefixMax (l : List Int) : List Int :=\n  match l with\n  | [] => []\n  | x :: xs =>\n    let rec go (l : List Int) (cur : Int) (acc : List Int) : List Int :=\n      match l with\n      | [] => acc.reverse\n      | y :: ys =>\n        let cur' := if cur ≤ y then y else cur\n        go ys cur' (cur' :: acc)\n    go xs x [x]\n\n-- Compute suffix maxima for a list via reversing and using prefix maxima.\ndef listSuffixMax (l : List Int) : List Int :=\n  let rev := l.reverse\n  let revPref := listPrefixMax rev\n  revPref.reverse\n\n-- Sum trapped water given heights and their prefix/suffix maxima.\ndef sumWater (h pm sm : List Int) : Int :=\n  match h, pm, sm with\n  | [], _, _ => 0\n  | _, [], _ => 0\n  | _, _, [] => 0\n  | x :: xs, p :: ps, s :: ss =>\n    let bound := if p ≤ s then p else s\n    let d := bound - x\n    let w := if d > 0 then d else 0\n    w + sumWater xs ps ss",
                "code": "let pm := listPrefixMax heights\n  let sm := listSuffixMax heights\n  sumWater heights pm sm",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef iMaxInt (a b : Int) : Int :=\n  if a < b then b else a\n\n@[reducible, simp]\ndef iMinInt (a b : Int) : Int :=\n  if a < b then a else b\n\n@[reducible, simp]\ndef listMaxInt (xs : List Int) : Int :=\n  match xs with\n  | []      => 0\n  | x :: xs => xs.foldl (fun m y => iMaxInt m y) x\n\n@[reducible, simp]\ndef waterAtIndex (heights : List Int) (i : Nat) (h : Int) : Int :=\n  let lm := listMaxInt (heights.take (i + 1))\n  let rm := listMaxInt (heights.drop i)\n  iMaxInt 0 (iMinInt lm rm - h)\n\n@[reducible, simp]\ndef waterList (heights : List Int) : List Int :=\n  let rec go (xs : List Int) (i : Nat) : List Int :=\n    match xs with\n    | []       => []\n    | x :: xs' => waterAtIndex heights i x :: go xs' (i + 1)\n  go heights 0\n\n@[reducible, simp]\ndef totalWater (heights : List Int) : Int :=\n  (waterList heights).foldl (fun acc w => acc + w) 0",
                "postcond": "result = totalWater heights",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_62": {
          "data_id": "verina_basic_62",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Linear search: return the first index where a[i] == key, or -1 if absent.\n  let rec go (i : Nat) (fuel : Nat) : Int :=\n    match fuel with\n    | 0 => -1\n    | fuel' + 1 =>\n      if h : i < a.size then\n        let xi := a[i]!\n        if xi == key then\n          Int.ofNat i\n        else\n          go (i + 1) fuel'\n      else\n        -- If i is out of bounds, key is not present.\n        -1\n  go 0 a.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_62",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- result = -1 exactly when key does not occur in the array\n  (result = -1 ↔ ¬ ∃ (i : Nat), i < a.size ∧ a[i]! = key) ∧\n  -- if result ≠ -1, it denotes the first index where key occurs\n  (result ≠ -1 →\n    0 ≤ result ∧\n    Int.toNat result < a.size ∧\n    a[(Int.toNat result)]! = key ∧\n    ∀ (j : Nat), j < Int.toNat result → a[j]! ≠ key)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_63": {
          "data_id": "verina_basic_63",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Absolute value for Float without relying on external libraries\ndef absFloat (x : Float) : Float :=\n  if x < 0.0 then -x else x\n\n-- Boolean comparator for Float less-than\ndef ltB (x y : Float) : Bool :=\n  if x < y then true else false\n\n-- Check whether there exists a y in the tail with y ≠ x and |x - y| < threshold\ndef hasCloseInTail (x : Float) (ys : List Float) (threshold : Float) : Bool :=\n  match ys with\n  | [] => false\n  | y :: ys' =>\n    if x == y then\n      -- Values are equal: they are not considered \"different numbers\"\n      hasCloseInTail x ys' threshold\n    else\n      if ltB (absFloat (x - y)) threshold then\n        true\n      else\n        hasCloseInTail x ys' threshold",
                "code": "-- Iterate through the list, checking each element against the remaining tail\n  let rec go (xs : List Float) : Bool :=\n    match xs with\n    | [] => false\n    | x :: xs' =>\n      if hasCloseInTail x xs' threshold then\n        true\n      else\n        go xs'\n  go numbers",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result is true iff there exist two distinct indices into the list\n  -- whose corresponding elements are within the given threshold in absolute difference.\n  result ↔ ∃ (i j : Fin numbers.length),\n    i ≠ j ∧ Float.abs (numbers.get i - numbers.get j) < threshold",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_63": {
          "data_id": "verina_advanced_63",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Tail-recursive helper that counts unique elements in a (non-empty) sorted list.\nprivate def countUniqueAux (prev : Int) (cnt : Nat) (rest : List Int) : Nat :=\n  match rest with\n  | [] => cnt\n  | y :: ys =>\n    -- Since the list is sorted non-decreasingly, duplicates appear contiguously.\n    -- Increment count only when we see a new value different from `prev`.\n    if y = prev then\n      countUniqueAux prev cnt ys\n    else\n      countUniqueAux y (cnt + 1) ys",
                "code": "match nums with\n  | [] => 0\n  | x :: xs =>\n    -- First element is always unique; continue counting over the tail.\n    countUniqueAux x 1 xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_63",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = nums.toFinset.card",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_64": {
          "data_id": "verina_advanced_64",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Auxiliary recursive function that removes all occurrences of `target` from `lst`.\n-- It preserves the original order by constructing the result recursively.\nprivate def removeAll (lst : List Nat) (target : Nat) : List Nat :=\n  match lst with\n  | [] => []\n  | x :: xs =>\n    if decide (x = target) then\n      removeAll xs target\n    else\n      x :: removeAll xs target",
                "code": "-- Delegate to the auxiliary function; precondition is not needed for logic here.\n  removeAll lst target",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result must be exactly the input list filtered to drop all elements equal to `target`,\n  -- preserving the relative order of the remaining elements.\n  result = lst.filter (fun x => decide (x ≠ target))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_64": {
          "data_id": "verina_basic_64",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Copy elements from src in [start, stop) into dst\ndef copyRange (src : Array Char) (start stop : Nat) (dst : Array Char) : Array Char :=\n  Id.run do\n    let mut out := dst\n    let mut j := start\n    while j < stop do\n      out := out.push (src[j]!)\n      j := j + 1\n    return out",
                "code": "-- Build the result of length l + p by:\n  -- 1) taking the prefix of oline up to atPos,\n  -- 2) inserting the first p elements of nl,\n  -- 3) appending the remainder of oline from atPos to l.\n  let out0 := Array.mkEmpty (l + p)\n  let out1 := copyRange oline 0 atPos out0\n  let out2 := copyRange nl 0 p out1\n  let out3 := copyRange oline atPos l out2\n  out3",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_64",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "atPos ≤ l ∧ l ≤ oline.size ∧ p ≤ nl.size",
                "postcond_aux": "",
                "postcond": "result.size = l + p\n  ∧ (∀ i : Nat, i < atPos → result[i]! = oline[i]!)\n  ∧ (∀ i : Nat, atPos ≤ i ∧ i < atPos + p → result[i]! = nl[i - atPos]!)\n  ∧ (∀ i : Nat, atPos + p ≤ i ∧ i < l + p → result[i]! = oline[i - p]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_65": {
          "data_id": "verina_basic_65",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We perform a bounded tail-recursive search for the largest r with (r+1)^2 > N.\n  -- The fuel ensures termination; r can never increase more than N times.\n  let rec loop (fuel r : Nat) : Nat :=\n    match fuel with\n    | 0 => r\n    | Nat.succ fuel' =>\n      -- If (r+1)^2 ≤ N, we can safely increase r and continue.\n      if h : (r + 1) * (r + 1) ≤ N then\n        loop fuel' (r + 1)\n      else\n        -- Otherwise, r is the largest value with r^2 ≤ N and (r+1)^2 > N.\n        r\n  -- Start from r = 0 with enough fuel (N + 1 steps suffice).\n  loop (N + 1) 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result * result ≤ N ∧ N < (result + 1) * (result + 1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_65": {
          "data_id": "verina_advanced_65",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Reverse the string by folding from right to left,\n  -- pushing each character onto the accumulator.\n  s.foldr (init := \"\") (fun c acc => acc.push c)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_65",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.length = s.length ∧\n  ∀ i : Nat, i < s.length → result.get? i = s.get? (s.length - 1 - i)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_66": {
          "data_id": "verina_basic_66",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- True iff x is divisible by 2 (no remainder)\n  decide (x % 2 = 0)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = decide (x % 2 = 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_66": {
          "data_id": "verina_advanced_66",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Join a list of strings with single spaces, with no leading/trailing spaces.\nprivate def joinWithSpace (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | h :: t => t.foldl (fun acc s => acc ++ \" \" ++ s) h",
                "code": "-- Split on spaces, filter out empty chunks to remove extra spaces,\n  -- reverse the list of words, then join with single spaces.\n  let words := words_str.splitOn \" \"\n  let words := words.filter (fun s => s ≠ \"\")\n  let reversed := words.reverse\n  joinWithSpace reversed",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_66",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef IsSpaces (s : String) : Prop :=\n  -- All characters in s are spaces\n  ∀ i : Fin s.length, s.get i = ' '\n\n@[reducible, simp]\ndef IsWord (s : String) : Prop :=\n  -- A word is non-empty and contains no spaces\n  s ≠ \"\" ∧ ∀ i : Fin s.length, s.get i ≠ ' '\n\n@[reducible, simp]\ndef glue : List String → List String → String\n  -- Interleave spaces segments (sps) and words (ws):\n  -- sp0 ++ w0 ++ sp1 ++ w1 ++ ... ++ spN, where sps.length = ws.length + 1\n  | sp :: sps', w :: ws' => sp ++ w ++ glue sps' ws'\n  | [sp], []             => sp\n  | [], []               => \"\"\n  | _, _                 => \"\"  -- unreachable under well-formed decomposition\n\n@[reducible, simp]\ndef joinWithSpace : List String → String\n  -- Join words by a single space, with no leading/trailing spaces\n  | []       => \"\"\n  | [w]      => w\n  | w :: ws  => w ++ \" \" ++ joinWithSpace ws\n\n@[reducible, simp]\ndef midNonempty (sps : List String) : Prop :=\n  -- All \"internal\" space segments (between words) are non-empty\n  ∀ i s, sps.get? i = some s → 0 < i ∧ i < sps.length - 1 → s ≠ \"\"\n\n@[reducible, simp]\ndef WordsOf (s : String) (ws : List String) : Prop :=\n  -- ws are exactly the contiguous non-space words of s, in order.\n  ∃ sps : List String,\n    sps.length = ws.length + 1 ∧\n    (∀ sp ∈ sps, IsSpaces sp) ∧\n    midNonempty sps ∧\n    (∀ w ∈ ws, IsWord w) ∧\n    s = glue sps ws",
                "postcond": "∃ ws : List String,\n    WordsOf words_str ws ∧\n    -- result is the words reversed, joined by single spaces\n    result = joinWithSpace ws.reverse",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_67": {
          "data_id": "verina_advanced_67",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper step function for the fold:\n-- Maintains a run-length encoded list in reverse order.\n-- Given the current accumulator and a new character c:\n-- - If the accumulator is empty, start a new run with (c, 1).\n-- - If the head run is for the same character, increment its count.\n-- - Otherwise, start a new run for c.\ndef rleStep (acc : List (Char × Nat)) (c : Char) : List (Char × Nat) :=\n  match acc with\n  | [] => [(c, 1)]\n  | (c', n) :: rest =>\n      if c == c' then\n        (c', n + 1) :: rest\n      else\n        (c, 1) :: acc",
                "code": "-- Fold over the string's characters to build the encoding in reverse,\n  -- then reverse once at the end to restore the original order.\n  let acc := s.data.foldl rleStep []\n  acc.reverse",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef replicateChar (c : Char) (n : Nat) : List Char :=\n  -- Repeat character c exactly n times.\n  List.replicate n c\n\n@[reducible, simp]\ndef decodeRLE : List (Char × Nat) → List Char\n  -- Expand a run-length-encoded list into the corresponding list of characters.\n  | [] => []\n  | (c, n) :: xs => replicateChar c n ++ decodeRLE xs\n\n@[reducible, simp]\ndef PositiveRuns : List (Char × Nat) → Prop\n  -- Every run-length is strictly positive.\n  | [] => True\n  | (_, n) :: xs => 0 < n ∧ PositiveRuns xs\n\n@[reducible, simp]\ndef NoAdjSameChar : List (Char × Nat) → Prop\n  -- Adjacent pairs must not have the same character.\n  | [] => True\n  | [_] => True\n  | (c1, n1) :: (c2, n2) :: xs => c1 ≠ c2 ∧ NoAdjSameChar ((c2, n2) :: xs)",
                "postcond": "PositiveRuns result ∧\n  NoAdjSameChar result ∧\n  String.mk (decodeRLE result) = s",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_67": {
          "data_id": "verina_basic_67",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Tail-recursive reverse for lists of Char\ndef revAux (l acc : List Char) : List Char :=\n  match l with\n  | []      => acc\n  | h :: t  => revAux t (h :: acc)\n\ndef rev (l : List Char) : List Char :=\n  revAux l []\n\n-- Boolean equality for lists of Char\ndef beqCharList (a b : List Char) : Bool :=\n  match a, b with\n  | [], [] => true\n  | x :: xs, y :: ys => (x == y) && beqCharList xs ys\n  | _, _ => false",
                "code": "-- A list is a palindrome if it equals its reverse\n  let r := rev x\n  beqCharList x r",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_67",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = true ↔ x = x.reverse",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_68": {
          "data_id": "verina_advanced_68",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper function to perform RLE on a list of characters.\n-- Produces a string of the form c1k1c2k2... where each ci is a character and ki is its run length.\ndef rleFromList (l : List Char) : String :=\n  match l with\n  | [] => \"\"\n  | c :: cs => go \"\" c 1 cs\nwhere\n  go (acc : String) (curr : Char) (count : Nat) (rest : List Char) : String :=\n    match rest with\n    | [] =>\n      let acc := acc.push curr\n      acc ++ toString count\n    | x :: xs =>\n      if x == curr then\n        go acc curr (count + 1) xs\n      else\n        let acc := (acc.push curr) ++ toString count\n        go acc x 1 xs",
                "code": "-- Convert input string to list of characters and run the encoder.\n  rleFromList input.data",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef isDigit (c : Char) : Prop :=\n  -- ASCII digit check\n  ('0').toNat ≤ c.toNat ∧ c.toNat ≤ ('9').toNat",
                "precond": "-- Input must contain no digit characters\n  ∀ c, c ∈ input.data → ¬ isDigit c",
                "postcond_aux": "@[reducible, simp]\ndef AllDigits (s : String) : Prop :=\n  ∀ c, c ∈ s.data → isDigit c\n\n@[reducible, simp]\ndef charStr (c : Char) : String :=\n  String.mk [c]\n\n@[reducible, simp]\ndef repeatChar (c : Char) (n : Nat) : String :=\n  String.mk (List.replicate n c)\n\n@[reducible, simp]\ndef encodeRuns (runs : List (Char × Nat)) : String :=\n  runs.foldl (fun acc p => acc ++ charStr p.fst ++ toString p.snd) \"\"\n\n@[reducible, simp]\ndef decodeRuns (runs : List (Char × Nat)) : String :=\n  runs.foldl (fun acc p => acc ++ repeatChar p.fst p.snd) \"\"\n\n@[reducible, simp]\ndef AdjacentDistinct : List (Char × Nat) → Prop\n  | [] => True\n  | [_] => True\n  | (p :: q :: rs) => p.fst ≠ q.fst ∧ AdjacentDistinct (q :: rs)\n\n@[reducible, simp]\ndef RunsWellFormed (runs : List (Char × Nat)) : Prop :=\n  ∀ p, p ∈ runs →\n    -- character is non-digit, count is positive,\n    -- and the decimal representation of the count is nonempty and all digits\n    (¬ isDigit p.fst) ∧\n    (p.snd ≥ 1) ∧\n    ((toString p.snd) ≠ \"\") ∧\n    AllDigits (toString p.snd)",
                "postcond": "∃ runs : List (Char × Nat),\n    RunsWellFormed runs ∧\n    AdjacentDistinct runs ∧\n    -- 1) Result alternates as blocks: each block is a non-digit char followed by ≥1 digit\n    --    (enforced by construction via encodeRuns + RunsWellFormed)\n    result = encodeRuns runs ∧\n    -- 2) Decoding the (char, count) blocks reconstructs the original input\n    input = decodeRuns runs ∧\n    -- 3) Non-empty iff and only if\n    (input = \"\" ↔ result = \"\")",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_68": {
          "data_id": "verina_basic_68",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Linear scan: return the first index i with a[i] == e, or a.size if absent.\n  -- We use a bounded loop driven by a decreasing fuel to avoid termination proofs.\n  let rec loop (i fuel : Nat) : Nat :=\n    match fuel with\n    | 0 => a.size\n    | Nat.succ fuel' =>\n      if a[i]! == e then\n        i\n      else\n        loop (i + 1) fuel'\n  loop 0 a.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_68",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(result < a.size ∧ a[result]! = e ∧ ∀ j, j < result → a[j]! ≠ e)\n  ∨\n  (result = a.size ∧ ∀ j, j < a.size → a[j]! ≠ e)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_69": {
          "data_id": "verina_advanced_69",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Linear scan: return the first index i where target ≤ xs[i],\n  -- or the length if all elements are < target.\n  let rec go (i : Nat) (ys : List Int) : Nat :=\n    match ys with\n    | [] => i\n    | y :: ys' =>\n      if target ≤ y then\n        i\n      else\n        go (i + 1) ys'\n  go 0 xs",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- xs is strictly increasing (hence sorted with no duplicates)\n  ∀ (i j : Fin xs.length), i < j → xs.get i < xs.get j",
                "postcond_aux": "",
                "postcond": "-- result is a valid insertion/search index (lower_bound):\n  -- - it lies within [0, xs.length]\n  -- - all indices strictly before result hold values < target\n  -- - all indices at/after result hold values ≥ target\n  result ≤ xs.length ∧\n  ∀ i : Fin xs.length,\n    (i.1 < result → xs.get i < target) ∧\n    (result ≤ i.1 → target ≤ xs.get i)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_69": {
          "data_id": "verina_basic_69",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper function that linearly searches for the first index of `e` starting at `i`,\n-- using `fuel` to ensure structural recursion terminates. We decrease `fuel` at each step.\ndef firstIdxAux (a : Array Int) (e : Int) (i : Nat) (fuel : Nat) : Nat :=\n  match fuel with\n  | 0 => i\n  | fuel' + 1 =>\n      if hlt : i < a.size then\n        if a[i]! == e then\n          i\n        else\n          firstIdxAux a e (i + 1) fuel'\n      else\n        -- Out of bounds: return current index (logically unreachable when fuel is set properly)\n        i",
                "code": "-- Start searching from index 0 with fuel equal to the array size.\n  firstIdxAux a e 0 a.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_69",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "∃ i : Nat, i < a.size ∧ a[i]! = e",
                "postcond_aux": "",
                "postcond": "result < a.size\n  ∧ a[result]! = e\n  ∧ (∀ j : Nat, j < result → a[j]! ≠ e)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_70": {
          "data_id": "verina_basic_70",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Tail-recursive linear search with a decreasing fuel to ensure termination.\n  -- Precondition guarantees there exists at least one index satisfying P.\n  let rec go (i fuel : Nat) : Nat :=\n    match fuel with\n    | 0 => \n      -- Unreachable under the stated precondition (no element satisfies P).\n      0\n    | Nat.succ fuel' =>\n      if P (a[i]!) then\n        i\n      else\n        go (i + 1) fuel'\n  go 0 a.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- At least one index exists where P holds on the corresponding element\n  ∃ i : Nat, i < a.size ∧ P (a[i]!) = true",
                "postcond_aux": "",
                "postcond": "-- result is the first index where P holds:\n  -- 1) result is within bounds\n  -- 2) a[result] satisfies P\n  -- 3) all indices before result do not satisfy P\n  result < a.size ∧\n  P (a[result]!) = true ∧\n  ∀ j : Nat, j < a.size → j < result → P (a[j]!) = false",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_70": {
          "data_id": "verina_advanced_70",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Find the first index of a given target in a list (0-based).\n-- Since the input is a permutation of [1..n], the targets 1 and n are guaranteed to exist.\ndef findIndex (xs : List Int) (target : Int) : Nat :=\n  let rec go (ys : List Int) (i : Nat) : Nat :=\n    match ys with\n    | [] => 0\n    | y :: ys' =>\n      if h : y = target then\n        i\n      else\n        go ys' i.succ\n  go xs 0",
                "code": "-- Positions of 1 and n (0-based)\n  let nNat := nums.length\n  let pos1 := findIndex nums 1\n  let posN := findIndex nums (Int.ofNat nNat)\n\n  -- Convert to Int for arithmetic\n  let i1 : Int := Int.ofNat pos1\n  let iN : Int := Int.ofNat posN\n  let n  : Int := Int.ofNat nNat\n\n  -- If 1 is to the right of n, moving 1 left will shift n one position left,\n  -- reducing the total number of swaps by 1.\n  let adjust : Int := if decide (i1 > iN) then 1 else 0\n\n  -- Swaps to bring 1 to front: i1\n  -- Swaps to bring n to end: (n - 1 - iN)\n  -- Subtract 1 if 1 starts to the right of n\n  i1 + (n - 1 - iN) - adjust",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_70",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "let n := nums.length\n  0 < n ∧\n  nums.Nodup ∧\n  -- nums is exactly the permutation of [1, 2, ..., n] (as Ints)\n  (∀ x : Int, x ∈ nums ↔ ∃ k : Nat, k < n ∧ x = Int.ofNat (k + 1))",
                "postcond_aux": "",
                "postcond": "let n := nums.length\n  -- Let i1 be the (unique) index of 1 and inx be the (unique) index of n.\n  -- For a permutation of [1..n], the minimal adjacent swaps to make the list\n  -- semi-ordered (head = 1, last = n) is:\n  --   i1 + ((n - 1) - inx) - (if inx < i1 then 1 else 0)\n  ∃ (i1 inx : Nat) (h1 : i1 < n) (hN : inx < n),\n    nums.get ⟨i1, h1⟩ = (1 : Int) ∧\n    nums.get ⟨inx, hN⟩ = Int.ofNat n ∧\n    result = Int.ofNat (i1 + ((n - 1) - inx) - (if inx < i1 then 1 else 0))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_71": {
          "data_id": "verina_advanced_71",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Compare two slices of the same underlying character array lexicographically.\n-- Slices are [s1, e1) and [s2, e2). When used here, lengths are equal.\npartial def lexLessSlices (arr : Array Char) (s1 e1 s2 e2 : Nat) : Bool :=\n  let rec loop (i1 i2 : Nat) : Bool :=\n    if i1 < e1 then\n      if i2 < e2 then\n        let c1 := arr[i1]!\n        let c2 := arr[i2]!\n        if c1 == c2 then\n          loop (i1 + 1) (i2 + 1)\n        else\n          c1.toNat < c2.toNat\n      else\n        false\n    else\n      false\n  loop s1 s2\n\n-- Build a String from a slice [s, e) of an Array Char.\npartial def sliceToString (arr : Array Char) (s e : Nat) : String :=\n  let rec build (i : Nat) (acc : List Char) : List Char :=\n    if i < e then\n      build (i + 1) (arr[i]! :: acc)\n    else\n      acc.reverse\n  String.mk (build s [])",
                "code": "Id.run do\n    -- Trivial optimal answer for k = 0 is the empty string.\n    if k == 0 then\n      return \"\"\n\n    -- Materialize the string as an array of characters for O(1) indexing.\n    let chars : Array Char := Array.mk s.data\n    let n := chars.size\n\n    -- Sliding window state\n    let mut l : Nat := 0\n    let mut ones : Nat := 0\n\n    -- Best answer tracked as slice [bestS, bestE)\n    let mut bestS : Nat := 0\n    let mut bestE : Nat := 0\n    let mut hasBest : Bool := false\n\n    -- Expand the right end of the window\n    let mut r : Nat := 0\n    while r < n do\n      -- Include chars[r]\n      let c := chars[r]!\n      if c == '1' then\n        ones := ones + 1\n\n      -- Shrink from the left until ones ≤ k\n      while ones > k do\n        let cl := chars[l]!\n        if cl == '1' then\n          ones := ones - 1\n        l := l + 1\n\n      -- If we have exactly k ones, minimize length by skipping leading zeros\n      if ones == k then\n        let mut l2 := l\n        -- Move l2 to the first '1' in the window to minimize length\n        let stop := r + 1\n        while l2 < stop && chars[l2]! == '0' do\n          l2 := l2 + 1\n\n        -- Candidate slice [l2, r+1)\n        let candS := l2\n        let candE := r + 1\n        let candLen := candE - candS\n\n        if !hasBest then\n          bestS := candS\n          bestE := candE\n          hasBest := true\n        else\n          let bestLen := bestE - bestS\n          if candLen < bestLen then\n            bestS := candS\n            bestE := candE\n          else if candLen == bestLen then\n            if lexLessSlices chars candS candE bestS bestE then\n              bestS := candS\n              bestE := candE\n\n        -- Keep the window minimal for the next iteration\n        l := l2\n\n      -- Advance right end\n      r := r + 1\n\n    if hasBest then\n      return sliceToString chars bestS bestE\n    else\n      return \"\"",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef onesCount : List Char → Nat\n| [] => 0\n| c :: cs => (if c = '1' then 1 else 0) + onesCount cs\n\n@[reducible, simp]\ndef substringOf (t s : String) : Prop :=\n  ∃ (i len : Nat), i + len ≤ s.data.length ∧ t.data = (s.data.drop i).take len\n\n@[reducible, simp]\ndef hasExactlyKOnesSubstr (s t : String) (k : Nat) : Prop :=\n  substringOf t s ∧ onesCount t.data = k",
                "postcond": "let existsCand : Prop := ∃ t : String, hasExactlyKOnesSubstr s t k\n  (existsCand ∧\n    hasExactlyKOnesSubstr s result k ∧\n    -- Minimal length among all substrings with exactly k ones\n    (∀ t : String, hasExactlyKOnesSubstr s t k → result.data.length ≤ t.data.length) ∧\n    -- Lexicographically smallest among those with the same minimal length\n    (∀ t : String, hasExactlyKOnesSubstr s t k → t.data.length = result.data.length → result ≤ t))\n  ∨\n  (¬ existsCand ∧ result = \"\")",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_71": {
          "data_id": "verina_basic_71",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute the longest common prefix of two lists of characters\n  let rec lcp (s1 s2 : List Char) : List Char :=\n    match s1, s2 with\n    | c1 :: t1, c2 :: t2 =>\n      if c1 == c2 then\n        c1 :: lcp t1 t2\n      else\n        []\n    | _, _ => []\n  lcp str1 str2",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_71",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- result is a common prefix of both inputs\n  (∃ s1 s2, result ++ s1 = str1 ∧ result ++ s2 = str2)\n  ∧\n  -- result is length-maximal among all common prefixes\n  (∀ l : List Char,\n    ((∃ t1, l ++ t1 = str1) ∧ (∃ t2, l ++ t2 = str2)) → l.length ≤ result.length)\n  ∧\n  -- length bounds (implied by being a prefix, included for clarity)\n  result.length ≤ str1.length\n  ∧\n  result.length ≤ str2.length\n  ∧\n  -- if one input is empty, the LCP is empty\n  ((str1 = [] ∨ str2 = []) → result = [])\n  ∧\n  -- if first characters differ, the LCP is empty\n  (∀ c1 t1 c2 t2, str1 = c1 :: t1 → str2 = c2 :: t2 → c1 ≠ c2 → result = [])",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_72": {
          "data_id": "verina_advanced_72",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Check divisibility by single-digit primes in increasing order\n  if n % 2 == 0 then\n    2\n  else if n % 3 == 0 then\n    3\n  else if n % 5 == 0 then\n    5\n  else if n % 7 == 0 then\n    7\n  else\n    0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- cond states that there exists a prime p < 10 dividing n\n  let cond : Prop := ∃ p : Nat, Nat.Prime p ∧ p ∣ n ∧ p < 10\n  -- If such a prime exists, result is the smallest such prime.\n  -- Otherwise, result = 0.\n  (cond ∧ Nat.Prime result ∧ result ∣ n ∧ result < 10 ∧\n    ∀ q : Nat, Nat.Prime q → q ∣ n → q < 10 → result ≤ q)\n  ∨ (¬cond ∧ result = 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_72": {
          "data_id": "verina_basic_72",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Append the element b to the end of array a\n  a.push b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_72",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.toList = a.toList ++ [b]",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_73": {
          "data_id": "verina_advanced_73",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Traverse the sorted list while tracking the smallest expected natural number (starting at 0).\n  -- For each element x:\n  -- - If expected < x, then expected is missing.\n  -- - If expected = x, increment expected and continue.\n  -- - If expected > x (possible with non-strictly increasing lists), skip x and continue.\n  let rec loop (expected : Nat) (lst : List Nat) : Nat :=\n    match lst with\n    | [] => expected\n    | x :: xs =>\n      if hlt : expected < x then\n        expected\n      else if heq : expected = x then\n        loop (expected + 1) xs\n      else\n        -- Here, ¬(expected < x) and expected ≠ x, hence x < expected; skip x.\n        loop expected xs\n  loop 0 l",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- result is the smallest natural number not present in l:\n  --   (1) result is not in l\n  --   (2) every natural number strictly smaller than result is in l\n  (¬ List.Mem result l) ∧ (∀ m, m < result → List.Mem m l)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_73": {
          "data_id": "verina_basic_73",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper function to compare two lists of characters with '?' wildcard in the pattern\nprivate def matchList (s : List Char) (p : List Char) : Bool :=\n  match s, p with\n  | [], [] => true\n  | _, [] => false\n  | [], _ => false\n  | cS :: tS, cP :: tP =>\n      if cP == '?' || cP == cS then\n        matchList tS tP\n      else\n        false",
                "code": "-- Ensure lengths match, then compare character-by-character with '?' wildcard support\n  if s.length == p.length then\n    matchList s.data p.data\n  else\n    false",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_73",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- Strings match iff they have equal length and, at every index,\n  -- either the pattern has '?' or the characters are identical.\n  (s.data.length = p.data.length ∧\n    ∀ i : Nat, i < s.data.length →\n      (p.data.get? i = some '?' ∨ s.data.get? i = p.data.get? i)) ↔ result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_74": {
          "data_id": "verina_basic_74",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- By precondition, the array is non-empty, so a[0]! is safe.\n  -- We iterate through the array, keeping track of the current maximum.\n  Id.run do\n    let mut maxVal : Int := a[0]!\n    let mut isFirst : Bool := true\n    for x in a do\n      if isFirst then\n        -- Skip the first element since it's used to initialize maxVal\n        isFirst := false\n      else\n        if maxVal < x then\n          maxVal := x\n        else\n          ()\n    return maxVal",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "0 < a.size",
                "postcond_aux": "",
                "postcond": "(∃ i, i < a.size ∧ a[i]! = result) ∧ (∀ j, j < a.size → a[j]! ≤ result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_74": {
          "data_id": "verina_advanced_74",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "/--\nsumFromStartAux l seen acc:\n- Traverses the list l as a growing subarray starting at its head.\n- `seen` accumulates the distinct elements encountered so far.\n- At each step, adds (number of distinct elements)^2 to `acc`.\n-/\ndef sumFromStartAux (l : List Nat) (seen : Finset Nat) (acc : Nat) : Nat :=\n  match l with\n  | [] => acc\n  | x :: xs =>\n    let seen' := seen.insert x\n    let acc' := acc + seen'.card * seen'.card\n    sumFromStartAux xs seen' acc'\n\n/--\nsumAllSubarraysAux l acc:\n- Iterates over all starting positions of contiguous subarrays of l.\n- For each start, uses `sumFromStartAux` to sum over all extensions.\n- Returns the total accumulated sum in `acc`.\n-/\ndef sumAllSubarraysAux (l : List Nat) (acc : Nat) : Nat :=\n  match l with\n  | [] => acc\n  | _ :: xs =>\n    let acc' := sumFromStartAux l (∅ : Finset Nat) acc\n    sumAllSubarraysAux xs acc'",
                "code": "-- Sum over all contiguous subarrays the square of the number of distinct elements\n  sumAllSubarraysAux nums 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_74",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "-- A contiguous subarray of l taking indices in [i, j) (start inclusive, end exclusive).\n@[reducible, simp]\ndef seg {α : Type u} (l : List α) (i j : Nat) : List α :=\n  (l.drop i).take (j - i)\n\n-- Number of distinct elements in a list of natural numbers.\n@[reducible, simp]\ndef distinctCount (l : List Nat) : Nat :=\n  l.toFinset.card",
                "postcond": "-- Sum over all non-empty contiguous subarrays nums[i..j) with 0 ≤ i < j ≤ n\n  -- of the square of the number of distinct elements in that subarray.\n  let n := nums.length\n  result =\n    ∑ i in Finset.range n,\n      ∑ j in Finset.Icc (i + 1) n,\n        (distinctCount (seg nums i j)) ^ 2",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_75": {
          "data_id": "verina_advanced_75",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper function: maximum of two Ints without relying on extra imports\ndef maxInt (x y : Int) : Int :=\n  if x < y then y else x",
                "code": "-- Handle the (theoretically impossible) empty case gracefully\n  match sequence with\n  | [] => 0\n  | x :: xs =>\n    -- Kadane's algorithm:\n    -- cur: best sum ending at current position\n    -- best: global best so far\n    let (_, best) :=\n      xs.foldl\n        (fun (acc : Int × Int) (e : Int) =>\n          let cur0  := acc.fst\n          let best0 := acc.snd\n          let cur1  := maxInt e (cur0 + e)\n          let best1 := maxInt best0 cur1\n          (cur1, best1))\n        (x, x)\n    best",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The sequence must be non-empty to initialize Kadane's algorithm with the first element.\n  sequence ≠ []",
                "postcond_aux": "@[reducible, simp]\ndef seg (xs : List Int) (i j : Nat) : List Int :=\n  -- Contiguous segment xs[i:j) using drop/take\n  (xs.drop i).take (j - i)\n\n@[reducible, simp]\ndef segSum (xs : List Int) (i j : Nat) : Int :=\n  -- Sum over the contiguous segment xs[i:j)\n  (seg xs i j).foldl (fun acc x => acc + x) 0",
                "postcond": "let n := sequence.length\n  -- result is the maximum sum among all nonempty contiguous sublists of `sequence`\n  ((∃ i j, i < j ∧ j ≤ n ∧ segSum sequence i j = result) ∧\n   (∀ i j, i < j ∧ j ≤ n → segSum sequence i j ≤ result))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_75": {
          "data_id": "verina_basic_75",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We assume a is non-empty per the precondition.\n  -- Use the first element as the initial minimum, then scan the rest with a simple recursive loop.\n  let startMin := a[0]!\n  let result := loop (a.size - 1) 1 startMin\n  result\nwhere\n  -- loop remaining i m scans 'remaining' elements starting at index i,\n  -- maintaining the current minimum m.\n  loop : Nat → Nat → Int → Int\n  | 0, _, m => m\n  | Nat.succ rem, i, m =>\n      let x := a[i]!\n      let m' := if x < m then x else m\n      loop rem (i + 1) m'",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_75",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The array must be non-empty to have a minimum.\n  0 < a.size",
                "postcond_aux": "",
                "postcond": "-- result is a minimum element of the array:\n  -- 1) result is less than or equal to every element in the array\n  -- 2) result occurs at some index in the array\n  (∀ i, i < a.size → result ≤ a[i]!) ∧ (∃ i, i < a.size ∧ a[i]! = result)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_76": {
          "data_id": "verina_basic_76",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "if x ≤ y then x else y",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (if x ≤ y then x else y)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_76": {
          "data_id": "verina_advanced_76",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Increment the count of a value in an association list (value, count).\n-- If the value is not present, insert it with count 1.\ndef incCount (acc : List (Int × Nat)) (x : Int) : List (Int × Nat) :=\n  match acc with\n  | [] => [(x, 1)]\n  | (y, c) :: rest =>\n      if x == y then\n        (y, c + 1) :: rest\n      else\n        (y, c) :: incCount rest x\n\n-- Build frequency counts for all integers in the list.\ndef buildCounts (xs : List Int) : List (Int × Nat) :=\n  xs.foldl (fun acc x => incCount acc x) []\n\n-- Find the pair with the maximal count in a non-empty list of (value, count).\n-- Returns none for the empty list.\ndef findMaxPair (l : List (Int × Nat)) : Option (Int × Nat) :=\n  match l with\n  | [] => none\n  | p :: ps =>\n      some <| ps.foldl (fun best q => if q.snd > best.snd then q else best) p\n\n-- Remove the first occurrence of a key (value) from the association list.\ndef removeKey (l : List (Int × Nat)) (key : Int) : List (Int × Nat) :=\n  match l with\n  | [] => []\n  | (y, c) :: rs =>\n      if y == key then\n        rs\n      else\n        (y, c) :: removeKey rs key\n\n-- Select top k keys by repeatedly taking the current maximum count and removing it.\n-- Accumulates results in reverse order for efficiency, then reverses at the end.\ndef selectK (freqs : List (Int × Nat)) (k : Nat) (acc : List Int) : List Int :=\n  match k with\n  | 0 => acc.reverse\n  | k' + 1 =>\n      match findMaxPair freqs with\n      | none => acc.reverse\n      | some (x, _) =>\n          let freqs' := removeKey freqs x\n          selectK freqs' k' (x :: acc)",
                "code": "let freqs := buildCounts nums\n  selectK freqs k []",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_76",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- k must not exceed the number of distinct elements in nums\n  k ≤ nums.toFinset.card",
                "postcond_aux": "@[reducible, simp]\ndef freq (nums : List Int) (x : Int) : Nat :=\n  -- frequency of x in nums (count occurrences)\n  (nums.filter (fun y => y == x)).length\n\n@[reducible, simp]\ndef nonincreasingBy (f : Int → Nat) (l : List Int) : Prop :=\n  -- Adjacent-pair nonincreasing order w.r.t. f\n  l.Chain' (fun x y => f x ≥ f y)",
                "postcond": "-- result is a list of exactly k distinct elements from nums\n  -- ordered by nonincreasing frequency, and every excluded element\n  -- has frequency no greater than any included element.\n  result.length = k ∧\n  result.Nodup ∧\n  (∀ x, x ∈ result → x ∈ nums) ∧\n  nonincreasingBy (freq nums) result ∧\n  (∀ x, x ∈ result → ∀ y, y ∈ nums → y ∉ result → freq nums x ≥ freq nums y)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_77": {
          "data_id": "verina_advanced_77",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-!\nAuxiliary helpers:\n- scanlMax: running maximum from the left (inclusive).\n- scanrMax: running maximum from the right (inclusive), built via reversing.\n- sumWaterAux: zips three lists (height, leftMax, rightMax) to accumulate trapped water.\n-/\n\n/-- Running maximum from the left (inclusive). -/\nprivate def scanlMax (l : List Nat) : List Nat :=\n  let rec loop (accMax : Nat) (l : List Nat) (acc : List Nat) : List Nat :=\n    match l with\n    | [] => acc.reverse\n    | x :: xs =>\n      let m := Nat.max accMax x\n      loop m xs (m :: acc)\n  loop 0 l []\n\n/-- Running maximum from the right (inclusive). -/\nprivate def scanrMax (l : List Nat) : List Nat :=\n  (scanlMax l.reverse).reverse\n\n/-- Sum trapped water using height, left maxima, and right maxima. -/\nprivate def sumWaterAux (h l r : List Nat) (acc : Nat) : Nat :=\n  match h, l, r with\n  | [], _, _ => acc\n  | _, [], _ => acc\n  | _, _, [] => acc\n  | x :: hs, a :: ls, b :: rs =>\n      let m := Nat.min a b\n      let w := m - x\n      sumWaterAux hs ls rs (acc + w)",
                "code": "let leftMax  := scanlMax height\n  let rightMax := scanrMax height\n  sumWaterAux height leftMax rightMax 0",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef sumList (l : List Nat) : Nat :=\n  -- Sum of natural numbers in a list\n  l.foldl (fun acc x => acc + x) 0\n\n@[reducible, simp]\ndef map2 {α β γ} (f : α → β → γ) : List α → List β → List γ\n  | [], _ => []\n  | _, [] => []\n  | a::as, b::bs => f a b :: map2 f as bs\n\n@[reducible, simp]\ndef prefixMaxIncl : List Nat → List Nat\n  | [] => []\n  | x::xs =>\n    -- Build list of prefix maxima including current index\n    let rec go (cur : Nat) : List Nat → List Nat\n      | [] => []\n      | y::ys =>\n        let m := Nat.max cur y\n        m :: go m ys\n    x :: go x xs\n\n@[reducible, simp]\ndef suffixMaxIncl (l : List Nat) : List Nat :=\n  -- Suffix maxima including current index\n  (prefixMaxIncl l.reverse).reverse\n\n@[reducible, simp]\ndef trapWaterTotal (height : List Nat) : Nat :=\n  -- For each index i, water_i = min(leftMax_i, rightMax_i) - height_i (Nat subtraction saturates at 0)\n  let left := prefixMaxIncl height\n  let right := suffixMaxIncl height\n  let cap := map2 Nat.min left right\n  let waterEach := map2 (fun m h => m - h) cap height\n  sumList waterEach",
                "postcond": "result = trapWaterTotal height",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_77": {
          "data_id": "verina_basic_77",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Retrieve the targeted inner array at index1\n  let inner := arr[index1]!\n  -- Update only the element at index2 within the selected inner array\n  let updatedInner := inner.set! index2 val\n  -- Replace the inner array at index1 with the updated one, leaving others unchanged\n  arr.set! index1 updatedInner",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_77",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- Indices must be valid for the targeted update\n  index1 < arr.size ∧ index2 < (arr[index1]!).size",
                "postcond_aux": "",
                "postcond": "-- Outer array size is preserved\n  result.size = arr.size ∧\n  -- All inner arrays except at index1 remain exactly the same\n  (∀ i, i < arr.size → i ≠ index1 → result[i]! = arr[i]!) ∧\n  -- The modified inner array keeps its size\n  (result[index1]!).size = (arr[index1]!).size ∧\n  -- In the modified inner array, only index2 is updated to `val`\n  (∀ j, j < (arr[index1]!).size →\n      result[index1]![j]! = (if j = index2 then val else arr[index1]![j]!))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_78": {
          "data_id": "verina_basic_78",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(x + y, x - y)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (x + y, x - y)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_78": {
          "data_id": "verina_advanced_78",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Nested search: for each index i, scan the tail starting from j = i+1\n  let rec searchFrom (i : Nat) (x : Int) (rest : List Int) (j : Nat) : Option (Nat × Nat) :=\n    match rest with\n    | [] => none\n    | y :: ys =>\n      if x + y == target then\n        some (i, j)\n      else\n        searchFrom i x ys (j + 1)\n\n  let rec outer (i : Nat) (lst : List Int) : Prod Nat Nat :=\n    match lst with\n    | [] => (0, 0) -- Unreachable due to precondition guaranteeing a solution\n    | x :: xs =>\n      match searchFrom i x xs (i + 1) with\n      | some p => p\n      | none   => outer (i + 1) xs\n\n  outer 0 nums",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_78",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- There exists exactly one ordered pair of distinct indices (i < j) within bounds\n  -- such that nums[i] + nums[j] = target.\n  ∃! (p : Nat × Nat),\n    p.fst < p.snd ∧\n    ∃ (h₁ : p.fst < nums.length) (h₂ : p.snd < nums.length),\n      nums.get ⟨p.fst, h₁⟩ + nums.get ⟨p.snd, h₂⟩ = target",
                "postcond_aux": "",
                "postcond": "-- The result must be exactly that unique pair from the precondition.\n  let P : (Nat × Nat) → Prop :=\n    fun p =>\n      p.fst < p.snd ∧\n      ∃ (h₁ : p.fst < nums.length) (h₂ : p.snd < nums.length),\n        nums.get ⟨p.fst, h₁⟩ + nums.get ⟨p.snd, h₂⟩ = target\n  P result ∧ ∀ p, P p → p = result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_79": {
          "data_id": "verina_basic_79",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Return the maximum of two Ints\ndef imax (u v : Int) : Int :=\n  if u < v then v else u\n\n-- Compute the maximum among the first x elements of array a.\n-- Assumes (as per precondition of the main function) that 1 ≤ x < a.size,\n-- so the first x elements exist.\ndef maxFirstX (a : Array Int) (x : Nat) : Int :=\n  -- Process k elements (indices 0..k-1) in reverse order, accumulating the max in m.\n  let rec go (k : Nat) (m : Int) : Int :=\n    match k with\n    | 0 => m\n    | k+1 =>\n      let m' := imax m (a[k]!)\n      go k m'\n  -- Defensive handling for x = 0 (should not occur under the given precondition).\n  if x = 0 then\n    0\n  else\n    -- Initialize with a[0]!, then process the remaining x-1 elements.\n    go (x - 1) (a[0]!)\n\n-- Starting from index `start`, find the first index p with a[p] > m.\n-- If no such index exists in [start, a.size), return the last index a.size - 1.\ndef firstGreaterIdxFrom (a : Array Int) (start : Nat) (m : Int) : Nat :=\n  let n := a.size\n  -- Iterate at most k steps, where k = n - start, ensuring termination.\n  let rec go (k : Nat) (i : Nat) : Nat :=\n    match k with\n    | 0 => n - 1\n    | k+1 =>\n      if h : i < n then\n        if a[i]! > m then i else go k (i + 1)\n      else\n        n - 1\n  let steps := n - start\n  go steps start",
                "code": "let m := maxFirstX a x\n  let p := firstGreaterIdxFrom a x m\n  (m, p)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "1 ≤ x ∧ x < a.size",
                "postcond_aux": "",
                "postcond": "let m := result.fst\n  let p := result.snd\n  -- m is the maximum among the first x elements (indices 0..x-1), and it is attained\n  ((∀ i, i < x → a[i]! ≤ m) ∧ (∃ i, i < x ∧ a[i]! = m)) ∧\n  -- p lies in the range [x, a.size)\n  x ≤ p ∧ p < a.size ∧\n  -- If there exists an element strictly greater than m from index x onward,\n  -- then p is the first index where this happens (minimal such index).\n  ((∃ i, x ≤ i ∧ i < a.size ∧ m < a[i]!) →\n    (m < a[p]! ∧ ∀ i, x ≤ i ∧ i < p → a[i]! ≤ m)) ∧\n  -- If no such element exists, p is set to the last index.\n  ((¬ ∃ i, x ≤ i ∧ i < a.size ∧ m < a[i]!) →\n    p = a.size - 1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_79": {
          "data_id": "verina_advanced_79",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Brute-force search with nested scans over the list.\n  -- We iterate i from 0 upward, and for each i we scan j from i+1 upward.\n  -- The first match found is lexicographically minimal by construction.\n  let rec findFrom (i : Nat) (xs : List Int) : Option (Nat × Nat) :=\n    match xs with\n    | [] => none\n    | x :: xs' =>\n      -- Scan the tail for a matching partner for x at index i\n      let rec findJ (j : Nat) (ys : List Int) : Option (Nat × Nat) :=\n        match ys with\n        | [] => none\n        | y :: ys' =>\n          if x + y == target then\n            some (i, j)\n          else\n            findJ (j + 1) ys'\n      match findJ (i + 1) xs' with\n      | some ij => some ij\n      | none    => findFrom (i + 1) xs'\n  findFrom 0 nums",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_79",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef validPair (nums : List Int) (target : Int) (i j : Nat) : Prop :=\n  i < j ∧\n  ∃ xi xj, nums.get? i = some xi ∧ nums.get? j = some xj ∧ xi + xj = target\n\n@[reducible, simp]\ndef lexFirstPair (nums : List Int) (target : Int) (i j : Nat) : Prop :=\n  validPair nums target i j ∧\n  -- Lexicographically first among all valid pairs:\n  -- minimal i; among those with the same i, minimal j.\n  ∀ i' j', validPair nums target i' j' → (i ≤ i') ∧ (i = i' → j ≤ j')",
                "postcond": "let hasPair := ∃ i j, validPair nums target i j\n  -- Completeness: if a valid pair exists, result is some lexicographically-first pair;\n  -- otherwise, result is none.\n  ((result = none) ↔ ¬ hasPair) ∧\n  ((∃ i j, result = some (i, j) ∧ lexFirstPair nums target i j) ↔ hasPair)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_80": {
          "data_id": "verina_advanced_80",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper to search a value in a list of (value, index) pairs.\n-- Returns the index if a matching value is found.\ndef findInList (seen : List (Int × Nat)) (need : Int) : Option Nat :=\n  match seen with\n  | [] => none\n  | (v, j) :: rest =>\n    if v == need then\n      some j\n    else\n      findInList rest need",
                "code": "-- We perform a single pass over the array while keeping a list of seen (value, index) pairs.\n  -- For each element, we look for (target - current) in the seen list.\n  -- Since seen only contains indices less than the current index, the returned pair is naturally sorted.\n  let n := nums.size\n  let rec loop (i : Nat) (seen : List (Int × Nat)) (fuel : Nat) : Array Nat :=\n    match fuel with\n    | 0 => #[]  -- Should not happen due to the problem's guarantee of a solution.\n    | Nat.succ fuel' =>\n      if h : i < n then\n        let v := nums[i]!\n        match findInList seen (target - v) with\n        | some j =>\n          -- j < i because j comes from seen; return sorted indices\n          if j ≤ i then\n            #[j, i]\n          else\n            #[i, j]\n        | none =>\n          loop (i + 1) ((v, i) :: seen) fuel'\n      else\n        #[]  -- Should not happen if input satisfies the precondition.\n  loop 0 [] n",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- There is exactly one pair of distinct indices (i, j) with i < j whose elements sum to target.\n  ∃! p : Nat × Nat,\n    p.1 < p.2 ∧\n    p.1 < nums.size ∧\n    p.2 < nums.size ∧\n    nums[p.1]! + nums[p.2]! = target",
                "postcond_aux": "",
                "postcond": "-- The result contains exactly two sorted indices i < j that are in-bounds\n  -- and whose elements sum to target. Moreover, by uniqueness, any other\n  -- in-bounds sorted pair summing to target must be equal to (i, j).\n  ∃ i j : Nat,\n    result.size = 2 ∧\n    i = result[0]! ∧\n    j = result[1]! ∧\n    i < j ∧\n    i < nums.size ∧\n    j < nums.size ∧\n    nums[i]! + nums[j]! = target ∧\n    (∀ k l : Nat,\n      k < l →\n      k < nums.size →\n      l < nums.size →\n      nums[k]! + nums[l]! = target →\n      k = i ∧ l = j)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_80": {
          "data_id": "verina_basic_80",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Helper: check if `key` occurs exactly once in a list.\n-- We carry a flag `found` that is true iff we've already seen the key once.\ndef exactlyOnceInList (xs : List Int) (key : Int) (found : Bool) : Bool :=\n  match xs with\n  | [] => found\n  | x :: xs' =>\n      if x == key then\n        if found then\n          false\n        else\n          exactlyOnceInList xs' key true\n      else\n        exactlyOnceInList xs' key found",
                "code": "-- Convert the array to a list and run the helper that short-circuits on a second occurrence.\n  exactlyOnceInList a.toList key false",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_80",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- result is true iff `key` occurs at exactly one index of `a`\n  result = decide (∃! i : Nat, i < a.size ∧ a[i]! = key)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_advanced_81": {
          "data_id": "verina_advanced_81",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_advanced_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-\nAuxiliary helpers:\n- insertUnique: inserts an element into a list that is already sorted in ascending order\n  without introducing duplicates.\n- foldInsert: folds insertUnique over the input list to produce a sorted list with unique elements.\n-/\nnamespace UniqueSorted\n\n-- Insert an element into an already-sorted (ascending) list without introducing duplicates.\ndef insertUnique (x : Int) : List Int → List Int\n| [] => [x]\n| y :: ys =>\n  -- Use propositional conditions with Decidable instances available for Int\n  if hxy : x < y then\n    x :: y :: ys\n  else if heq : x = y then\n    -- x is already present; skip inserting to avoid duplicates\n    y :: ys\n  else\n    -- x ≥ y and x ≠ y ⇒ y < x; keep y and insert into the tail\n    y :: insertUnique x ys\n\n-- Fold insertion over the whole list, accumulating a sorted list without duplicates.\ndef foldInsert (arr : List Int) : List Int :=\n  let rec go (acc : List Int) (rest : List Int) : List Int :=\n    match rest with\n    | [] => acc\n    | x :: xs => go (insertUnique x acc) xs\n  go [] arr\n\nend UniqueSorted",
                "code": "-- Build a sorted list without duplicates by folding insertions\n  UniqueSorted.foldInsert arr",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_advanced_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- result contains exactly the elements of arr, has no duplicates, and is sorted ascending\n  List.Nodup result ∧\n  List.Sorted (· ≤ ·) result ∧\n  (∀ x : Int, x ∈ result ↔ x ∈ arr)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_81": {
          "data_id": "verina_basic_81",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We return a pair (remainder, quotient) as Ints.\n  match y with\n  | 0 =>\n    -- When divisor is zero, no division is performed: (r, q) = (x, 0)\n    (Int.ofNat x, 0)\n  | Nat.succ y' =>\n    -- When divisor is nonzero, use natural number division and modulus,\n    -- then cast the results to Int.\n    let q : Nat := x / (Nat.succ y')\n    let r : Nat := x % (Nat.succ y')\n    (Int.ofNat r, Int.ofNat q)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_81",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "let r := result.fst\n  let q := result.snd\n  -- When y = 0, no division is performed: return (x, 0) as integers.\n  (y = 0 → result = (Int.ofNat x, 0))\n  ∧\n  -- When y ≠ 0, q and r satisfy the division algorithm properties over Int.\n  (y ≠ 0 →\n    q * (Int.ofNat y) + r = Int.ofNat x\n    ∧ 0 ≤ r\n    ∧ r < Int.ofNat y\n    ∧ 0 ≤ q)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_82": {
          "data_id": "verina_basic_82",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_82",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Assuming the precondition ensures the array is non-empty,\n  -- return a slice of the array starting from index 1 to the end.\n  a.extract 1 a.size",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_82",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "0 < a.size",
                "postcond_aux": "",
                "postcond": "result.size = a.size - 1 ∧\n  (∀ i, i < result.size → result[i]! = a[i + 1]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_83": {
          "data_id": "verina_basic_83",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_83",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Append all elements of b to a using a left fold and push\n  b.foldl (fun acc x => acc.push x) a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_83",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.size = a.size + b.size\n  ∧ (∀ i, i < a.size → result[i]! = a[i]!)\n  ∧ (∀ j, j < b.size → result[a.size + j]! = b[j]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_84": {
          "data_id": "verina_basic_84",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_84",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Map over the array, replacing elements greater than k with -1\n  arr.map (fun x => if x > k then (-1) else x)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_84",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.size = arr.size ∧\n  ∀ i, i < arr.size →\n    result[i]! = (if arr[i]! > k then (-1 : Int) else arr[i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_85": {
          "data_id": "verina_basic_85",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_85",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Reverse the array by iterating from the end to the beginning\n  let n := a.size\n  let mut i := n\n  let mut b : Array Int := Array.mkEmpty n\n  while i > 0 do\n    let j := i - 1\n    b := b.push a[j]!\n    i := j\n  b",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_85",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- The result must have the same length and be the exact reverse of the input.\n  result.size = a.size ∧\n  (∀ i, i < a.size → result[i]! = a[a.size - 1 - i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_86": {
          "data_id": "verina_basic_86",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_86",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Handle empty array early\n  let n := a.size\n  if n = 0 then\n    #[]\n  else\n    -- Normalize the offset to the array size (convert to Nat since offset ≥ 0 by precondition)\n    let k := (Int.toNat offset) % n\n    -- Build the rotated array: new[i] = a[(i + k) % n]\n    Array.init n (fun i => a[((i : Nat) + k) % n]!)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_86",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "0 ≤ offset",
                "postcond_aux": "",
                "postcond": "result.size = a.size ∧\n  (∀ (i : Nat), i < result.size → result[i]! = a[(i + Int.toNat offset) % a.size]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_87": {
          "data_id": "verina_basic_87",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_87",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-\n  Swap elements at positions i and j in array a.\n  If either index is out of bounds, return the array unchanged.\n-/\ndef swap (a : Array Int) (i j : Nat) : Array Int :=\n  if hi : i < a.size ∧ j < a.size then\n    let xi := a[i]!\n    let xj := a[j]!\n    let a1 := a.set! i xj\n    let a2 := a1.set! j xi\n    a2\n  else\n    a\n\n/-\n  Find the index of the minimum element in the subarray a[start .. a.size).\n  If start is out of bounds (start ≥ a.size), return start.\n-/\ndef findMinIndex (a : Array Int) (start : Nat) : Nat :=\n  if h : start < a.size then\n    let idxs : List Nat := (List.range (a.size - start)).map (fun j => start + j)\n    idxs.foldl\n      (fun m i => if a[i]! < a[m]! then i else m)\n      start\n  else\n    start",
                "code": "-- Perform selection sort by iterating over all positions\n  (List.range a.size).foldl\n    (fun arr i =>\n      let minIdx := findMinIndex arr i\n      if minIdx = i then\n        arr\n      else\n        swap arr i minIdx)\n    a",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_87",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef NonDecreasing (arr : Array Int) : Prop :=\n  -- Non-decreasing means every adjacent pair is ordered\n  ∀ i : Nat, i + 1 < arr.size → arr[i]! ≤ arr[i + 1]!\n\n@[reducible, simp]\ndef IsPermutation (a b : Array Int) : Prop :=\n  -- b is a permutation of a if there is a bijection between indices\n  -- that reorders a to b (sizes must match)\n  b.size = a.size ∧ ∃ e : Equiv (Fin b.size) (Fin a.size), ∀ i : Fin b.size, b[i] = a[e i]",
                "postcond": "NonDecreasing result ∧ IsPermutation a result",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_88": {
          "data_id": "verina_basic_88",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_88",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Build the array by pushing elements from the list in order\n  xs.foldl (fun acc x => acc.push x) #[]",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_88",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.size = xs.length ∧ ∀ i (hi : i < xs.length), result[i]! = xs.get ⟨i, hi⟩",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_89": {
          "data_id": "verina_basic_89",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_89",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "/-- Boolean membership check: does list `l` contain integer `x`? -/\ndef containsInt (l : List Int) (x : Int) : Bool :=\n  match l with\n  | [] => false\n  | y :: ys => if x == y then true else containsInt ys x\n\n/-- Remove duplicates while preserving the order of first occurrences. -/\ndef dedupPreserveFirst (s : List Int) : List Int :=\n  -- We carry:\n  --   res  : collected unique elements in reverse order\n  --   seen : elements we've already encountered\n  let (res, _) :=\n    s.foldl\n      (fun (acc : List Int × List Int) (x : Int) =>\n        let (res, seen) := acc\n        if containsInt seen x then\n          (res, seen)\n        else\n          (x :: res, x :: seen))\n      ([], [])\n  res.reverse",
                "code": "dedupPreserveFirst s",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_89",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "-- No preconditions, always allowed\n  -- Postcondition:\n  -- 1) result contains no duplicates\n  -- 2) result contains exactly the elements that appear in s (set equality via membership)\n  -- 3) The order of elements in result is the order of their first appearance in s:\n  --    among elements present in result, comparing first-occurrence indices in s\n  --    agrees with comparing their positions in result.\n  List.Nodup result\n  ∧ (∀ x, x ∈ result ↔ x ∈ s)\n  ∧ (∀ x y, x ∈ result → y ∈ result →\n        (s.indexOf x < s.indexOf y ↔ result.indexOf x < result.indexOf y))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_90": {
          "data_id": "verina_basic_90",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_90",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Use the precondition only to satisfy the parameter (not needed in the logic here)\n  let _ := h_precond\n\n  -- Determine the matrix dimensions\n  let rows := a.size\n  let cols := (a[0]!).size\n\n  -- Recursive helper with a fuel to ensure termination. It performs the classic \"staircase\" search\n  -- starting from the top-right corner and moving left or down accordingly.\n  let rec go (r c fuel : Nat) : (Int × Int) :=\n    match fuel with\n    | 0 => (-1, -1)\n    | fuel' + 1 =>\n      if h_r : r < rows then\n        if h_c : c < cols then\n          let val := a[r]![c]!\n          if val == key then\n            (Int.ofNat r, Int.ofNat c)\n          else\n            -- Move left if current value is greater than key; otherwise, move down.\n            if val > key then\n              if c = 0 then\n                (-1, -1)\n              else\n                go r (c - 1) fuel'\n            else\n              go (r + 1) c fuel'\n        else\n          -- Out-of-bounds column (shouldn't happen with our invariants), treat as not found\n          (-1, -1)\n      else\n        -- Ran past the last row: not found\n        (-1, -1)\n  -- Start from top-right corner with enough fuel (rows + cols) to guarantee termination\n  go 0 (cols - 1) (rows + cols)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_90",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "@[reducible, simp]\ndef rowLen (a : Array (Array Int)) : Nat :=\n  (a[0]!).size\n\n@[reducible, simp]\ndef get2d (a : Array (Array Int)) (r c : Nat) : Int :=\n  (a[r]!)[c]!\n\n@[reducible, simp]\ndef KeyInMatrix (a : Array (Array Int)) (key : Int) : Prop :=\n  ∃ r c : Nat, r < a.size ∧ c < rowLen a ∧ get2d a r c = key",
                "precond": "-- Non-empty outer array and non-zero, uniform inner lengths\n  0 < a.size ∧\n  0 < rowLen a ∧\n  (∀ r : Nat, r < a.size → (a[r]!).size = rowLen a) ∧\n  -- Rows are sorted non-decreasing\n  (∀ r : Nat, r < a.size → ∀ c : Nat, c + 1 < rowLen a →\n      get2d a r c ≤ get2d a r (c + 1)) ∧\n  -- Columns are sorted non-decreasing\n  (∀ r : Nat, r + 1 < a.size → ∀ c : Nat, c < rowLen a →\n      get2d a r c ≤ get2d a (r + 1) c)",
                "postcond_aux": "",
                "postcond": "let rows := a.size\n  let cols := rowLen a\n  -- Exact characterization of (-1, -1) as \"key not present\"\n  ((result = (-1, -1)) ↔ ¬ KeyInMatrix a key)\n  ∧\n  -- If a position is returned, it is in-bounds and matches the key\n  (result ≠ (-1, -1) →\n    ∃ r c : Nat,\n      result = (Int.ofNat r, Int.ofNat c) ∧\n      r < rows ∧ c < cols ∧\n      get2d a r c = key)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_91": {
          "data_id": "verina_basic_91",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_91",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Simply return the pair with the inputs swapped\n  (Y, X)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_91",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (Y, X)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_92": {
          "data_id": "verina_basic_92",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_92",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "(Y, X)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_92",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.fst = Y ∧ result.snd = X",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_93": {
          "data_id": "verina_basic_93",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_93",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Swap the two UInt8 values by returning them in reversed order\n  (Y, X)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_93",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.fst = Y ∧ result.snd = X",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_94": {
          "data_id": "verina_basic_94",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_94",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Create a fresh array by mapping identity over the input, effectively copying it\n  s.map (fun x => x)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_94",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result.size = s.size ∧ ∀ i, i < s.size → result[i]! = s[i]!",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_95": {
          "data_id": "verina_basic_95",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_95",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Convert Int indices to Nat (precondition guarantees they are within bounds)\n  let iN := Int.toNat i\n  let jN := Int.toNat j\n\n  -- Read the original values at i and j\n  let vi := arr[iN]!\n  let vj := arr[jN]!\n\n  -- Swap by first writing vj at i, then vi at j\n  let arr1 := arr.set! iN vj\n  let arr2 := arr1.set! jN vi\n  arr2",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_95",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- Indices are non-negative and within bounds after converting to Nat\n  0 ≤ i ∧ 0 ≤ j ∧ Int.toNat i < arr.size ∧ Int.toNat j < arr.size",
                "postcond_aux": "",
                "postcond": "-- Same size and values are swapped at i and j, all other positions unchanged\n  result.size = arr.size ∧\n  result.get? (Int.toNat i) = arr.get? (Int.toNat j) ∧\n  result.get? (Int.toNat j) = arr.get? (Int.toNat i) ∧\n  (∀ k : Nat, k ≠ Int.toNat i → k ≠ Int.toNat j → result.get? k = arr.get? k)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_96": {
          "data_id": "verina_basic_96",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_96",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Simply return the pair with the order swapped\n  (Y, X)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_96",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (Y, X)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_97": {
          "data_id": "verina_basic_97",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_97",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Update the element at index j to 60, leave others unchanged\n  a.mapIdx (fun i x => if i == j then (60 : Int) else x)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_97",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- j must be a valid index into a\n  j < a.size",
                "postcond_aux": "",
                "postcond": "-- Sizes are preserved and all elements are unchanged except at j, which is set to 60\n  result.size = a.size ∧\n  (∀ i, i < a.size → result[i]! = (if i = j then (60 : Int) else a[i]!))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_98": {
          "data_id": "verina_basic_98",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_98",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "x * 3",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_98",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = (3 : Int) * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_99": {
          "data_id": "verina_basic_99",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_99",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "if x < 18 then\n    let twice := x + x\n    twice + x\n  else\n    x * 3",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_99",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 3 * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_100": {
          "data_id": "verina_basic_100",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_100",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- If x is zero, return 0; otherwise return x + 2 * x (which equals 3 * x)\n  if x == 0 then\n    0\n  else\n    x + 2 * x",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_100",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 3 * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_101": {
          "data_id": "verina_basic_101",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_101",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "import Mathlib",
                "code_aux": "-- A simple arithmetic lemma used to justify correctness:\n-- the sum (x + x) + x equals 3 * x over the integers.\ntheorem triple_expr_eq (x : Int) : (x + x) + x = 3 * x := by\n  -- Mathlib provides three_mul: 3 * x = x + x + x\n  -- Our left-hand side is definitionally (x + x) + x = x + x + x\n  simpa using (three_mul x).symm",
                "code": "-- Compute double first, then add the original input to obtain triple.\n  let double := x + x\n  double + x",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_101",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "result = 3 * x",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_102": {
          "data_id": "verina_basic_102",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_102",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Brute-force search for the lexicographically smallest (i, j)\n  let n := nums.size\n\n  -- Search j from i+1 upward using a decreasing \"fuel\" remJ\n  let rec loopJ (i j remJ : Nat) : Option (Nat × Nat) :=\n    match remJ with\n    | 0 => none\n    | Nat.succ rJ =>\n        if nums[i]! + nums[j]! == target then\n          some (i, j)\n        else\n          loopJ i (j + 1) rJ\n\n  -- Iterate i from 0 up to n-2 using a decreasing \"fuel\" remI = number of i positions left\n  let rec loopI (i remI : Nat) : Option (Nat × Nat) :=\n    match remI with\n    | 0 => none\n    | Nat.succ rI =>\n        let jCount := n - (i + 1)\n        match loopJ i (i + 1) jCount with\n        | some p => some p\n        | none => loopI (i + 1) rI\n\n  -- By problem assumption, a valid pair exists; provide a safe default otherwise\n  match loopI 0 (n - 1) with\n  | some p => p\n  | none => (0, 1)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_102",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- The array has at least two elements and there exists at least one valid pair (i, j)\n  -- with i < j, both in-bounds, whose elements sum to target.\n  2 ≤ nums.size ∧\n  ∃ i j : Nat,\n    i < j ∧ i < nums.size ∧ j < nums.size ∧ nums[i]! + nums[j]! = target",
                "postcond_aux": "",
                "postcond": "-- Unpack the result as (i, j).\n  let i := result.fst\n  let j := result.snd\n  -- The returned pair is in-bounds, ordered, and sums to target,\n  -- and it is lexicographically minimal among all valid pairs.\n  (i < j ∧ i < nums.size ∧ j < nums.size ∧ nums[i]! + nums[j]! = target) ∧\n  (∀ i' j' : Nat,\n    i' < j' ∧ i' < nums.size ∧ j' < nums.size ∧ nums[i']! + nums[j']! = target →\n      (i ≤ i' ∧ (i = i' → j ≤ j')))",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_103": {
          "data_id": "verina_basic_103",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_103",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Update index 4 by adding 3 to its current value, then set index 7 to 516.\n  -- The precondition guarantees that the array has at least 8 elements, so these operations are safe.\n  let a' := a.set! 4 (a[4]! + 3)\n  let a'' := a'.set! 7 516\n  a''",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_103",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "8 ≤ a.size",
                "postcond_aux": "",
                "postcond": "result.size = a.size ∧\n  result[4]! = a[4]! + 3 ∧\n  result[7]! = (516 : Int) ∧\n  (∀ i, i < a.size → i ≠ 4 → i ≠ 7 → result[i]! = a[i]!)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_104": {
          "data_id": "verina_basic_104",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_104",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "-- Insert a pair into a list of pairs, keeping the list sorted by the key (ascending).\ndef insertByKey (x : Int × Int) : List (Int × Int) → List (Int × Int)\n  | [] => [x]\n  | y :: ys =>\n    if x.1 ≤ y.1 then\n      x :: y :: ys\n    else\n      y :: insertByKey x ys\n\n-- Insertion sort of a list of (Int × Int) by the key (ascending).\ndef sortByKey : List (Int × Int) → List (Int × Int)\n  | [] => []\n  | x :: xs => insertByKey x (sortByKey xs)\n\n-- Insert all key-value pairs into a Map, overriding existing keys with later ones.\ndef insertAll (m : Map Int Int) (xs : List (Int × Int)) : Map Int Int :=\n  List.foldl (fun acc (p : Int × Int) => insert acc p.1 p.2) m xs",
                "code": "-- Merge by first inserting all from m1, then from m2 (so m2 overrides).\n  let merged := insertAll (insertAll empty m1.entries) m2.entries\n  -- Ensure the resulting entries are sorted by key (ascending).\n  let sortedEntries := sortByKey merged.entries\n  ⟨sortedEntries⟩",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_104",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef HasKey (m : Map Int Int) (k : Int) : Prop :=\n  ∀ {v : Int}, (k, v) ∈ m.entries → True\n\n@[reducible, simp]\ndef PairIn (m : Map Int Int) (k v : Int) : Prop :=\n  (k, v) ∈ m.entries\n\n@[reducible, simp]\ndef sortedByKey : List (Int × Int) → Prop\n| [] => True\n| p :: ps => (∀ q ∈ ps, p.1 ≤ q.1) ∧ sortedByKey ps",
                "postcond": "sortedByKey result.entries\n  ∧ (∀ k, HasKey m2 k → HasKey result k)\n  ∧ (∀ k, HasKey m1 k → HasKey result k)\n  ∧ (∀ k, HasKey result k → HasKey m1 k ∨ HasKey m2 k)\n  ∧ (∀ k v, PairIn result k v → HasKey m2 k → PairIn m2 k v)\n  ∧ (∀ k v, PairIn result k v → ¬ HasKey m2 k → PairIn m1 k v)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_105": {
          "data_id": "verina_basic_105",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_105",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute element-wise product, defaulting missing elements to 0 via get!\n  let n := Nat.max a.size b.size\n  let rec go (i fuel : Nat) (acc : Array Int) : Array Int :=\n    match fuel with\n    | 0 => acc\n    | Nat.succ fuel' =>\n      -- a[i]! and b[i]! yield 0 when i is out of bounds (Int is Inhabited with 0)\n      let acc := acc.push (a[i]! * b[i]!)\n      go (i + 1) fuel' acc\n  go 0 n (Array.mkEmpty n)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_105",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- Arrays must be of equal length for the specification to hold\n  a.size = b.size",
                "postcond_aux": "",
                "postcond": "-- Result length matches inputs and each element is the product a[i] * b[i]\n  result.size = a.size ∧\n  ∀ i, i < a.size → result[i]! = a[i]! * b[i]!",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_106": {
          "data_id": "verina_basic_106",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_106",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- We fold over array `a`, carrying the current index in `b` and the accumulating result.\n  let (_, result) :=\n    a.foldl\n      (fun (p : Nat × Array Int) (x : Int) =>\n        let i   := p.fst\n        let acc := p.snd\n        -- Sum corresponding elements and push into the result; use b[i]! as instructed\n        (i + 1, acc.push (x + b[i]!))\n      )\n      (0, #[])\n  result",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_106",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "-- Arrays must have equal length to allow element-wise summation\n  a.size = b.size",
                "postcond_aux": "",
                "postcond": "-- The result array has the same size as inputs,\n  -- and each element is the sum of corresponding elements from a and b.\n  result.size = a.size ∧\n  ∀ i, i < result.size → result[i]! = a[i]! + b[i]!",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_107": {
          "data_id": "verina_basic_107",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_107",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Compute the integer average using Euclidean division on Int (floor division for positive divisor).\n  -- This guarantees 2 * avg ∈ {a + b, a + b - 1}, hence within [a + b - 1, a + b + 1].\n  let s := a + b\n  s / 2",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_107",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "",
                "postcond": "(a + b - 1) ≤ 2 * result ∧ 2 * result ≤ (a + b + 1)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        },
        "verina_basic_108": {
          "data_id": "verina_basic_108",
          "task_reports": {
            "execute_code_gen": {
              "task_name": "execute_code_gen",
              "data_id": "verina_basic_108",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": true,
                "spec": false,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "-- Build partial sums array starting from 0 and track if any partial sum is negative.\n  let initialArr : Array Int := (Array.mkEmpty (operations.length + 1)).push (0 : Int)\n  let initState : (Array Int × Int × Bool) := (initialArr, (0 : Int), false)\n\n  let (arr, _, negFound) :=\n    operations.foldl\n      (fun (state : Array Int × Int × Bool) (op : Int) =>\n        let (arr, acc, neg) := state\n        let s := acc + op\n        let arr := arr.push s\n        let neg := neg || decide (s < 0)\n        (arr, s, neg))\n      initState\n\n  (arr, negFound)",
                "precond_aux": "",
                "precond": "",
                "postcond_aux": "",
                "postcond": "",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            },
            "execute_spec_gen": {
              "task_name": "execute_spec_gen",
              "data_id": "verina_basic_108",
              "fewshot_example_names": [
                "verina_basic_15",
                "verina_basic_44"
              ],
              "task_flags": {
                "code": false,
                "spec": true,
                "proof": false
              },
              "task_options": {
                "with_ref_spec": false,
                "with_spec_desc": false,
                "with_ref_code": false
              },
              "artifact": {
                "imports": "",
                "code_aux": "",
                "code": "",
                "precond_aux": "",
                "precond": "True",
                "postcond_aux": "@[reducible, simp]\ndef sumFirst (ops : List Int) : Nat → Int\n  | 0 => 0\n  | Nat.succ k =>\n    match ops with\n    | [] => 0\n    | x :: xs => x + sumFirst xs k\n\n@[reducible, simp]\ndef isPartialSums (ops : List Int) (arr : Array Int) : Prop :=\n  -- The array has one more element than the number of operations,\n  -- and arr[k] equals the sum of the first k operations (with arr[0] = 0).\n  arr.size = ops.length + 1 ∧\n  ∀ k, k ≤ ops.length → arr[k]! = sumFirst ops k",
                "postcond": "isPartialSums operations result.fst ∧\n  (result.snd ↔ ∃ i, 1 ≤ i ∧ i ≤ operations.length ∧ result.fst[i]! < 0)",
                "proof_aux": "",
                "proof": ""
              },
              "extra_info": {},
              "scores": {}
            }
          }
        }
      }
    }
  }
}