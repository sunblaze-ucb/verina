# Coq Specification Evaluation

This document describes how the verina framework evaluates LLM-generated specifications in Coq.

## Overview

The evaluation framework tests specifications using **automation tactics** (hammer-like approach) rather than predefined proofs. This allows evaluation of LLM-generated specs without knowing their content ahead of time.

## Evaluation Outcomes

| Outcome | Description | Coq Behavior |
|---------|-------------|--------------|
| **PASS** | Spec is proven correct | Compilation succeeds |
| **FAIL** | Spec is proven incorrect | Type error or contradiction |
| **UNKNOWN** | Automation cannot decide | "No applicable tactic" error |

For UNKNOWN cases, QuickChick (property-based testing) provides a fallback.

## Automation Tactics

### Positive Goals (proving P holds)

```coq
Ltac verina_hammer :=
  solve [
    reflexivity | trivial | easy |
    lia | nia | tauto |
    intuition lia | intuition nia |
    firstorder | firstorder lia |
    vm_compute; reflexivity | vm_compute; lia
  ].
```

**What it handles:**
- Arithmetic: `5 >= 2`, `3 + 4 = 7`
- Propositional logic: `True /\ True`, `A -> A`
- Simple equalities: `true = true`, `12 = 3 * 4`

### Negation Goals (proving ~P)

```coq
Ltac verina_hammer_neg :=
  intro H;
  first [
    discriminate | contradiction |
    lia | nia | tauto |
    intuition lia | easy
  ].
```

**What it handles:**
- Inequality contradictions: `~(0 >= 2)`
- Boolean discrimination: `~(true = false)`
- Arithmetic negations: `~(3 > 5)`

## Framework-Generated Test Examples

### Precondition Soundness Test

Tests that valid inputs satisfy the precondition.

**Generated by:** `template.render_precond_unit_test_sound_decidable()`

```coq
(* <precond_test_decidable>0</precond_test_decidable> *)
Goal isPrime_precond 2.
  unfold isPrime_precond.
  solve [reflexivity | trivial | easy | lia | nia | tauto |
         intuition lia | intuition nia | firstorder | firstorder lia |
         vm_compute; reflexivity | vm_compute; lia].
Qed.
```

**Result:** PASS - `lia` solves `2 >= 2`

### Precondition Completeness Test

Tests that invalid inputs are rejected by the precondition.

**Generated by:** `template.render_precond_unit_test_complete_decidable()`

```coq
(* <precond_test_decidable>0</precond_test_decidable> *)
Goal ~(isPrime_precond 0).
  unfold isPrime_precond.
  intro H.
  first [discriminate | contradiction | lia | nia | tauto | intuition lia | easy].
Qed.
```

**Result:** PASS - `lia` proves `~(0 >= 2)`

### Postcondition Completeness Test

Tests that expected outputs satisfy the postcondition.

**Generated by:** `template.render_postcond_unit_test_complete_decidable()`

```coq
(* <postcond_test_decidable>0</postcond_test_decidable> *)
Goal isPrime_postcond 2 true h2.
  unfold isPrime_postcond.
  solve [reflexivity | trivial | easy | lia | nia | tauto |
         intuition lia | intuition nia | firstorder | firstorder lia |
         vm_compute; reflexivity | vm_compute; lia].
Qed.
```

**Result:** PASS - `reflexivity` solves `true = true`

### Postcondition Soundness Test

Tests that unexpected outputs are rejected by the postcondition.

**Generated by:** `template.render_postcond_unit_test_sound_decidable()`

```coq
(* <postcond_test_decidable>0,0</postcond_test_decidable> *)
Goal ~(isPrime_postcond 2 false h2).
  unfold isPrime_postcond.
  intro H.
  first [discriminate | contradiction | lia | nia | tauto | intuition lia | easy].
Qed.
```

**Result:** PASS - `discriminate` proves `~(false = true)`

## Handling Complex Specs

### Quantified Postconditions (UNKNOWN)

Specs with universal or existential quantifiers typically fail automation:

```coq
(* Complex spec: result = true iff n is prime *)
Definition is_prime_prop (n : nat) : Prop :=
  n >= 2 /\ forall k, 2 <= k < n -> n mod k <> 0.

Definition isPrime_postcond (n : nat) (result : bool) : Prop :=
  (result = true <-> is_prime_prop n).
```

**Automation fails because:**
1. `forall k, ...` introduces a quantifier
2. `<->` (iff) requires bidirectional proof
3. Modular arithmetic reasoning

**Fallback:** QuickChick property-based testing

### QuickChick Plausible Testing

When automation fails, the framework uses QuickChick for property-based testing:

**Generated by:** `template.render_precond_unit_test_sound_plausible()` etc.

```coq
(* <precond_test_undecidable_plausible>0</precond_test_undecidable_plausible> *)
QuickChick (isPrime_precond_dec (5)%Z).

(* <postcond_test_undecidable_plausible>0</postcond_test_undecidable_plausible> *)
QuickChick (isPrime_postcond_dec (2)%Z true).

(* Testing rejection (using negb) *)
(* <postcond_test_undecidable_plausible>0,0</postcond_test_undecidable_plausible> *)
QuickChick (negb (isPrime_postcond_dec (2)%Z false)).
```

**QuickChick output parsing:**
- `+++ Passed` → PASS (no counterexample found)
- `Failed` → FAIL (counterexample found)
- `Gave up` → UNKNOWN (too many discards)

**Requirements for QuickChick:**
- Specs must have decidable (`_dec`) bool-returning versions
- QuickChick requires Docker image with `coq-quickchick` installed

## Test Structure

### Complete Spec Test File

```coq
Require Import ZArith.
Require Import Arith.
Require Import Bool.
Require Import Lia.
Open Scope nat_scope.

(* Precondition *)
Definition isPrime_precond (n : nat) : Prop := n >= 2.

(* Postcondition (simplified for decidability) *)
Definition isPrime_postcond (n : nat) (result : bool)
    (h_precond : isPrime_precond n) : Prop :=
  match n with
  | 2 => result = true
  | 3 => result = true
  | 4 => result = false
  | 5 => result = true
  | _ => True
  end.

(* Precond proofs for postcond tests *)
Lemma h2 : isPrime_precond 2. unfold isPrime_precond. lia. Qed.
Lemma h4 : isPrime_precond 4. unfold isPrime_precond. lia. Qed.

(* Precond Sound Tests *)
Goal isPrime_precond 2.
  unfold isPrime_precond.
  solve [lia].
Qed.

(* Precond Complete Tests *)
Goal ~(isPrime_precond 0).
  unfold isPrime_precond.
  intro H. lia.
Qed.

(* Postcond Complete Tests *)
Goal isPrime_postcond 2 true h2.
  unfold isPrime_postcond.
  solve [reflexivity].
Qed.

(* Postcond Sound Tests *)
Goal ~(isPrime_postcond 2 false h2).
  unfold isPrime_postcond.
  intro H. discriminate.
Qed.
```

## Configuration

### Docker Setup for QuickChick

QuickChick requires a Docker image with Coq and QuickChick installed:

**Build the Docker image:**
```bash
docker build -f docker/Dockerfile.coq -t verina-coq .
```

**Dockerfile (`docker/Dockerfile.coq`):**
```dockerfile
FROM coqorg/coq:8.18
RUN opam update && opam install -y coq-quickchick && opam clean -a -c -s --logs
WORKDIR /workspace
```

### qa_coq.toml

```toml
output_dir = "output/qa_coq"
run_type = "qa"
itp_type = "coq"

[coq_config]
use_quickchick = true   # Enable for plausible testing
quickchick_num_tests = 1000
docker_image = "verina-coq"  # Required for QuickChick
```

### Using CoqCompiler with Docker

```python
from verina.coq import CoqCompiler

# With Docker (required for QuickChick)
compiler = CoqCompiler(docker_image='verina-coq')

# Without Docker (local coqc)
compiler = CoqCompiler()
```

## Implementation

### Template Class

`src/verina/coq/template.py`:

```python
class CoqGenerationTaskTemplate(ITPTemplate):
    AUTOMATION_TACTICS = (
        "reflexivity | trivial | easy | "
        "lia | nia | tauto | "
        "intuition lia | intuition nia | "
        "firstorder | firstorder lia | "
        "vm_compute; reflexivity | vm_compute; lia"
    )

    NEGATION_AUTOMATION_TACTICS = (
        "discriminate | contradiction | "
        "lia | nia | tauto | "
        "intuition lia | easy"
    )
```

### Key Methods

**Decidable Tests (Automation Tactics):**

| Method | Purpose |
|--------|---------|
| `render_precond_unit_test_sound_decidable` | Test precond accepts valid input |
| `render_precond_unit_test_complete_decidable` | Test precond rejects invalid input |
| `render_postcond_unit_test_complete_decidable` | Test postcond accepts expected output |
| `render_postcond_unit_test_sound_decidable` | Test postcond rejects unexpected output |

**Plausible Tests (QuickChick):**

| Method | Purpose |
|--------|---------|
| `render_precond_unit_test_sound_plausible` | QuickChick test precond accepts valid input |
| `render_precond_unit_test_complete_plausible` | QuickChick test precond rejects invalid input |
| `render_postcond_unit_test_complete_plausible` | QuickChick test postcond accepts expected output |
| `render_postcond_unit_test_sound_plausible` | QuickChick test postcond rejects unexpected output |

## Limitations

1. **Quantifiers**: Automation cannot handle `forall` or `exists`
2. **Complex arithmetic**: Non-linear modular arithmetic may fail
3. **Custom types**: Only built-in types (nat, Z, bool) are well-supported
4. **QuickChick**: Requires decidable (bool-returning) checkers

## Comparison with Lean

| Aspect | Coq | Lean |
|--------|-----|------|
| Decidable | `solve [lia \| ...]` | `decide` |
| Plausible | QuickChick | `plausible` |
| Arithmetic | `lia`, `nia` | `omega`, `decide` |
| Automation | `intuition`, `firstorder` | `aesop`, `simp` |
